<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/img/duck.jpeg">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/img/duck.jpeg">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/img/duck.jpeg">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/img/duck.jpeg">
    
    
        <link rel="mask-icon" href="/img/duck.jpeg">
    


    <!-- meta -->


<title>pwntools | Gwoo</title>


    <meta name="keywords" content="pwn">




    <!-- OpenGraph -->
 
    <meta name="description" content="转自: https:&#x2F;&#x2F;blog.csdn.net&#x2F;kelxLZ&#x2F;article&#x2F;details&#x2F;123152529    Author：ZERO-A-ONE   Date：2022-02-24   本文翻译自：https:&#x2F;&#x2F;github.com&#x2F;Gallopsled&#x2F;[pwntools](https:&#x2F;&#x2F;so.csdn.net&#x2F;so&#x2F;search?q&#x3D;pwntools&amp;spm&#x3D;1001">
<meta property="og:type" content="article">
<meta property="og:title" content="pwntools">
<meta property="og:url" content="http://example.com/2023/05/11/pwntools/index.html">
<meta property="og:site_name" content="Gwoo">
<meta property="og:description" content="转自: https:&#x2F;&#x2F;blog.csdn.net&#x2F;kelxLZ&#x2F;article&#x2F;details&#x2F;123152529    Author：ZERO-A-ONE   Date：2022-02-24   本文翻译自：https:&#x2F;&#x2F;github.com&#x2F;Gallopsled&#x2F;[pwntools](https:&#x2F;&#x2F;so.csdn.net&#x2F;so&#x2F;search?q&#x3D;pwntools&amp;spm&#x3D;1001">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-05-10T16:51:30.000Z">
<meta property="article:modified_time" content="2023-05-11T13:11:57.783Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary_large_image">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/dark.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.4.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">孤鹜</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        pwntools
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2023/05/" class="post-meta__date button">2023-05-11</a>
        
 
        
     
    <span id="leancloud_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span>总访问量</span>
        <span id="leancloud_value_page_pv"></span>
        <span></span>
    </span>

    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%AE%E5%BD%95"><span class="toc-text">二、目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85Pwntools"><span class="toc-text">三、安装Pwntools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85"><span class="toc-text">3.1 验证安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B6%E5%AE%83%E6%9E%B6%E6%9E%84"><span class="toc-text">3.2 其它架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">四、管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E7%A1%80IO"><span class="toc-text">4.1 基础IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2 进程和基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%9A%E8%AF%9D%E4%BA%92%E5%8A%A8"><span class="toc-text">4.3 会话互动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BD%91%E7%BB%9C"><span class="toc-text">4.4 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%AE%89%E5%85%A8%E7%9A%84Shell"><span class="toc-text">4.5 安全的Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3"><span class="toc-text">4.6 串行端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">五、实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E6%95%B4%E6%95%B0"><span class="toc-text">5.1 打包和解包整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6I-O"><span class="toc-text">5.2 文件I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%93%88%E5%B8%8C%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-text">5.3 哈希和编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A0%B7%E4%BE%8B%E7%94%9F%E6%88%90"><span class="toc-text">5.4 样例生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Bytes-vs-Strings"><span class="toc-text">六、Bytes vs. Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Python2"><span class="toc-text">6.1 Python2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Python3"><span class="toc-text">6.2 Python3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%BA%BB%E7%83%A6"><span class="toc-text">6.3 麻烦</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%8E%AF%E5%A2%83"><span class="toc-text">七、环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="toc-text">7.1 环境设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81ELFs"><span class="toc-text">八、ELFs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8A%A0%E8%BD%BDELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.1 加载ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">8.2 使用符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%94%B9%E5%8F%98%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80"><span class="toc-text">8.3 改变基本地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%AF%BB%E5%8F%96ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.4 读取ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%AF%B9ELF%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E8%A1%A5"><span class="toc-text">8.5 对ELF文件进行修补</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%90%9C%E7%B4%A2ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.6 搜索ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E6%9E%84%E5%BB%BAELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.7 构建ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.8 运行和调试ELF文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B1%87%E7%BC%96"><span class="toc-text">九、汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96"><span class="toc-text">9.1 基础汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%8E%B0%E6%88%90%E7%9A%84%E6%B1%87%E7%BC%96%EF%BC%88shellcraft%EF%BC%89"><span class="toc-text">9.2 现成的汇编（shellcraft）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.3 命令行工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">9.4 异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E7%8E%B0%E6%88%90%E6%B1%87%E7%BC%96"><span class="toc-text">9.4.1 现成汇编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.4.2 命令行工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">十、调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%85%88%E5%89%8D%E6%9D%A1%E4%BB%B6"><span class="toc-text">10.1 先前条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%9C%A8GDB%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.2 在GDB下启动一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E9%99%84%E5%8A%A0%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3 附加到一个正在运行的进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3.1 本地进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">10.3.2 远程服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E8%B0%83%E8%AF%95%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">10.3 调试异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%8F%90%E7%A4%BA%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-text">10.3.1 提示和限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%EF%BC%88Pwntools%E8%87%AA%E8%BA%AB%EF%BC%89"><span class="toc-text">10.4 故障排除（Pwntools自身）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE%EF%BC%88%E5%B7%A5%E4%BD%9C%E8%AF%A6%E6%83%85%EF%BC%89"><span class="toc-text">10.4.1 幕后花絮（工作详情）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3"><span class="toc-text">10.4.2 指定一个终端窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">10.4.3 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-4-%E6%97%A0%E6%B3%95%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B%E4%B8%AD"><span class="toc-text">10.4.4 无法附加到进程中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-5-argv0-and-argc-0"><span class="toc-text">10.4.5 argv0 and argc&#x3D;&#x3D;0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81ROP"><span class="toc-text">十一、ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E8%83%8C%E6%99%AF"><span class="toc-text">11.1 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AAELF"><span class="toc-text">11.2 加载一个ELF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E4%BF%AE%E5%A4%8D%E5%9C%B0%E5%9D%80"><span class="toc-text">11.2.1 修复地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E6%A3%80%E6%9F%A5gadgets"><span class="toc-text">11.3 检查gadgets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89gadgets"><span class="toc-text">11.3.1 查看所有gadgets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E7%9C%9F%E6%AD%A3%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84gadgets"><span class="toc-text">11.3.2 真正查看所有的gadgets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-text">11.4 添加原始数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%AF%BC%E5%87%BAROP%E6%A0%88"><span class="toc-text">11.5 导出ROP栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E6%8F%90%E5%8F%96%E5%8E%9F%E5%A7%8B%E5%AD%97%E8%8A%82"><span class="toc-text">11.6 提取原始字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E7%A5%9E%E5%A5%87%E5%9C%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.7 神奇地调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%90%8D%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.8 使用函数名来调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9-%E5%A4%9A%E9%87%8DELF"><span class="toc-text">11.9 多重ELF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAshell"><span class="toc-text">11.10 获取一个shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-text">十二、日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%8A%9F%E8%83%BD"><span class="toc-text">12.1 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">12.2 命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E7%8E%AF%E5%A2%83"><span class="toc-text">12.3 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E7%AE%A1%E9%81%93"><span class="toc-text">12.4 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E8%8C%83%E5%9B%B4"><span class="toc-text">12.5 范围</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">Article Directory</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%AE%E5%BD%95"><span class="toc-text">二、目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85Pwntools"><span class="toc-text">三、安装Pwntools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85"><span class="toc-text">3.1 验证安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B6%E5%AE%83%E6%9E%B6%E6%9E%84"><span class="toc-text">3.2 其它架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">四、管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E7%A1%80IO"><span class="toc-text">4.1 基础IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2 进程和基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%9A%E8%AF%9D%E4%BA%92%E5%8A%A8"><span class="toc-text">4.3 会话互动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BD%91%E7%BB%9C"><span class="toc-text">4.4 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%AE%89%E5%85%A8%E7%9A%84Shell"><span class="toc-text">4.5 安全的Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3"><span class="toc-text">4.6 串行端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">五、实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E6%95%B4%E6%95%B0"><span class="toc-text">5.1 打包和解包整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6I-O"><span class="toc-text">5.2 文件I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%93%88%E5%B8%8C%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-text">5.3 哈希和编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A0%B7%E4%BE%8B%E7%94%9F%E6%88%90"><span class="toc-text">5.4 样例生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Bytes-vs-Strings"><span class="toc-text">六、Bytes vs. Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Python2"><span class="toc-text">6.1 Python2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Python3"><span class="toc-text">6.2 Python3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%BA%BB%E7%83%A6"><span class="toc-text">6.3 麻烦</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%8E%AF%E5%A2%83"><span class="toc-text">七、环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="toc-text">7.1 环境设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81ELFs"><span class="toc-text">八、ELFs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8A%A0%E8%BD%BDELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.1 加载ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">8.2 使用符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%94%B9%E5%8F%98%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80"><span class="toc-text">8.3 改变基本地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%AF%BB%E5%8F%96ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.4 读取ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%AF%B9ELF%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E8%A1%A5"><span class="toc-text">8.5 对ELF文件进行修补</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%90%9C%E7%B4%A2ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.6 搜索ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E6%9E%84%E5%BB%BAELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.7 构建ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.8 运行和调试ELF文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B1%87%E7%BC%96"><span class="toc-text">九、汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96"><span class="toc-text">9.1 基础汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%8E%B0%E6%88%90%E7%9A%84%E6%B1%87%E7%BC%96%EF%BC%88shellcraft%EF%BC%89"><span class="toc-text">9.2 现成的汇编（shellcraft）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.3 命令行工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">9.4 异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E7%8E%B0%E6%88%90%E6%B1%87%E7%BC%96"><span class="toc-text">9.4.1 现成汇编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.4.2 命令行工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">十、调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%85%88%E5%89%8D%E6%9D%A1%E4%BB%B6"><span class="toc-text">10.1 先前条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%9C%A8GDB%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.2 在GDB下启动一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E9%99%84%E5%8A%A0%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3 附加到一个正在运行的进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3.1 本地进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">10.3.2 远程服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E8%B0%83%E8%AF%95%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">10.3 调试异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%8F%90%E7%A4%BA%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-text">10.3.1 提示和限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%EF%BC%88Pwntools%E8%87%AA%E8%BA%AB%EF%BC%89"><span class="toc-text">10.4 故障排除（Pwntools自身）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE%EF%BC%88%E5%B7%A5%E4%BD%9C%E8%AF%A6%E6%83%85%EF%BC%89"><span class="toc-text">10.4.1 幕后花絮（工作详情）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3"><span class="toc-text">10.4.2 指定一个终端窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">10.4.3 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-4-%E6%97%A0%E6%B3%95%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B%E4%B8%AD"><span class="toc-text">10.4.4 无法附加到进程中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-5-argv0-and-argc-0"><span class="toc-text">10.4.5 argv0 and argc&#x3D;&#x3D;0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81ROP"><span class="toc-text">十一、ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E8%83%8C%E6%99%AF"><span class="toc-text">11.1 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AAELF"><span class="toc-text">11.2 加载一个ELF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E4%BF%AE%E5%A4%8D%E5%9C%B0%E5%9D%80"><span class="toc-text">11.2.1 修复地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E6%A3%80%E6%9F%A5gadgets"><span class="toc-text">11.3 检查gadgets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89gadgets"><span class="toc-text">11.3.1 查看所有gadgets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E7%9C%9F%E6%AD%A3%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84gadgets"><span class="toc-text">11.3.2 真正查看所有的gadgets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-text">11.4 添加原始数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%AF%BC%E5%87%BAROP%E6%A0%88"><span class="toc-text">11.5 导出ROP栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E6%8F%90%E5%8F%96%E5%8E%9F%E5%A7%8B%E5%AD%97%E8%8A%82"><span class="toc-text">11.6 提取原始字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E7%A5%9E%E5%A5%87%E5%9C%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.7 神奇地调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%90%8D%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.8 使用函数名来调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9-%E5%A4%9A%E9%87%8DELF"><span class="toc-text">11.9 多重ELF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAshell"><span class="toc-text">11.10 获取一个shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-text">十二、日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%8A%9F%E8%83%BD"><span class="toc-text">12.1 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">12.2 命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E7%8E%AF%E5%A2%83"><span class="toc-text">12.3 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E7%AE%A1%E9%81%93"><span class="toc-text">12.4 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E8%8C%83%E5%9B%B4"><span class="toc-text">12.5 范围</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <p>转自: <a target="_blank" rel="noopener" href="https://blog.csdn.net/kelxLZ/article/details/123152529">https://blog.csdn.net/kelxLZ/article/details/123152529</a></p>
<ul>
<li>  Author：ZERO-A-ONE</li>
<li>  Date：2022-02-24</li>
</ul>
<blockquote>
<p>本文翻译自：<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/[pwntools](https://so.csdn.net/so/search?q=pwntools&amp;spm=1001.2101.3001.7020)-tutorial%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E8%80%83%E8%99%91%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%AD%E6%96%87%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8Dpwntools%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E6%96%87%E7%AB%A0%E9%83%BD%E6%AF%94%E8%BE%83%E8%80%81%E5%92%8C%E6%9D%82%E4%B9%B1%EF%BC%8C%E4%B8%94%E8%BD%AC%E6%8D%A2%E4%B8%BAPython3%E5%90%8E%E5%8F%88%E6%9C%89%E8%AE%B8%E5%A4%9A%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E5%BE%88%E5%A4%9A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%84%9F%E5%88%B0%E5%8F%AF%E4%BB%A5%E7%BF%BB%E8%AF%91%E4%B8%80%E4%B8%8B">https://github.com/Gallopsled/[pwntools](https://so.csdn.net/so/search?q=pwntools&amp;spm=1001.2101.3001.7020)-tutorial，主要是考虑到目前中文互联网中关于系统介绍pwntools使用方法的文章都比较老和杂乱，且转换为Python3后又有许多零零散散的问题，看到这个仓库中包含了很多使用技巧和调试问题的解决方案，感到可以翻译一下</a></p>
</blockquote>
<p>这个资源库包含了一些开始使用pwntools（和pwntools）的基本教程。</p>
<p>这些教程并不致力于解释<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B&spm=1001.2101.3001.7020">逆向工程</a>或利用，而是假定读者有这方面的知识。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>Pwntools</code>是一个工具包，使选手们在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CTF&spm=1001.2101.3001.7020">CTF</a>期间的尽可能容易的编写EXP，并使EXP尽可能的容易阅读。</p>
<p>有些代码每个人都写过无数次，而且每个人都有自己的方法。Pwntools的目标是以半标准的方式提供所有这些，这样你就可以停止复制粘贴相同的<code>struct.unpack(&#39;&gt;I&#39;, x)</code>代码，而是使用更多稍微清晰的包装器，如<code>pac</code>k或<code>p32</code>甚至<code>p64(..., endian=&#39;big&#39;, sign=True)</code>。</p>
<p>除了对日常的功能进行方便的包装外，它还提供了一套非常丰富的IO管道，将所有你曾经执行过的IO封装在一个统一的界面中。从本地攻击切换到远程攻击，或者通过SSH进行本地攻击，都只是修改一行代码的工作。</p>
<p>最后但并非最不重要的是，它还包括一系列用于中级到高级使用情况的开发协助工具。这些工具包括给定内存泄露基元的远程符号解析（<code>MemLeak</code>和<code>DynELF</code>），ELF解析和修补（<code>ELF</code>），以及ROP小工具发现和调用链构建（<code>ROP</code>）。</p>
<h2 id="二、目录"><a href="#二、目录" class="headerlink" title="二、目录"></a>二、目录</h2><ul>
<li>Installing Pwntools</li>
<li>Tubes<ul>
<li>  Basic Tubes</li>
<li>  Interactive Shells</li>
<li>  Processes</li>
<li>  Networking</li>
<li>  Secure Shell</li>
<li>  Serial Ports</li>
</ul>
</li>
<li>Utility<ul>
<li>  Encoding and Hashing</li>
<li>  Packing / unpacking integers</li>
<li>  Pattern generation</li>
<li>  Safe evaluation</li>
</ul>
</li>
<li>Bytes vs. Strings<ul>
<li>Python2</li>
<li>Python3<ul>
<li>  Gotchas</li>
</ul>
</li>
</ul>
</li>
<li>Context<ul>
<li>  Architecture</li>
<li>  Endianness</li>
<li>  Log verbosity</li>
<li>  Timeout</li>
</ul>
</li>
<li>ELFs<ul>
<li>  Reading and writing</li>
<li>  Patching</li>
<li>  Symbols</li>
</ul>
</li>
<li>Assembly<ul>
<li>  Assembling shellcode</li>
<li>  Disassembling bytes</li>
<li>  Shellcraft library</li>
<li>  Constants</li>
</ul>
</li>
<li>Debugging<ul>
<li>  Debugging local processes</li>
<li>  Breaking at the entry point</li>
<li>  Debugging shellcode</li>
</ul>
</li>
<li>ROP<ul>
<li>  Dumping gadgets</li>
<li>  Searching for gadgets</li>
<li>  ROP stack generation</li>
<li>  Helper functions</li>
</ul>
</li>
<li>Logging<ul>
<li>  Basic logging</li>
<li>  Log verbosity</li>
<li>  Progress spinners</li>
</ul>
</li>
<li>Leaking Remote Memory<ul>
<li>  Declaring a leak function</li>
<li>  Leaking arbitrary memory</li>
<li>  Remote symbol resolution</li>
</ul>
</li>
</ul>
<h2 id="三、安装Pwntools"><a href="#三、安装Pwntools" class="headerlink" title="三、安装Pwntools"></a>三、安装Pwntools</h2><p>这个过程可以说是简单明了，Ubuntu 18.04和20.04是唯一 “官方支持 “的平台，因为它们是官方对软件进行自动化测试的唯二平台。</p>
<pre><code>$ apt-get update
$ apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
$ python3 -m pip install --upgrade pip
$ python3 -m pip install --upgrade pwntools
</code></pre>
<h3 id="3-1-验证安装"><a href="#3-1-验证安装" class="headerlink" title="3.1 验证安装"></a>3.1 验证安装</h3><p>如果以下命令成功，一切都应该是OK的</p>
<pre><code>$ python -c &#39;from pwn import *&#39;
</code></pre>
<h3 id="3-2-其它架构"><a href="#3-2-其它架构" class="headerlink" title="3.2 其它架构"></a>3.2 其它架构</h3><p>如果你想为其它的架构组装或反汇编代码，你需要安装一个合适的<code>binutils</code>。对于Ubuntu和Mac OS X用户，安装说明可在<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/install/binutils.html">docs.pwntools.com</a>上找到。</p>
<pre><code>$ apt-get install binutils-*
</code></pre>
<h2 id="四、管道"><a href="#四、管道" class="headerlink" title="四、管道"></a>四、管道</h2><p>管道是方便高校的I/O包装器，里面包含了你需要执行的大多数类型的I/O。</p>
<ul>
<li>  Local processes</li>
<li>  Remote TCP or UDP connections</li>
<li>  Processes running on a remote server over SSH</li>
<li>  Serial port I/O</li>
</ul>
<p>本介绍提供了一些所提供功能的例子，但更复杂的组合是可能的。关于如何进行正则表达式匹配，以及将管道连接在一起的更多信息，请参阅完整的<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/tubes.html">文档</a>。</p>
<h3 id="4-1-基础IO"><a href="#4-1-基础IO" class="headerlink" title="4.1 基础IO"></a>4.1 基础IO</h3><p>下面介绍一些IO中的基本功能：</p>
<p><strong>接收数据</strong></p>
<ul>
<li>  <code>recv(n)</code> - 接收任何数量的可用字节</li>
<li>  <code>recvline()</code> - 接收数据，直到遇到换行</li>
<li>  <code>recvuntil(delim)</code> - 接收数据，直到找到一个分隔符</li>
<li>  <code>recvregex(pattern)</code> - 接收数据，直到满足一个与pattern重合的内容为止</li>
<li>  <code>recvrepeat(timeout)</code> - 继续接收数据，直到发生超时</li>
<li>  <code>clean()</code> - 丢弃所有缓冲的数据</li>
</ul>
<p><strong>发送数据</strong></p>
<ul>
<li>  <code>send(data)</code> - 发送数据</li>
<li>  <code>sendline(line)</code> - 发送数据加一个换行</li>
</ul>
<p><strong>操作整数</strong></p>
<ul>
<li>  <code>pack(int)</code> - 打包发送一个字（word）大小的整数</li>
<li>  <code>unpack()</code> - 接收并解包一个字（word）大小的整数</li>
</ul>
<h3 id="4-2-进程和基本功能"><a href="#4-2-进程和基本功能" class="headerlink" title="4.2 进程和基本功能"></a>4.2 进程和基本功能</h3><p>为了创建一个与进程对话的管道，你只需创建一个进程对象并给它一个目标二进制的名字。</p>
<pre><code>from pwn import *

io = process(&#39;sh&#39;)
io.sendline(&#39;echo Hello, world&#39;)
io.recvline()
# &#39;Hello, world\n&#39;
</code></pre>
<p>如果你需要提供命令行参数，或设置环境，可以使用额外的选项。更多信息请参见完整的<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/tubes/processes.html">文档</a>。</p>
<pre><code>from pwn import *

io = process([&#39;sh&#39;, &#39;-c&#39;, &#39;echo $MYENV&#39;], env=&#123;&#39;MYENV&#39;: &#39;MYVAL&#39;&#125;)
io.recvline()
# &#39;MYVAL\n&#39;
</code></pre>
<p>读取二进制数据也不是一个问题。你可以用<code>recv</code>接收多达若干字节的数据，或者用<code>recvn</code>接受精确的字节数。</p>
<pre><code>from pwn import *

io = process([&#39;sh&#39;, &#39;-c&#39;, &#39;echo A; sleep 1; echo B; sleep 1; echo C; sleep 1; echo DDD&#39;])

io.recv()
# &#39;A\n&#39;

io.recvn(4)
# &#39;B\nC\n&#39;

hex(io.unpack())
# 0xa444444
</code></pre>
<h3 id="4-3-会话互动"><a href="#4-3-会话互动" class="headerlink" title="4.3 会话互动"></a>4.3 会话互动</h3><p>你在游戏服务器中获取了一个shell吗？赶快！互动地使用它是很容易的。</p>
<pre><code>from pwn import *

# Let&#39;s pretend we&#39;re uber 1337 and landed a shell.
io = process(&#39;sh&#39;)

# &lt;exploit goes here&gt;

io.interactive()
</code></pre>
<h3 id="4-4-网络"><a href="#4-4-网络" class="headerlink" title="4.4 网络"></a>4.4 网络</h3><p>创建一个网络连接也很容易，而且有完全相同的接口。一个<code>remote</code>对象连接到其他地方，而一个<code>listen</code>对象则在等待连接。</p>
<pre><code>from pwn import *

io = remote(&#39;google.com&#39;, 80)
io.send(&#39;GET /\r\n\r\n&#39;)
io.recvline()
# &#39;HTTP/1.0 200 OK\r\n&#39;
</code></pre>
<p>如果你需要指定协议信息，也是很直接方便的。</p>
<pre><code>from pwn import *

dns  = remote(&#39;8.8.8.8&#39;, 53, typ=&#39;udp&#39;)
tcp6 = remote(&#39;google.com&#39;, 80, fam=&#39;ipv6&#39;)
</code></pre>
<p>侦听连接并没有多复杂。请注意，这正好是在监听一个连接，然后停止监听。</p>
<pre><code>from pwn import *

client = listen(8080).wait_for_connection()
</code></pre>
<h3 id="4-5-安全的Shell"><a href="#4-5-安全的Shell" class="headerlink" title="4.5 安全的Shell"></a>4.5 安全的Shell</h3><p>SSH连接也同样简单。可以将下面的代码与上面 “Hello Process “中的代码进行比较。</p>
<p>你还可以用SSH做更复杂的事情，如端口转发和文件上传/下载。更多信息请参见<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/ssh.md">SSH</a>教程。</p>
<pre><code>from pwn import *

session = ssh(&#39;bandit0&#39;, &#39;bandit.labs.overthewire.org&#39;, password=&#39;bandit0&#39;)

io = session.process(&#39;sh&#39;, env=&#123;&quot;PS1&quot;:&quot;&quot;&#125;)
io.sendline(&#39;echo Hello, world!&#39;)
io.recvline()
# &#39;Hello, world!\n&#39;
</code></pre>
<h3 id="4-6-串行端口"><a href="#4-6-串行端口" class="headerlink" title="4.6 串行端口"></a>4.6 串行端口</h3><p>如果你需要在本地进行一些黑客攻击，也有一个串行管道。一如既往，在完整的<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/tubes/serial.html">在线文档</a>中有更多信息。</p>
<pre><code>from pwn import *

io = serialtube(&#39;/dev/ttyUSB0&#39;, baudrate=115200)
</code></pre>
<h2 id="五、实用功能"><a href="#五、实用功能" class="headerlink" title="五、实用功能"></a>五、实用功能</h2><p>Pwntools大约有一半的内容是实用功能，这样你就不再需要到处复制粘贴这样的东西。</p>
<pre><code>import struct

def p(x):
    return struct.pack(&#39;I&#39;, x)
def u(x):
    return struct.unpack(&#39;I&#39;, x)[0]

1234 == u(p(1234))
</code></pre>
<p>此外，你不仅得到了漂亮的小包装，作为额外的奖励，在阅读别人的漏洞代码时，一切都更清晰，更容易理解。</p>
<pre><code>from pwn import *

1234 == unpack(pack(1234))
</code></pre>
<h3 id="5-1-打包和解包整数"><a href="#5-1-打包和解包整数" class="headerlink" title="5.1 打包和解包整数"></a>5.1 打包和解包整数</h3><p>这可能是你最常做的事情，所以它在最前面。主要的<code>pack</code>和<code>unpack</code>函数都知道<code>context</code>中的全局设置，如<code>endian</code>、<code>bits</code>和<code>sign</code>。</p>
<p>你也可以在函数调用中明确指定它们。</p>
<pre><code>pack(1)
# &#39;\x01\x00\x00\x00&#39;

pack(-1)
# &#39;\xff\xff\xff\xff&#39;

pack(2**32 - 1)
# &#39;\xff\xff\xff\xff&#39;

pack(1, endian=&#39;big&#39;)
# &#39;\x00\x00\x00\x01&#39;

p16(1)
# &#39;\x01\x00&#39;

hex(unpack(&#39;AAAA&#39;))
# &#39;0x41414141&#39;

hex(u16(&#39;AA&#39;))
# &#39;0x4141&#39;
</code></pre>
<h3 id="5-2-文件I-O"><a href="#5-2-文件I-O" class="headerlink" title="5.2 文件I/O"></a>5.2 文件I/O</h3><p>只需调用一个函数，它就能做你想做的事。</p>
<pre><code>from pwn import *

write(&#39;filename&#39;, &#39;data&#39;)
read(&#39;filename&#39;)
# &#39;data&#39;
read(&#39;filename&#39;, 1)
# &#39;d&#39;
</code></pre>
<h3 id="5-3-哈希和编码"><a href="#5-3-哈希和编码" class="headerlink" title="5.3 哈希和编码"></a>5.3 哈希和编码</h3><p>能够快速的将你的数据转换成你需要的任何格式。</p>
<p><strong>Base64</strong></p>
<pre><code>&#39;hello&#39; == b64d(b64e(&#39;hello&#39;))
</code></pre>
<p><strong>Hashes</strong></p>
<pre><code>md5sumhex(&#39;hello&#39;) == &#39;5d41402abc4b2a76b9719d911017c592&#39;
write(&#39;file&#39;, &#39;hello&#39;)
md5filehex(&#39;file&#39;) == &#39;5d41402abc4b2a76b9719d911017c592&#39;
sha1sumhex(&#39;hello&#39;) == &#39;aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d&#39;
</code></pre>
<p><strong>URL Encoding</strong></p>
<pre><code>urlencode(&quot;Hello, World!&quot;) == &#39;%48%65%6c%6c%6f%2c%20%57%6f%72%6c%64%21&#39;
</code></pre>
<p><strong>Hex Encoding</strong></p>
<pre><code>enhex(&#39;hello&#39;)
# &#39;68656c6c6f&#39;
unhex(&#39;776f726c64&#39;)
# &#39;world&#39;
</code></pre>
<p><strong>Bit Manipulation and Hex Dumping</strong></p>
<pre><code>bits(0b1000001) == bits(&#39;A&#39;)
# [0, 0, 0, 1, 0, 1, 0, 1]
unbits([0,1,0,1,0,1,0,1])
# &#39;U&#39;
</code></pre>
<p><strong>Hex Dumping</strong></p>
<pre><code>print hexdump(read(&#39;/dev/urandom&#39;, 32))
# 00000000  65 4c b6 62  da 4f 1d 1b  d8 44 a6 59  a3 e8 69 2c  │eL·b│·O··│·D·Y│··i,│
# 00000010  09 d8 1c f2  9b 4a 9e 94  14 2b 55 7c  4e a8 52 a5  │····│·J··│·+U|│N·R·│
# 00000020
</code></pre>
<h3 id="5-4-样例生成"><a href="#5-4-样例生成" class="headerlink" title="5.4 样例生成"></a>5.4 样例生成</h3><p>样例生成是一种非常方便的方法，可以在不需要进行数学计算的情况下找到偏移量。</p>
<p>假设我们有一个直接的缓冲区溢出，我们生成一个样例并提供给目标应用程序。</p>
<pre><code>io = process(...)
io.send(cyclic(512))
</code></pre>
<p>在核心转储中，我们可能看到崩溃发生在0x61616178。我们可以不用对崩溃帧做任何分析，只需把这个数字打回去，得到一个偏移量。</p>
<pre><code>cyclic_find(0x61616178)
# 92
</code></pre>
<h2 id="六、Bytes-vs-Strings"><a href="#六、Bytes-vs-Strings" class="headerlink" title="六、Bytes vs. Strings"></a>六、Bytes vs. Strings</h2><p>当Pwntools最初（重新）编写时，大约在十年前，Python2是最受欢迎的。</p>
<pre><code>commit e692277db8533eaf62dd3d2072144ccf0f673b2e
Author: Morten Brøns-Pedersen &lt;mortenbp@gmail.com&gt;
Date:   Thu Jun 7 17:34:48 2012 +0200

    ALL THE THINGS
</code></pre>
<p>多年来在Python中编写的许多EXP都假定<code>str</code>对象与<code>bytes</code>对象有1:1的映射，因为这是Python2上的工作原理。 在这一节中，我们讨论在Python3上编写EXP所需的一些变化，并阐述与Python2的对应关系。</p>
<h3 id="6-1-Python2"><a href="#6-1-Python2" class="headerlink" title="6.1 Python2"></a>6.1 Python2</h3><p>在Python2中，<code>str</code>类和<code>bytes</code>类是一样的，而且有一个1:1的映射。从来不需要对任何东西调用<code>encode</code>或<code>decode</code> – 文本就是字节，字节就是文本。</p>
<p>这对编写EXP来说是非常方便的，因为你只需写”\x90\x90\x90\x90 “就可以得到一个NOP滑块。Python2上所有的Pwntools管道和数据操作都支持字符串或字节。</p>
<p>从来没有人使用<code>unicode</code>对象来编写漏洞，所以<code>unicode</code>到字节的转换极其罕见。</p>
<h3 id="6-2-Python3"><a href="#6-2-Python3" class="headerlink" title="6.2 Python3"></a>6.2 Python3</h3><p>在 Python3 中，<code>unicode</code>类实际上就是<code>str</code>类。这有一些直接和明显的影响。</p>
<p>乍一看，Python3似乎让事情变得更难了，因为<code>bytes</code>声明的是单个的八位数（正如名字<code>bytes</code>所暗示的），而<code>str</code>用于任何基于文本的数据表示。</p>
<p>Pwntools花了很大力气来遵循 “最小惊喜原则”——也就是说，事情会按照你预期的方式进行。</p>
<pre><code>&gt;&gt;&gt; r.send(&#39;❤️&#39;)
[DEBUG] Sent 0x6 bytes:
    00000000  e2 9d a4 ef  b8 8f                                  │····│··│
    00000006
&gt;&gt;&gt; r.send(&#39;\x00\xff\x7f\x41\x41\x41\x41&#39;)
[DEBUG] Sent 0x7 bytes:
    00000000  00 ff 7f 41  41 41 41                               │···A│AAA│
    00000007
</code></pre>
<p>然而，有时事情会出现一些故障。注意这里99f7e2如何被转换为c299c3b7c3a2。</p>
<pre><code>&gt;&gt;&gt; shellcode = &quot;\x99\xf7\xe2&quot;
&gt;&gt;&gt; print(hexdump(flat(&quot;padding\x00&quot;, shellcode)))
00000000  70 61 64 64  69 6e 67 00  c2 99 c3 b7  c3 a2        │padd│ing·│····│··│
0000000e
</code></pre>
<p>这是因为文本字符串”\x99\xf7\xe2 “被自动转换为UTF-8代码。这不可能是用户想要的。</p>
<p>作为解决方案，我们只需要以b为前缀：</p>
<pre><code>&gt;&gt;&gt; shellcode = b&quot;\x99\xf7\xe2&quot;
&gt;&gt;&gt; print(hexdump(flat(b&quot;padding\x00&quot;, shellcode)))
00000000  70 61 64 64  69 6e 67 00  99 f7 e2                  │padd│ing·│···│
0000000b
</code></pre>
<p>好极了！</p>
<p>一般来说，Python3上的Pwntools的修复方法是确保你所有的字符串都有一个<code>b</code>前缀。这就解决了歧义，并使一切变得简单明了。</p>
<h3 id="6-3-麻烦"><a href="#6-3-麻烦" class="headerlink" title="6.3 麻烦"></a>6.3 麻烦</h3><p>关于Python3的<code>bytes</code>对象，有一个值得一提的 “麻烦”。当对它们进行迭代时，你会得到整数，而不是<code>bytes</code>对象。这是与Python2的巨大差异，也是一个主要的烦恼。</p>
<pre><code>&gt;&gt;&gt; x=b&#39;123&#39;
&gt;&gt;&gt; for i in x:
...     print(i)
...
49
50
51
</code></pre>
<p>为了解决这个问题，我们建议使用切片，它产生长度为1<code>bytes</code>的对象。</p>
<pre><code>&gt;&gt;&gt; for i in range(len(x)):
...     print(x[i:i+1])
...
b&#39;1&#39;
b&#39;2&#39;
b&#39;3&#39;
</code></pre>
<h2 id="七、环境"><a href="#七、环境" class="headerlink" title="七、环境"></a>七、环境</h2><p><code>context</code>对象是一个全局的、线程感知的对象，包含了<code>pwntools</code>使用的各种设置。</p>
<p>一般来说，在一个EXP的首部，你会发现类似的东西：</p>
<pre><code>from pwn import *
context.arch = &#39;amd64&#39;
</code></pre>
<p>这通知pwntools生成的shellcode将用于amd64，并且默认字大小为64位。</p>
<h3 id="7-1-环境设置"><a href="#7-1-环境设置" class="headerlink" title="7.1 环境设置"></a>7.1 环境设置</h3><p><strong>arch</strong></p>
<p>目标架构。有效值是<code>&quot;arch64&quot;</code>、<code>&quot;arm&quot;</code>、<code>&quot;i386&quot;</code>、<code>&quot;amd64&quot;</code>，等等。默认是 <code>&quot;i386&quot;</code>。</p>
<p>第一次设置时，它会自动将默认的context.bits和context.endian设置为最可能的值。</p>
<p><strong>bits</strong></p>
<p>在目标二进制中，有多少位组成一个字，如<code>32</code>或<code>64</code>。</p>
<p><strong>binary</strong></p>
<p>从ELF文件中获取配置。例如：<code>context.binary=&#39;/bin/sh&#39;</code></p>
<p><strong>log_file</strong></p>
<p>将所有的日志输出送入的文件。</p>
<p><strong>log_level</strong></p>
<p>日志的详细程度。有效值是整数（越小越详细），以及<code>&quot;debug&quot;</code>、<code>&quot;info &quot;</code>和<code>&quot;error &quot;</code>等字符串值。</p>
<p><strong>sign</strong></p>
<p>设置整数打包/解包的是否有符号。默认为 <code>&quot;unsigned&quot;</code>。</p>
<p><strong>terminal</strong></p>
<p>用来打开新窗口的首选终端程序。默认情况下，使用<code>x-terminal-emulator</code>或<code>tmux</code>。</p>
<p><strong>timeout</strong></p>
<p>管道操作的默认超时范围。</p>
<p><strong>update</strong></p>
<p>一次设置多个值，例如<code>context.update(arch=&#39;mips&#39;, bits=64, endian=&#39;big&#39;)</code></p>
<h2 id="八、ELFs"><a href="#八、ELFs" class="headerlink" title="八、ELFs"></a>八、ELFs</h2><p>Pwntools通过ELF类使与ELF文件的交互变得相对简单。你可以在<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/elf.html">RTD</a>上找到完整的文档。</p>
<h3 id="8-1-加载ELF文件"><a href="#8-1-加载ELF文件" class="headerlink" title="8.1 加载ELF文件"></a>8.1 加载ELF文件</h3><p>ELF文件是按路径加载的。在被加载后，一些与安全有关的文件属性被打印出来。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)
# [*] &#39;/bin/bash&#39;
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE
#     FORTIFY:  Enabled
</code></pre>
<h3 id="8-2-使用符号表"><a href="#8-2-使用符号表" class="headerlink" title="8.2 使用符号表"></a>8.2 使用符号表</h3><p>ELF文件有几组不同的符号表可用，每组都包含在<code>&#123;name: data&#125;</code>的字典中。</p>
<ul>
<li>  <code>ELF.symbols</code> 列出所有已知的符号，包括下面的符号。优先考虑PLT条目，而不是GOT条目。</li>
<li>  <code>ELF.got</code> 只包含GOT表</li>
<li>  <code>ELF.plt</code> 只包含PLT表</li>
<li>  <code>ELF.functions</code> 只包含函数符号表（需要DWARF符号表）</li>
</ul>
<p>这对于保持漏洞的稳健性非常有用，因为它消除了对硬编码地址的需要。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

print &quot;%#x -&gt; license&quot; % e.symbols[&#39;bash_license&#39;]
print &quot;%#x -&gt; execve&quot; % e.symbols[&#39;execve&#39;]
print &quot;%#x -&gt; got.execve&quot; % e.got[&#39;execve&#39;]
print &quot;%#x -&gt; plt.execve&quot; % e.plt[&#39;execve&#39;]
print &quot;%#x -&gt; list_all_jobs&quot; % e.functions[&#39;list_all_jobs&#39;].address
</code></pre>
<p>这将打印出类似下面的内容：</p>
<pre><code>0x4ba738 -&gt; license
0x41db60 -&gt; execve
0x6f0318 -&gt; got.execve
0x41db60 -&gt; plt.execve
0x446420 -&gt; list_all_jobs
</code></pre>
<h3 id="8-3-改变基本地址"><a href="#8-3-改变基本地址" class="headerlink" title="8.3 改变基本地址"></a>8.3 改变基本地址</h3><p>使用pwntools改变ELF文件的基址（比如为ASLR做调整）是非常直接和简单的。让我们改变bash的基址，看看所有的符号都有什么变化。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

print &quot;%#x -&gt; base address&quot; % e.address
print &quot;%#x -&gt; entry point&quot; % e.entry
print &quot;%#x -&gt; execve&quot; % e.symbols[&#39;execve&#39;]

print &quot;---&quot;
e.address = 0x12340000

print &quot;%#x -&gt; base address&quot; % e.address
print &quot;%#x -&gt; entry point&quot; % e.entry
print &quot;%#x -&gt; execve&quot; % e.symbols[&#39;execve&#39;]
</code></pre>
<p>这应该打印出类似的内容：</p>
<pre><code>0x400000 -&gt; base address
0x42020b -&gt; entry point
0x41db60 -&gt; execve
---
0x12340000 -&gt; base address
0x1236020b -&gt; entry point
0x1235db60 -&gt; execve
</code></pre>
<h3 id="8-4-读取ELF文件"><a href="#8-4-读取ELF文件" class="headerlink" title="8.4 读取ELF文件"></a>8.4 读取ELF文件</h3><p>我们可以通过pwntools直接与ELF互动，就像它被加载到内存中一样，使用<code>read</code>、<code>write</code>和与<code>packing</code>模块中的函数命名相同。此外，你可以通过<code>disasm</code>方法看到反汇编。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

print repr(e.read(e.address, 4))

p_license = e.symbols[&#39;bash_license&#39;]
license   = e.unpack(p_license)
print &quot;%#x -&gt; %#x&quot; % (p_license, license)

print e.read(license, 14)
print e.disasm(e.symbols[&#39;main&#39;], 12)
</code></pre>
<p>打印出来的东西应该如下：</p>
<pre><code>&#39;\x7fELF&#39;
0x4ba738 -&gt; 0x4ba640
License GPLv3+
  41eab0:       41 57                   push   r15
  41eab2:       41 56                   push   r14
  41eab4:       41 55                   push   r13
</code></pre>
<h3 id="8-5-对ELF文件进行修补"><a href="#8-5-对ELF文件进行修补" class="headerlink" title="8.5 对ELF文件进行修补"></a>8.5 对ELF文件进行修补</h3><p>对ELF文件的修补也同样简单。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

# Cause a debug break on the &#39;exit&#39; command
e.asm(e.symbols[&#39;exit_builtin&#39;], &#39;int3&#39;)

# Disable chdir and just print it out instead
e.pack(e.got[&#39;chdir&#39;], e.plt[&#39;puts&#39;])

# Change the license
p_license = e.symbols[&#39;bash_license&#39;]
license = e.unpack(p_license)
e.write(license, &#39;Hello, world!\n\x00&#39;)

e.save(&#39;./bash-modified&#39;)
</code></pre>
<p>然后我们可以运行我们修改过的bash版本。</p>
<pre><code>$ chmod +x ./bash-modified
$ ./bash-modified -c &#39;exit&#39;
Trace/breakpoint trap (core dumped)
$ ./bash-modified --version | grep &quot;Hello&quot;
Hello, world!
$ ./bash-modified -c &#39;cd &quot;No chdir for you!&quot;&#39;
/home/user/No chdir for you!
No chdir for you!
./bash-modified: line 0: cd: No chdir for you!: No such file or directory
</code></pre>
<h3 id="8-6-搜索ELF文件"><a href="#8-6-搜索ELF文件" class="headerlink" title="8.6 搜索ELF文件"></a>8.6 搜索ELF文件</h3><p>在编写EXP的时候，你经常需要找到一些字节序列。最常见的例子是搜索例如<code>&quot;/bin/sh\x00 &quot;</code>的<code>execve</code>调用。<code>search</code>方法返回一个迭代器，允许你选择第一个结果，或者如果你需要一些特殊的东西（比如地址中没有坏字符），可以继续搜索。你可以选择传递一个<code>writable</code>参数给<code>search</code>，表示它应该只返回可写段的地址。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

for address in e.search(&#39;/bin/sh\x00&#39;):
    print hex(address)
</code></pre>
<p>上面的例子打印的内容应该如下：</p>
<pre><code>0x420b82
0x420c5e
</code></pre>
<h3 id="8-7-构建ELF文件"><a href="#8-7-构建ELF文件" class="headerlink" title="8.7 构建ELF文件"></a>8.7 构建ELF文件</h3><p>通过pwntools我们可以很方便地从头开始创建一个ELF文件。所有这些功能都是上下文感知的。相关的函数是<code>from_bytes</code>和<code>from_assembly</code>。每一个都返回一个<code>ELF</code>对象，它可以很容易地被保存到文件中。</p>
<pre><code>from pwn import *

ELF.from_bytes(&#39;\xcc&#39;).save(&#39;int3-1&#39;)
ELF.from_assembly(&#39;int3&#39;).save(&#39;int3-2&#39;)
ELF.from_assembly(&#39;nop&#39;, arch=&#39;powerpc&#39;).save(&#39;powerpc-nop&#39;)
</code></pre>
<h3 id="8-8-运行和调试ELF文件"><a href="#8-8-运行和调试ELF文件" class="headerlink" title="8.8 运行和调试ELF文件"></a>8.8 运行和调试ELF文件</h3><p>如果你有一个ELF对象，你可以直接运行或调试它。以下两个代码是等同的：</p>
<pre><code>&gt;&gt;&gt; io = elf.process()
# vs
&gt;&gt;&gt; io = process(elf.path)
</code></pre>
<p>同样地，你可以启动一个调试器，并将其连接到ELF上。这在测试shellcode时是非常有用的，不需要用C语言包装器来加载和调试它。</p>
<pre><code>&gt;&gt;&gt; io = elf.debug()
# vs
&gt;&gt;&gt; io = gdb.debug(elf.path)
</code></pre>
<h2 id="九、汇编"><a href="#九、汇编" class="headerlink" title="九、汇编"></a>九、汇编</h2><p>Pwntools使得用户在几乎所有的架构中进行汇编变得非常容易，并带有各种可以开箱即用已经生成好且依然可定制的shellcode。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/walkthrough">walkthrough</a>目录中，有几个较长的shellcode教程。本页为您提供了基础知识。</p>
<h3 id="9-1-基础汇编"><a href="#9-1-基础汇编" class="headerlink" title="9.1 基础汇编"></a>9.1 基础汇编</h3><p>最基本的例子，是将汇编代码转换成shellcode。</p>
<pre><code>from pwn import *

print repr(asm(&#39;xor edi, edi&#39;))
# &#39;1\xff&#39;

print enhex(asm(&#39;xor edi, edi&#39;))
# 31ff
</code></pre>
<h3 id="9-2-现成的汇编（shellcraft）"><a href="#9-2-现成的汇编（shellcraft）" class="headerlink" title="9.2 现成的汇编（shellcraft）"></a>9.2 现成的汇编（<code>shellcraft</code>）</h3><p><code>shellcraft</code>模块会提供给你一些现成的汇编代码。它通常是可定制的。找出存在哪些<code>shellcraft</code>模板的最简单方法是查看<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/shellcraft.html">RTD</a>上的文档。</p>
<pre><code>from pwn import *
help(shellcraft.sh)
print &#39;---&#39;
print shellcraft.sh()
print &#39;---&#39;
print enhex(asm(shellcraft.sh()))


Help on function sh in module pwnlib.shellcraft.internal:

sh()
    Execute /bin/sh
---
    /* push &#39;/bin///sh\x00&#39; */
    push 0x68
    push 0x732f2f2f
    push 0x6e69622f

    /* call execve(&#39;esp&#39;, 0, 0) */
    push (SYS_execve) /* 0xb */
    pop eax
    mov ebx, esp
    xor ecx, ecx
    cdq /* edx=0 */
    int 0x80
---
6a68682f2f2f73682f62696e6a0b5889e331c999cd80
</code></pre>
<h3 id="9-3-命令行工具"><a href="#9-3-命令行工具" class="headerlink" title="9.3 命令行工具"></a>9.3 命令行工具</h3><p>有三个命令行工具用于与汇编进行交互。</p>
<ul>
<li>  <code>asm</code></li>
<li>  <code>disasm</code></li>
<li>  <code>shellcraft</code></li>
</ul>
<p><strong>asm</strong></p>
<p><code>asm</code>工具的功能正如其名，它将汇编码转换为机器码，它为汇编指令输出的格式化提供了几个选项，当输出是一个终端时，它默认为十六进制编码。</p>
<pre><code>$ asm nop
90
</code></pre>
<p>当输出是其他东西时，它显示的是原始数据。</p>
<pre><code>$ asm nop | xxd
0000000: 90                                       .
</code></pre>
<p>如果在命令行上没有提供指令，它将在stdin上获取数据。</p>
<pre><code>$ echo &#39;push ebx; pop edi&#39; | asm
535f
</code></pre>
<p>最后，它支持一些不同的选项，通过<code>--format</code>选项来指定输出格式。支持的参数有<code>raw</code>、<code>hex</code>、<code>string</code>和<code>elf</code>。</p>
<pre><code>$ asm --format=elf &#39;int3&#39; &gt; ./int3
$ ./halt
Trace/breakpoint trap (core dumped)
</code></pre>
<p><strong>disasm</strong></p>
<p>Disasm是<code>asm</code>的反义词，也就是将16进制的机器码反汇编成汇编指令。</p>
<pre><code>$ disasm cd80
   0:    cd 80                    int    0x80
$ asm nop | disasm
   0:    90                       nop
</code></pre>
<p><strong>shellcraft</strong></p>
<p><code>shellcraft</code>命令是内部<code>shellcraft</code>模块的命令行接口。在命令行中，必须按<code>arch.os.template</code>的顺序指定完整的环境信息。</p>
<pre><code>$ shellcraft i386.linux.sh
6a68682f2f2f73682f62696e6a0b5889e331c999cd80
</code></pre>
<h3 id="9-4-异构架构"><a href="#9-4-异构架构" class="headerlink" title="9.4 异构架构"></a>9.4 异构架构</h3><p>为其它非X86架构进行汇编交互，你需要自行安装适当版本的<code>binutils</code>。你应该看看<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/installing.md">installing.md</a>以了解更多这方面的信息。我们唯一需要改变的是在全局环境变量中设置架构。你可以在 <a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/context.md">context.md</a> 中看到更多关于<code>context</code>的信息。</p>
<pre><code>from pwn import *

context.arch = &#39;arm&#39;

print repr(asm(&#39;mov r0, r1&#39;))
# &#39;\x01\x00\xa0\xe1&#39;

print enhex(asm(&#39;mov r0, r1&#39;))
# 0100a0e1
</code></pre>
<h4 id="9-4-1-现成汇编"><a href="#9-4-1-现成汇编" class="headerlink" title="9.4.1 现成汇编"></a>9.4.1 现成汇编</h4><p><code>shellcraft</code>模块会自动切换到相应的架构。</p>
<pre><code>from pwn import *

context.arch = &#39;arm&#39;

print shellcraft.sh()
print enhex(asm(shellcraft.sh()))


    adr r0, bin_sh
    mov r2, #0
    mov r1, r2
    svc SYS_execve
bin_sh: .asciz &quot;/bin/sh&quot;

08008fe20020a0e30210a0e10b0000ef2f62696e2f736800
</code></pre>
<h4 id="9-4-2-命令行工具"><a href="#9-4-2-命令行工具" class="headerlink" title="9.4.2 命令行工具"></a>9.4.2 命令行工具</h4><p>你也可以通过使用<code>--context</code>命令行选项，使用命令行来汇编生成其它架构的<code>shellcode</code>。</p>
<pre><code>$ asm --context=arm &#39;mov r0, r1&#39;
0100a0e1
$ shellcraft arm.linux.sh
08008fe20020a0e30210a0e10b0000ef2f62696e2f736800
</code></pre>
<h2 id="十、调试"><a href="#十、调试" class="headerlink" title="十、调试"></a>十、调试</h2><p>Pwntools对在你的漏洞工作流程中使用调试器有丰富的支持，在开发EXP的问题出现时，调试器非常有用。</p>
<p>除了这里的调试资源外，你可能想通过以下项目来增强你的GDB经验：</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://pwndbg.re/">Pwndbg</a></li>
<li>  <a target="_blank" rel="noopener" href="https://github.com/hugsy/gef">GDB Enhanced Features (GEF)</a></li>
</ul>
<h3 id="10-1-先前条件"><a href="#10-1-先前条件" class="headerlink" title="10.1 先前条件"></a>10.1 先前条件</h3><p>你的机器上应该同时安装了<code>gdb</code>和<code>gdbserver</code>。你可以用<code>which gdb</code>或<code>which gdbserver</code>来轻松检查。</p>
<p>如果你发现你没有安装它们，它们可以很容易地从大多数软件包管理器中安装。</p>
<pre><code>$ sudo apt-get install gdb gdbserver
</code></pre>
<h3 id="10-2-在GDB下启动一个进程"><a href="#10-2-在GDB下启动一个进程" class="headerlink" title="10.2 在GDB下启动一个进程"></a>10.2 在GDB下启动一个进程</h3><p>在GDB下启动一个进程，同时还能从pwntools与该进程进行交互，这在之前是一个棘手的过程，但幸运的是，这一切都已经被解决了，而且这个过程是相当无感和便捷的。</p>
<p>要在GDB下从第一条指令开始启动一个进程，只需使用<a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/gdb.html#pwnlib.gdb.debug">gdb.debug</a>。</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug(&quot;/bin/bash&quot;, gdbscript=&#39;continue&#39;)
&gt;&gt;&gt; io.sendline(&#39;echo hello&#39;)
&gt;&gt;&gt; io.recvline()
# b&#39;hello\n&#39;
&gt;&gt;&gt; io.interactive()
</code></pre>
<p>这应该会自动在一个新的窗口中启动调试器，以便你进行交互。如果不是这样，或者你看到关于<code>context.terminal</code>的错误，请查看指定终端窗口的章节。</p>
<p>在这个例子中，我们传入了<code>gdbscript=&#39;continue&#39;</code>，以使调试器恢复执行，但是你可以传入任何有效的GDB脚本命令，它们将在调试进程启动时被执行。</p>
<h3 id="10-3-附加到一个正在运行的进程"><a href="#10-3-附加到一个正在运行的进程" class="headerlink" title="10.3 附加到一个正在运行的进程"></a>10.3 附加到一个正在运行的进程</h3><p>有时你不想在调试器下启动你的目标，但想在开发过程的某个阶段附加到它。这也已经被Pwntools便捷无缝的实现了。</p>
<h4 id="10-3-1-本地进程"><a href="#10-3-1-本地进程" class="headerlink" title="10.3.1 本地进程"></a>10.3.1 本地进程</h4><p>一般来说，你会创建一个<code>process()</code>管道，以便与目标可执行文件交互。你可以简单地把它传递给<code>gdb.attach()</code>，它将神奇地打开一个新的终端窗口，在调试器中运行目标二进制文件。</p>
<pre><code>&gt;&gt;&gt; io = process(&#39;/bin/sh&#39;)
&gt;&gt;&gt; gdb.attach(io, gdbscript=&#39;continue&#39;)
</code></pre>
<p>一个新的窗口应该出现，你可以继续与进程进行互动，就像你通常在Pwntools中做的一样。</p>
<h4 id="10-3-2-远程服务器"><a href="#10-3-2-远程服务器" class="headerlink" title="10.3.2 远程服务器"></a>10.3.2 远程服务器</h4><p>有时你想调试的二进制文件运行在一个远程服务器上，你想调试你所连接的进程（而不是服务器本身）。只要服务器在当前机器上运行，这也可以无缝地完成。</p>
<p>让我们用socat伪造一个服务器!</p>
<pre><code>&gt;&gt;&gt; socat = process([&#39;socat&#39;, &#39;TCP-LISTEN:4141,reuseaddr,fork&#39;, &#39;EXEC:/bin/bash -i&#39;])
</code></pre>
<p>然后我们像往常一样用远程管道连接到远程进程。</p>
<pre><code>&gt;&gt;&gt; io = remote(&#39;localhost&#39;, 4141)
[x] Opening connection to localhost on port 4141
[x] Opening connection to localhost on port 4141: Trying 127.0.0.1
[+] Opening connection to localhost on port 4141: Done
&gt;&gt;&gt; io.sendline(&#39;echo hello&#39;)
&gt;&gt;&gt; io.recvline()
b&#39;hello\n&#39;
&gt;&gt;&gt; io.lport, io.rport
</code></pre>
<p>它是有效的！为了调试特定的<code>bash</code>进程，只要把它我们的远程对象传给<code>gdb.attach()</code>。Pwntools将查找连接的远程端的PID，并尝试自动连接到它。</p>
<pre><code>&gt;&gt;&gt; gdb.attach(io)
</code></pre>
<p>调试器应该自动出现，你可以与进程进行交互。</p>
<h3 id="10-3-调试异构架构"><a href="#10-3-调试异构架构" class="headerlink" title="10.3 调试异构架构"></a>10.3 调试异构架构</h3><p>从基于英特尔的系统中在pwntools下调试异构架构（如ARM或PowerPC）是十分容易的。</p>
<pre><code>&gt;&gt;&gt; context.arch = &#39;arm&#39;
&gt;&gt;&gt; elf = ELF.from_assembly(shellcraft.echo(&quot;Hello, world!\n&quot;) + shellcraft.exit())
&gt;&gt;&gt; process(elf.path).recvall()
b&#39;Hello, world!\n&#39;
</code></pre>
<p>用<code>gdb.debug(...)</code>来代替调用<code>process(...)</code></p>
<pre><code>&gt;&gt;&gt; gdb.debug(elf.path).recvall()
b&#39;Hello, world!\n&#39;
</code></pre>
<h4 id="10-3-1-提示和限制"><a href="#10-3-1-提示和限制" class="headerlink" title="10.3.1 提示和限制"></a>10.3.1 提示和限制</h4><p>运行异构架构的进程必须用<code>gdb.debug</code>启动，以便对其进行调试，由于QEMU的工作方式，不可能附加到一个正在运行的进程上。</p>
<p>需要注意的是，QEMU有一个非常有限的用来通知GDB各种库的位置存根，所以调试可能会更加困难，一些命令也无法工作。</p>
<p>Pwntools推荐使用Pwndbg来处理这种情况，因为它拥有专门处理QEMU存根下调试程序的能力。</p>
<h3 id="10-4-故障排除（Pwntools自身）"><a href="#10-4-故障排除（Pwntools自身）" class="headerlink" title="10.4 故障排除（Pwntools自身）"></a>10.4 故障排除（Pwntools自身）</h3><h4 id="10-4-1-幕后花絮（工作详情）"><a href="#10-4-1-幕后花絮（工作详情）" class="headerlink" title="10.4.1 幕后花絮（工作详情）"></a>10.4.1 幕后花絮（工作详情）</h4><p>有时程序就是不正常工作，你需要看看Pwntools内部在调试器的设置下发生了什么。</p>
<p>你可以在全局范围内设置日志上下文（例如通过<code>context.log_level=&#39;debug&#39;</code>），也可以通过传递相同的参数，只为GDB会话设置。</p>
<p>你应该看到在幕后为你处理的一切操作。比如说：</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug(&#39;/bin/sh&#39;, log_level=&#39;debug&#39;)
[x] Starting local process &#39;/home/user/bin/gdbserver&#39; argv=[b&#39;/home/user/bin/gdbserver&#39;, b&#39;--multi&#39;, b&#39;--no-disable-randomization&#39;, b&#39;localhost:0&#39;, b&#39;/bin/sh&#39;]
[+] Starting local process &#39;/home/user/bin/gdbserver&#39; argv=[b&#39;/home/user/bin/gdbserver&#39;, b&#39;--multi&#39;, b&#39;--no-disable-randomization&#39;, b&#39;localhost:0&#39;, b&#39;/bin/sh&#39;] : pid 34282
[DEBUG] Received 0x25 bytes:
    b&#39;Process /bin/sh created; pid = 34286\n&#39;
[DEBUG] Received 0x18 bytes:
    b&#39;Listening on port 45145\n&#39;
[DEBUG] Wrote gdb script to &#39;/tmp/user/pwnxcd1zbyx.gdb&#39;
    target remote 127.0.0.1:45145
[*] running in new terminal: /usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb
[DEBUG] Launching a new terminal: [&#39;/usr/local/bin/tmux&#39;, &#39;splitw&#39;, &#39;/usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb&#39;]
[DEBUG] Received 0x25 bytes:
    b&#39;Remote debugging from host 127.0.0.1\n&#39;
</code></pre>
<h4 id="10-4-2-指定一个终端窗口"><a href="#10-4-2-指定一个终端窗口" class="headerlink" title="10.4.2 指定一个终端窗口"></a>10.4.2 指定一个终端窗口</h4><p>Pwntools[attempts to launch a new window][run_in_new_terminal]，根据你当前使用的任何窗口系统来展示你的调试器。</p>
<p>默认情况下，它是自动检测的：</p>
<ul>
<li>  tmux or screen</li>
<li>  X11-based terminals like GNOME Terminal</li>
</ul>
<p>如果你没有使用支持的终端环境，或者它没有以你想要的方式工作（例如，水平与垂直分割），你可以通过设置<code>context.terminal</code>环境变量来增加支持。</p>
<p>例如，下面将使用TMUX进行水平分割，而不是默认设置。</p>
<pre><code>&gt;&gt;&gt; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
</code></pre>
<p>也许你是一个GNOME终端的用户，而默认的设置并不工作？</p>
<pre><code>&gt;&gt;&gt; context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]
</code></pre>
<p>你可以指定任何你喜欢的终端，甚至可以把设置放在<code>~/.pwn.conf</code>里面，这样它就会被用于你的所有脚本了</p>
<pre><code>[context]
terminal=[&#39;x-terminal-emulator&#39;, &#39;-e&#39;]
</code></pre>
<h4 id="10-4-3-环境变量"><a href="#10-4-3-环境变量" class="headerlink" title="10.4.3 环境变量"></a>10.4.3 环境变量</h4><p>Pwntools允许你通过<code>process()</code>指定任何你喜欢的环境变量，对于<code>gdb.debug()</code>也是如此。</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug([&#39;bash&#39;, &#39;-c&#39;, &#39;echo $HELLO&#39;], env=&#123;&#39;HELLO&#39;: &#39;WORLD&#39;&#125;)
&gt;&gt;&gt; io.recvline()
b&#39;WORLD\n&#39;
</code></pre>
<p><strong>CWD</strong></p>
<p>不幸的是，当使用<code>gdb.debug()</code>时，该进程是在<code>gdbserver</code>下启动的，它增加了自己的环境变量。当环境必须被非常仔细地控制时，这可能会带来复杂的情况。</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug([&#39;env&#39;], env=&#123;&#39;FOO&#39;:&#39;BAR&#39;&#125;, gdbscript=&#39;continue&#39;)
&gt;&gt;&gt; print(io.recvallS())
   =/home/user/bin/gdbserver
FOO=BAR

Child exited with status 0
GDBserver exiting
</code></pre>
<p>这只在你用<code>gdb.debug()</code>在调试器下启动进程时发生。如果你能够启动你的进程，然后用<code>gdb.attach()</code>附加，你就可以避免这个问题。</p>
<p><strong>环境变量排序</strong></p>
<p>一些漏洞可能需要某些环境变量以特定的顺序出现。但是Python2的字典是没有顺序的，这可能会加剧这个问题。</p>
<p>为了让你的环境变量有一个特定的顺序，我们建议使用Python3（它基于插入顺序对字典进行排序），或者使用<code>collection.OrderedDict</code>。</p>
<h4 id="10-4-4-无法附加到进程中"><a href="#10-4-4-无法附加到进程中" class="headerlink" title="10.4.4 无法附加到进程中"></a>10.4.4 无法附加到进程中</h4><p>现代的Linux系统有一个叫做<code>trace_scope</code>的设置，它可以阻止非子进程的进程被调试。Pwntools对于它自己启动的任何进程都能解决这个问题，但是如果你必须在Pwntools之外启动一个进程，并试图通过pid附加到它（例如<code>gdb.attach(1234)</code>），你可能被阻止附加。</p>
<p>你可以通过禁用安全设置和重启机器来解决这个问题：</p>
<pre><code>sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF
kernel.yama.ptrace_scope = 0
EOF
</code></pre>
<h4 id="10-4-5-argv0-and-argc-0"><a href="#10-4-5-argv0-and-argc-0" class="headerlink" title="10.4.5 argv0 and argc==0"></a>10.4.5 argv0 and argc==0</h4><p>有些题目要求在启动时将<code>argv[0]</code>设置为一个特定的值，甚至要求它是NULL（即<code>argc==0</code>）。</p>
<p>通过<code>gdb.debug()</code>不可能用这种配置启动一个processs，但你可以使用<code>gdb.attach()</code>。这是因为在gdbserver下启动二进制文件的限制。</p>
<h2 id="十一、ROP"><a href="#十一、ROP" class="headerlink" title="十一、ROP"></a>十一、ROP</h2><h3 id="11-1-背景"><a href="#11-1-背景" class="headerlink" title="11.1 背景"></a>11.1 背景</h3><p>面向返回的编程（ROP）是一种绕过NX（no-execute，也称为预防数据执行（DEP））的技术。</p>
<p>Pwntools有几个特点，使ROP的利用更简单，但只适用于i386和amd64架构。</p>
<h3 id="11-2-加载一个ELF"><a href="#11-2-加载一个ELF" class="headerlink" title="11.2 加载一个ELF"></a>11.2 加载一个ELF</h3><p>要创建一个<code>ROP</code>对象，只需向它传递一个<code>ELF</code>文件。</p>
<pre><code>elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
</code></pre>
<p>这将自动加载二进制文件，并从其中提取大多数简单的gadgets。例如，如果你想加载<code>rbx</code>寄存器。</p>
<pre><code>rop.rbx
# Gadget(0x5fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x8)
</code></pre>
<h4 id="11-2-1-修复地址"><a href="#11-2-1-修复地址" class="headerlink" title="11.2.1 修复地址"></a>11.2.1 修复地址</h4><p>在这里，我们可以看到gadgets的地址，它的反汇编内容，它加载了什么寄存器，以及gadgets执行时堆栈被调整了多少。</p>
<p>由于在我们的例子中，<code>/bin/sh</code>是地址无关的（即使用ASLR），我们可以先调整ELF对象上的加载地址。</p>
<pre><code>elf.address = 0xff000000
rop = ROP(elf)
rop.rbx
# Gadget(0xff005fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x8)
</code></pre>
<h3 id="11-3-检查gadgets"><a href="#11-3-检查gadgets" class="headerlink" title="11.3 检查gadgets"></a>11.3 检查gadgets</h3><p>你可以通过魔法访问器询问ROP对象如何加载你想要的任何寄存器。我们在上面使用了<code>rbx</code>，但是我们也可以寻找其他的寄存器。</p>
<pre><code>rop.rbx
# Gadget(0xff005fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x8)
</code></pre>
<p>如果寄存器不能被加载，返回值为<code>None</code>。在我们的例子中，假如没有<code>pop rcx; ret</code>的gadgets：</p>
<pre><code>rop.rcx
# None
</code></pre>
<h4 id="11-3-1-查看所有gadgets"><a href="#11-3-1-查看所有gadgets" class="headerlink" title="11.3.1 查看所有gadgets"></a>11.3.1 查看所有gadgets</h4><p>Pwntools有意排除了大多数非实质性的gadgets，但你可以通过查看<code>ROP.gadgets</code>属性看到它已经加载的列表，该属性将一个gadgets的地址映射到gadgets本身。</p>
<pre><code>rop.gadgets
# &#123;4278225723: Gadget(0xff008b3b, [&#39;add esp, 0x10&#39;, &#39;pop rbx&#39;, &#39;pop rbp&#39;, &#39;pop r12&#39;, &#39;ret&#39;], [&#39;rbx&#39;, &#39;rbp&#39;, &#39;r12&#39;], 0x20),
#  4278278088: Gadget(0xff0157c8, [&#39;add esp, 0x130&#39;, &#39;pop rbp&#39;, &#39;ret&#39;], [&#39;rbp&#39;], 0x138),
#  4278284789: Gadget(0xff0171f5, [&#39;add esp, 0x138&#39;, &#39;pop rbx&#39;, &#39;pop rbp&#39;, &#39;ret&#39;], [&#39;rbx&#39;, &#39;rbp&#39;], 0x144),
#  4278272966: Gadget(0xff0143c6, [&#39;add esp, 0x18&#39;, &#39;ret&#39;], [], 0x1c),
#  4278239612: Gadget(0xff00c17c, [&#39;add esp, 0x20&#39;, &#39;pop rbx&#39;, &#39;pop rbp&#39;, &#39;pop r12&#39;, &#39;ret&#39;], [&#39;rbx&#39;, &#39;rbp&#39;, &#39;r12&#39;], 0x30),
#  4278259611: Gadget(0xff010f9b, [&#39;add esp, 0x28&#39;, &#39;pop rbp&#39;, &#39;pop r12&#39;, &#39;ret&#39;], [&#39;rbp&#39;, &#39;r12&#39;], 0x34),
# ...
#  4278216828: Gadget(0xff00687c, [&#39;pop rsp&#39;, &#39;pop r13&#39;, &#39;ret&#39;], [&#39;rsp&#39;, &#39;r13&#39;], 0xc),
#  4278214225: Gadget(0xff005e51, [&#39;pop rsp&#39;, &#39;ret&#39;], [&#39;rsp&#39;], 0x8),
#  4278210586: Gadget(0xff00501a, [&#39;ret&#39;], [], 0x4)&#125;
</code></pre>
<h4 id="11-3-2-真正查看所有的gadgets"><a href="#11-3-2-真正查看所有的gadgets" class="headerlink" title="11.3.2 真正查看所有的gadgets"></a>11.3.2 真正查看所有的gadgets</h4><p>Pwntools的ROP过滤掉了非实质性的小工具，所以如果它没有你想要的东西，我们建议使用ROPGadget来检查二进制文件。</p>
<h3 id="11-4-添加原始数据"><a href="#11-4-添加原始数据" class="headerlink" title="11.4 添加原始数据"></a>11.4 添加原始数据</h3><p>为了将原始数据添加到ROP栈中，只需调用<code>ROP.raw()</code>。</p>
<pre><code>rop.raw(0xdeadbeef)
rop.raw(0xcafebabe)
rop.raw(&#39;asdf&#39;)
</code></pre>
<h3 id="11-5-导出ROP栈"><a href="#11-5-导出ROP栈" class="headerlink" title="11.5 导出ROP栈"></a>11.5 导出ROP栈</h3><p>现在我们有了一些gadgets，让我们看看ROP栈上有什么：</p>
<pre><code>print(rop.dump())
# 0x0000:       0xdeadbeef
# 0x0004:       0xcafebabe
# 0x0008:          b&#39;asdf&#39; &#39;asdf&#39;
</code></pre>
<h3 id="11-6-提取原始字节"><a href="#11-6-提取原始字节" class="headerlink" title="11.6 提取原始字节"></a>11.6 提取原始字节</h3><p>现在我们有了一个ROP栈，我们想从它那里得到原始字节。我们可以使用<code>byte()</code>方法来实现这个功能。</p>
<pre><code>print(hexdump(bytes(rop)))
# 00000000  ef be ad de  be ba fe ca  61 73 64 66               │····│····│asdf│
# 0000000c
</code></pre>
<h3 id="11-7-神奇地调用函数"><a href="#11-7-神奇地调用函数" class="headerlink" title="11.7 神奇地调用函数"></a>11.7 神奇地调用函数</h3><p>Pwntools的ROP工具的真正威力在于能够调用任意的函数，无论是通过神奇的访问器还是通过<code>ROP.call()</code>例程。</p>
<pre><code>elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
rop.call(0xdeadbeef, [0, 1])
print(rop.dump())
# 0x0000:       0xdeadbeef 0xdeadbeef(0, 1, 2, 3)
# 0x0004:          b&#39;baaa&#39; &lt;return address&gt;
# 0x0008:              0x0 arg0
# 0x000c:              0x1 arg1
</code></pre>
<p>注意这里它使用的是32位ABI，这是不正确的。我们也可以对64位二进制文件进行ROP，但我们需要相应地设置<code>context.arch</code>。我们可以使用<code>context.binary</code>来自动完成这个工作。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
rop.call(0xdeadbeef, [0, 1])
print(rop.dump())
# 0x0000:           0x61aa pop rdi; ret
# 0x0008:              0x0 [arg0] rdi = 0
# 0x0010:           0x5f73 pop rsi; ret
# 0x0018:              0x1 [arg1] rsi = 1
# 0x0020:       0xdeadbeef
</code></pre>
<h3 id="11-8-使用函数名来调用函数"><a href="#11-8-使用函数名来调用函数" class="headerlink" title="11.8 使用函数名来调用函数"></a>11.8 使用函数名来调用函数</h3><p>如果你的库在其GOT/PLT中有你想调用的函数，或者有二进制的符号，你可以直接调用函数名。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
rop.execve(0xdeadbeef)
print(rop.dump())
# 0x0000:           0x61aa pop rdi; ret
# 0x0008:       0xdeadbeef [arg0] rdi = 3735928559
# 0x0010:           0x5824 execve
</code></pre>
<h3 id="11-9-多重ELF"><a href="#11-9-多重ELF" class="headerlink" title="11.9 多重ELF"></a>11.9 多重ELF</h3><p>一般来说，在你的进程的地址空间中，一次有一个以上的ELF可用。让我们看一个使用<code>/bin/sh</code>以及其<code>libc</code>的例子。最初，我们看了<code>rop.rcx</code>，这个gadgets是不存在的，因为bash中没有<code>pop rcx; ret</code>这个gadgets。然后，现在我们也有来自libc的所有gadgets了。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
libc = elf.libc

elf.address = 0xAA000000
libc.address = 0xBB000000

rop.rax
# Gadget(0xaa00eb87, [&#39;pop rax&#39;, &#39;ret&#39;], [&#39;rax&#39;], 0x10)
rop.rbx
# Gadget(0xaa005fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x10)
rop.rcx
# Gadget(0xbb09f822, [&#39;pop rcx&#39;, &#39;ret&#39;], [&#39;rcx&#39;], 0x10)
rop.rdx
# Gadget(0xbb117960, [&#39;pop rdx&#39;, &#39;add rsp, 0x38&#39;, &#39;ret&#39;], [&#39;rdx&#39;], 0x48)
</code></pre>
<p>注意<code>rax</code>和<code>rbx</code>的gadgets是在主二进制文件中（0xAA…），而后两个是在libc（0xBB…）。</p>
<p>现在，让我们做一个更复杂的函数调用吧!</p>
<pre><code>rop.memcpy(0xaaaaaaaa, 0xbbbbbbbb, 0xcccccccc)
print(rop.dump())
# 0x0000:       0xbb11c1e1 pop rdx; pop r12; ret
# 0x0008:       0xcccccccc [arg2] rdx = 3435973836
# 0x0010:      b&#39;eaaafaaa&#39; &lt;pad r12&gt;
# 0x0018:       0xaa0061aa pop rdi; ret
# 0x0020:       0xaaaaaaaa [arg0] rdi = 2863311530
# 0x0028:       0xaa005f73 pop rsi; ret
# 0x0030:       0xbbbbbbbb [arg1] rsi = 3149642683
# 0x0038:       0xaa0058a4 memcpy
</code></pre>
<p>请注意，Pwntools能够使用<code>pop rdx; pop r12; ret</code>gadgets，并说明堆栈上需要的额外值。还要注意的是，每个项目的符号值都在<code>rop.dump()</code>中获取。例如，它显示我们正在设置<code>rdx=3435973836</code>。</p>
<h3 id="11-10-获取一个shell"><a href="#11-10-获取一个shell" class="headerlink" title="11.10 获取一个shell"></a>11.10 获取一个shell</h3><p>当我们了解了pwntools的ROP功能时，获得一个shell是很容易的！我们直接调用<code>execve</code>，并从内存中的某个地方找到一个<code>&quot;/bin/sh/x00 &quot;</code>的实例作为第一个参数传递进去。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
libc = elf.libc

elf.address = 0xAA000000
libc.address = 0xBB000000

rop = ROP([elf, libc])

binsh = next(libc.search(b&quot;/bin/sh\x00&quot;))
rop.execve(binsh, 0, 0)
</code></pre>
<p>显示我们的ROP栈</p>
<pre><code>print(rop.dump())
# 0x0000:       0xbb11c1e1 pop rdx; pop r12; ret
# 0x0008:              0x0 [arg2] rdx = 0
# 0x0010:      b&#39;eaaafaaa&#39; &lt;pad r12&gt;
# 0x0018:       0xaa0061aa pop rdi; ret
# 0x0020:       0xbb1b75aa [arg0] rdi = 3139138986
# 0x0028:       0xaa005f73 pop rsi; ret
# 0x0030:              0x0 [arg1] rsi = 0
# 0x0038:       0xaa005824 execve
</code></pre>
<p>提取ROP的原始字节</p>
<pre><code>print(hexdump(bytes(rop)))
# 00000000  e1 c1 11 bb  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
# 00000010  65 61 61 61  66 61 61 61  aa 61 00 aa  00 00 00 00  │eaaa│faaa│·a··│····│
# 00000020  aa 75 1b bb  00 00 00 00  73 5f 00 aa  00 00 00 00  │·u··│····│s_··│····│
# 00000030  00 00 00 00  00 00 00 00  24 58 00 aa  00 00 00 00  │····│····│$X··│····│
# 00000040
</code></pre>
<h2 id="十二、日志"><a href="#十二、日志" class="headerlink" title="十二、日志"></a>十二、日志</h2><p>Pwntools有一个丰富的内部调试系统，可用于你自己的调试，以及弄清Pwntools幕后发生的事情。</p>
<h3 id="12-1-功能"><a href="#12-1-功能" class="headerlink" title="12.1 功能"></a>12.1 功能</h3><p>当你从pwn导入*时，日志功能就导入了。这些功能如下：</p>
<ul>
<li>  <code>error</code></li>
<li>  <code>warn</code></li>
<li>  <code>info</code></li>
<li>  <code>debug</code></li>
</ul>
<p>例如：</p>
<pre><code>&gt;&gt;&gt; warn(&#39;Warning!&#39;)
[!] Warning!
&gt;&gt;&gt; info(&#39;Info!&#39;)
[*] Info!
&gt;&gt;&gt; debug(&#39;Debug!&#39;)
</code></pre>
<p>注意，最后一行默认不显示，因为默认的日志级别是 “info”。</p>
<p>你可以在你的开发脚本中使用这些，而不是打印，这可以让你准确地调控你看到的调试信息量</p>
<p>你可以通过各种方式控制哪些日志信息是可见的，所有这些都将在下面解释。</p>
<h3 id="12-2-命令行"><a href="#12-2-命令行" class="headerlink" title="12.2 命令行"></a>12.2 命令行</h3><p>最简单的方法是在运行你的脚本时加入神奇的参数DEBUG，例如：打开最大限度的日志记录功能：</p>
<pre><code>$ python exploit.py DEBUG
</code></pre>
<p>这对于查看正在发送/接收的确切字节，以及在pwntools内部发生的事情，以使你的EXP发挥作用是很有用的。</p>
<h3 id="12-3-环境"><a href="#12-3-环境" class="headerlink" title="12.3 环境"></a>12.3 环境</h3><p>你也可以通过context.log_level来设置日志的粗略程度，就像你设置目标架构等的方式一样。这与在命令行中控制所有的日志语句的方式相同。</p>
<pre><code>&gt;&gt;&gt; context.log_level = &#39;debug&#39;
</code></pre>
<p><code>log_console</code></p>
<p>默认情况下，所有的日志都转到STDOUT。如果你想把它改成一个不同的文件，例如STDERR，你可以通过log_console设置来实现。</p>
<pre><code>&gt;&gt;&gt; context.log_console = sys.stderr
</code></pre>
<p><code>log_file</code></p>
<p>有时你想让你的日志转到一个特定的文件，例如log.txt，以便以后查看。你可以通过设置context.log_file来添加一个日志文件。</p>
<pre><code>&gt;&gt;&gt; context.log_file = &#39;./log.txt&#39;
</code></pre>
<h3 id="12-4-管道"><a href="#12-4-管道" class="headerlink" title="12.4 管道"></a>12.4 管道</h3><p>每个管子在创建时都可以单独控制其日志的粗略程度。只需将<code>level=&#39;...&#39;</code>传递给对象的构造。</p>
<pre><code>&gt;&gt;&gt; io = process(&#39;sh&#39;, level=&#39;debug&#39;)
[x] Starting local process &#39;/usr/bin/sh&#39; argv=[b&#39;sh&#39;]
[+] Starting local process &#39;/usr/bin/sh&#39; argv=[b&#39;sh&#39;] : pid 34475
&gt;&gt;&gt; io.sendline(&#39;echo hello&#39;)
[DEBUG] Sent 0xb bytes:
    b&#39;echo hello\n&#39;
&gt;&gt;&gt; io.recvline()
[DEBUG] Received 0x6 bytes:
    b&#39;hello\n&#39;
b&#39;hello\n&#39;
</code></pre>
<p>这适用于所有的管子（<code>process</code>、<code>remote</code>等），也适用于类似管子的东西（如<code>gdb.attach</code>和<code>gdb.debug</code>）以及其他许多例程。</p>
<p>例如，如果你想确切地看到一些shellcode是如何组装的。</p>
<pre><code>&gt;&gt;&gt; asm(&#39;nop&#39;, log_level=&#39;debug&#39;)
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/pwntools/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,&quot;awx&quot;
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    nop
[DEBUG] /usr/bin/x86_64-linux-gnu-as -32 -o /tmp/user/pwn-asm-0yy12n6i/step2 /tmp/user/pwn-asm-0yy12n6i/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/user/pwn-asm-0yy12n6i/step3 /tmp/user/pwn-asm-0yy12n6i/step4
b&#39;\x90&#39;
</code></pre>
<h3 id="12-5-范围"><a href="#12-5-范围" class="headerlink" title="12.5 范围"></a>12.5 范围</h3><p>有时你希望所有的日志都被启用，但只针对部分漏洞脚本。你可以手动切换<code>context.log_level</code>，或者你可以使用一个范围内的助手。</p>
<pre><code>io = process(...)
with context.local(log_level=&#39;debug&#39;):
    # Things inside the &#39;with&#39; block are logged verbosely
    io.recvall()
</code></pre>

    </div>
     
    <div class="post-footer__meta"><p>updated at 2023-05-11</p></div> 
    <div class="post-entry__tags"><a href="/tags/pwn/" class="post-tags__link button"># pwn</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2023/05/11/IDA/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            IDA
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2023/05/10/gcc-protection/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            gcc_protection
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
    
        <span id="leancloud_container_site_uv" hidden>
            <span>总访问人</span>
            <span id="leancloud_value_site_uv"></span>
            <span></span>
            
                <span> </span>
            
        </span>
    
    
        <span id="leancloud_container_site_pv" hidden>
            <span>总访问量</span>
            <span id="leancloud_value_site_pv"></span>
            <span></span>
            
                <span> </span>
            
        </span>
    

     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2023 <a href="/">Gwoo</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 



 



 


    
    <script>
        (function () {
            function getRecord(Counter, target) {
                return new Promise(function (resolve, reject) {
                    Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
                        .then(response => response.json())
                        .then(({results}) => {
                            if (results && results.length > 0) {
                                var record = results[0];
                                resolve(record);
                            } else {
                                Counter('post', '/classes/Counter', {
                                        target, time: 0
                                    })
                                    .then(response => response.json())
                                    .then(record => {
                                        resolve(record);
                                    }).catch(error => {
                                        console.error('Failed to create', error);
                                        reject(error);
                                    });
                            }
                        }).catch(error => {
                            console.error('LeanCloud Counter Error', error);
                            reject(error);
                        });
                })
            }
        
            function buildIncrement(objectId) {
                return {
                    "method": "PUT",
                    "path": `/1.1/classes/Counter/${ objectId }`,
                    "body": {
                        "time": {
                            '__op': 'Increment',
                            'amount': 1
                        }
                    }
                }
            }
        
            function increment(Counter, incrArr) {
                return new Promise(function (resolve, reject) {
                    Counter('post', '/batch', {
                        "requests": incrArr
                    }).then((res) => {
                        resolve(res);
                    }).catch(error => {
                        console.error('Failed to save visitor count', error);
                        reject(error);
                    });
                });
            }
        
            function validUV() {
                var key = 'LeanCloud_UV_Flag';
                var flag = localStorage.getItem(key);
                if (flag) {
                    if (new Date().getTime() - parseInt(flag) <= 86400000) {
                        return false;
                    }
                }
                localStorage.setItem(key, new Date().getTime().toString());
                return true;
            }
        
            function addCount(Counter) {
                var enableIncr = 'leancloud' === 'leancloud';
                var getterArr = [];
                var incrArr = [];
                var pvCtn = document.querySelector('#leancloud_container_site_pv');
                if (pvCtn || enableIncr) {
                    var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
                        incrArr.push(buildIncrement(record.objectId))
                        var ele = document.querySelector('#leancloud_value_site_pv');
                        if (ele) {
                            ele.innerText = record.time + 1;
                            if (pvCtn) {
                                pvCtn.style.display = 'inline';
                            }
                        }
                    });
                    getterArr.push(pvGetter);
                }
                var uvCtn = document.querySelector('#leancloud_container_site_uv');
                if (uvCtn || enableIncr) {
                    var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
                        var vuv = validUV();
                        vuv && incrArr.push(buildIncrement(record.objectId))
                        var ele = document.querySelector('#leancloud_value_site_uv');
                        if (ele) {
                            ele.innerText = record.time + (vuv ? 1 : 0);
                            if (uvCtn) {
                                uvCtn.style.display = 'inline';
                            }
                        }
                    });
                    getterArr.push(uvGetter);
                }
                if ('true' === 'true') {
                    var viewCtn = document.querySelector('#leancloud_container_page_pv');
                    if (viewCtn || enableIncr) {
                        var target = decodeURI('/2023/05/11/pwntools/');
                        var viewGetter = getRecord(Counter, target).then((record) => {
                            incrArr.push(buildIncrement(record.objectId))
                            if (viewCtn) {
                                var ele = document.querySelector('#leancloud_value_page_pv');
                                if (ele) {
                                    ele.innerText = (record.time || 0) + 1;
                                    viewCtn.style.display = 'inline';
                                }
                            }
                        });
                        getterArr.push(viewGetter);
                    }
                }
                if (enableIncr) {
                    Promise.all(getterArr).then(() => {
                        incrArr.length > 0 && increment(Counter, incrArr);
                    })
                }
            }
        
            var app_id = 'bJN1qKDryqdQMB2GyyxMcO8b-gzGzoHsz';
            var app_key = 'J2HWpTbi7MLIsrnuJaALYcw2';
            var server_url = '';
        
            function fetchData(api_server) {
                var Counter = (method, url, data) => {
                    return fetch(`${ api_server }/1.1${ url }`, {
                        method,
                        headers: {
                                'X-LC-Id': app_id,
                                'X-LC-Key': app_key,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(data)
                    });
                };
                addCount(Counter);
            }
            var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
            if (api_server) {
                fetchData(api_server);
            } else {
                fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
                    .then(response => response.json())
                    .then(({api_server}) => {
                        fetchData('https://' + api_server);
                    });
            }
        })();
    </script>

 

 

 

 

 

 




    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
