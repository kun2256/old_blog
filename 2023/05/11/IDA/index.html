<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/img/duck.jpeg">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/img/duck.jpeg">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/img/duck.jpeg">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/img/duck.jpeg">
    
    
        <link rel="mask-icon" href="/img/duck.jpeg">
    


    <!-- meta -->


<title>IDA | Gwoo</title>


    <meta name="keywords" content="pwn">




    <!-- OpenGraph -->
 
    <meta name="description" content="转自:https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_73644864&#x2F;article&#x2F;details&#x2F;128376581  学习逆向工程需要熟悉一个反汇编器的使用，学会阅读汇编语言，学会编写脚本和查找资料 IDA是功能很强大的一款反汇编机器，本文保姆级讲解了IDA的基本使用   目录 序言 IDA Pro简介 IDA的基本用法 ida文件加载 IDA桌面简介 导航带 反汇编窗口 函数窗口 十六">
<meta property="og:type" content="article">
<meta property="og:title" content="IDA">
<meta property="og:url" content="http://example.com/2023/05/11/IDA/index.html">
<meta property="og:site_name" content="Gwoo">
<meta property="og:description" content="转自:https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_73644864&#x2F;article&#x2F;details&#x2F;128376581  学习逆向工程需要熟悉一个反汇编器的使用，学会阅读汇编语言，学会编写脚本和查找资料 IDA是功能很强大的一款反汇编机器，本文保姆级讲解了IDA的基本使用   目录 序言 IDA Pro简介 IDA的基本用法 ida文件加载 IDA桌面简介 导航带 反汇编窗口 函数窗口 十六">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e6c53b96479a43de82c0af9e529476e3.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f4dc9e4f81c268f59add57aeb7e16548.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/5cf94032a6a01c01dfa50256eac26f5e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/0cd6ba94670595b77bd4da7e04e00f1e.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b095e80418b3fde4b47aca392c730cf9.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/c6fa1a6bb820081793c9ad95a2aa231e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f9dbf4b21e11457abd9fd1e484d78249.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/250e9136c6604e9a8ef033b9be7ea4b0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8f3f7a0374e446e2a0e56659ff2ddbb1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/99a991fef5714a16ba1da3651089b204.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5769c6b338d54c888be76f8b5ef7ac9f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d1464ac58cb140a785f5c0823cab3cac.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9253b516d83f46f1a720d8179bf94ecf.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/08a2e0477b5141fa964ebf3c4fbe8294.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8c64a65a6abe49858df9e5508d350e42.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f881e8ae1c3542f784c7efe273afddd3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b324701f0c3743a8beb7132f320142dd.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/59867bcaab154656aaba47aa9cab99e9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/fd98607840d94153907c0d3dfc3524d4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/42f442e268e84ae0aed090a24d174a31.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/65046984e569482f97f56ad9d654bc31.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/02a564ca09a94986a59c836afbbb7ca4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5042c012424a4123b0768a55b236ec14.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9cce1ed51a084869950cd80e81d20a65.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8337a294b47549a98dee9e29d8dfc02f.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/85e03ba5bded4c7ba1d362001d68ebea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/08db388a2aef44d9a6f225c80decef52.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b3dffdfa41194ac985d9f5c986a54e1a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e3115472ae8f41659c0c1c24411e00a8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20d4fb5909f34cb88e36a3173c4a8abe.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/37c83fb1563444969fca073537c4dd90.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e7abea6f0dad4f8e9278431feb01a044.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/952ca29cd08848e1910be12f55c67be5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b5c78a7c306842dcb28fd36a61b65737.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4ae8842d252e45e597f83ee260dc0cb8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5fdc1c5bd4164d27a324197a97f7c34d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/22dca596fdfe4e3cbe848183e13dc5ec.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/18e8f294983840b1a46c7a72cb96d23a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a98d45452248425aa259ed70de90922c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e28bd31e1ffa4dc39c8600105f318e6c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/650ec1eee7344e5296417e0973109322.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/185c28c668b448a58a3455dfd76fc6c9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4b3e1070e1bb5fb24f28034fab4f07ad.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e7fe0fc1e6bfb0498c0436d2925a5459.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a688fe913cca4a288ed0a9c94f612932.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/62c37388e7a84d44939a698859d06dde.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/2186472ae16640ffe7750fa781ddc43b.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d1e01cfd5cdd4751854c5ba229d56e7f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c39db0f349034db993d458f0193aa704.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6511a644e9be496783603b524af326b0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0a82b67b963b48caac04e14474f01f51.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4f67cc320e0843b98376ed157dc359b0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/44d992ad434e4144a103eac2e894e8a9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b84f4021687c4a3ca4a059a5fa6827e1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8edd0bcfccff40568c191a873d4eb84a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/aa96d675deb1464ca9338141886d8939.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/85bfc453015d4e27971a0c1c1fe8709a.jpeg">
<meta property="article:published_time" content="2023-05-11T13:09:36.000Z">
<meta property="article:modified_time" content="2023-05-11T13:19:25.279Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/e6c53b96479a43de82c0af9e529476e3.jpeg">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/dark.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.4.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">孤鹜</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        IDA
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2023/05/" class="post-meta__date button">2023-05-11</a>
        
 
        
     
    <span id="leancloud_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span>总访问量</span>
        <span id="leancloud_value_page_pv"></span>
        <span></span>
    </span>

    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ida%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-text">ida文件加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E6%A1%8C%E9%9D%A2%E7%AE%80%E4%BB%8B"><span class="toc-text">IDA桌面简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%B8%A6"><span class="toc-text">导航带</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E7%AA%97%E5%8F%A3"><span class="toc-text">反汇编窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AA%97%E5%8F%A3"><span class="toc-text">函数窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%AA%97%E5%8F%A3"><span class="toc-text">十六进制窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hex-view"><span class="toc-text">Hex view</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%AA%97%E5%8F%A3"><span class="toc-text">结构体窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%AA%97%E5%8F%A3"><span class="toc-text">枚举窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strings%E7%AA%97%E5%8F%A3"><span class="toc-text">Strings窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Names%E7%AA%97%E5%8F%A3"><span class="toc-text">Names窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACDU"><span class="toc-text">ACDU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8"><span class="toc-text">交叉引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%EF%BC%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%8C%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B7%B3%E8%BD%AC%EF%BC%89"><span class="toc-text">代码交叉引用（函数调用，顺序执行和跳转）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%95%B0%E6%8D%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8"><span class="toc-text">数据数据交叉引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8"><span class="toc-text">访问交叉引用列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0"><span class="toc-text">名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="toc-text">修改参数，局部变量，函数名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%9C%B0%E5%9D%80%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">修改地址的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">重命名寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E6%B3%A8%E9%87%8A"><span class="toc-text">IDA注释 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-text">函数操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-text">新建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-text">删除函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">代码和数据的相互转换 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84"><span class="toc-text">指定数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-text">显示汇编语言对应的机器码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Patch"><span class="toc-text">Patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9exe%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BF%9D%E5%AD%98%E8%BF%90%E8%A1%8C"><span class="toc-text">修改exe文件并保存运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%92%8CIDC%E8%AF%AD%E6%B3%95"><span class="toc-text">脚本的使用方式和IDC语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%8F%92%E4%BB%B6"><span class="toc-text">构建插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="toc-text">安装插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-text">插件配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDAPython"><span class="toc-text">IDAPython</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8%E9%80%9A%E5%B8%B8%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%A4%A7%E6%A6%82%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">调试器通常用于执行以下两种任务（大概了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">开始动态调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9"><span class="toc-text">断点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">软件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">硬件断点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA"><span class="toc-text">跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-text">寄存器变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86"><span class="toc-text">监视</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%9B%BE%E5%BD%A2"><span class="toc-text">IDA的第三方图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">外部流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E5%9B%BE"><span class="toc-text">外部调用图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E5%9B%BE"><span class="toc-text">外部交叉引用图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%AE%E5%BD%95"><span class="toc-text">二、目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85Pwntools"><span class="toc-text">三、安装Pwntools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85"><span class="toc-text">3.1 验证安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B6%E5%AE%83%E6%9E%B6%E6%9E%84"><span class="toc-text">3.2 其它架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">四、管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E7%A1%80IO"><span class="toc-text">4.1 基础IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2 进程和基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%9A%E8%AF%9D%E4%BA%92%E5%8A%A8"><span class="toc-text">4.3 会话互动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BD%91%E7%BB%9C"><span class="toc-text">4.4 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%AE%89%E5%85%A8%E7%9A%84Shell"><span class="toc-text">4.5 安全的Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3"><span class="toc-text">4.6 串行端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">五、实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E6%95%B4%E6%95%B0"><span class="toc-text">5.1 打包和解包整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6I-O"><span class="toc-text">5.2 文件I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%93%88%E5%B8%8C%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-text">5.3 哈希和编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A0%B7%E4%BE%8B%E7%94%9F%E6%88%90"><span class="toc-text">5.4 样例生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Bytes-vs-Strings"><span class="toc-text">六、Bytes vs. Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Python2"><span class="toc-text">6.1 Python2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Python3"><span class="toc-text">6.2 Python3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%BA%BB%E7%83%A6"><span class="toc-text">6.3 麻烦</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%8E%AF%E5%A2%83"><span class="toc-text">七、环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="toc-text">7.1 环境设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81ELFs"><span class="toc-text">八、ELFs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8A%A0%E8%BD%BDELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.1 加载ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">8.2 使用符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%94%B9%E5%8F%98%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80"><span class="toc-text">8.3 改变基本地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%AF%BB%E5%8F%96ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.4 读取ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%AF%B9ELF%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E8%A1%A5"><span class="toc-text">8.5 对ELF文件进行修补</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%90%9C%E7%B4%A2ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.6 搜索ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E6%9E%84%E5%BB%BAELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.7 构建ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.8 运行和调试ELF文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B1%87%E7%BC%96"><span class="toc-text">九、汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96"><span class="toc-text">9.1 基础汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%8E%B0%E6%88%90%E7%9A%84%E6%B1%87%E7%BC%96%EF%BC%88shellcraft%EF%BC%89"><span class="toc-text">9.2 现成的汇编（shellcraft）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.3 命令行工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">9.4 异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E7%8E%B0%E6%88%90%E6%B1%87%E7%BC%96"><span class="toc-text">9.4.1 现成汇编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.4.2 命令行工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">十、调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%85%88%E5%89%8D%E6%9D%A1%E4%BB%B6"><span class="toc-text">10.1 先前条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%9C%A8GDB%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.2 在GDB下启动一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E9%99%84%E5%8A%A0%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3 附加到一个正在运行的进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3.1 本地进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">10.3.2 远程服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E8%B0%83%E8%AF%95%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">10.3 调试异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%8F%90%E7%A4%BA%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-text">10.3.1 提示和限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%EF%BC%88Pwntools%E8%87%AA%E8%BA%AB%EF%BC%89"><span class="toc-text">10.4 故障排除（Pwntools自身）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE%EF%BC%88%E5%B7%A5%E4%BD%9C%E8%AF%A6%E6%83%85%EF%BC%89"><span class="toc-text">10.4.1 幕后花絮（工作详情）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3"><span class="toc-text">10.4.2 指定一个终端窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">10.4.3 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-4-%E6%97%A0%E6%B3%95%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B%E4%B8%AD"><span class="toc-text">10.4.4 无法附加到进程中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-5-argv0-and-argc-0"><span class="toc-text">10.4.5 argv0 and argc&#x3D;&#x3D;0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81ROP"><span class="toc-text">十一、ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E8%83%8C%E6%99%AF"><span class="toc-text">11.1 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AAELF"><span class="toc-text">11.2 加载一个ELF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E4%BF%AE%E5%A4%8D%E5%9C%B0%E5%9D%80"><span class="toc-text">11.2.1 修复地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E6%A3%80%E6%9F%A5gadgets"><span class="toc-text">11.3 检查gadgets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89gadgets"><span class="toc-text">11.3.1 查看所有gadgets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E7%9C%9F%E6%AD%A3%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84gadgets"><span class="toc-text">11.3.2 真正查看所有的gadgets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-text">11.4 添加原始数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%AF%BC%E5%87%BAROP%E6%A0%88"><span class="toc-text">11.5 导出ROP栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E6%8F%90%E5%8F%96%E5%8E%9F%E5%A7%8B%E5%AD%97%E8%8A%82"><span class="toc-text">11.6 提取原始字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E7%A5%9E%E5%A5%87%E5%9C%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.7 神奇地调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%90%8D%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.8 使用函数名来调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9-%E5%A4%9A%E9%87%8DELF"><span class="toc-text">11.9 多重ELF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAshell"><span class="toc-text">11.10 获取一个shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-text">十二、日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%8A%9F%E8%83%BD"><span class="toc-text">12.1 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">12.2 命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E7%8E%AF%E5%A2%83"><span class="toc-text">12.3 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E7%AE%A1%E9%81%93"><span class="toc-text">12.4 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E8%8C%83%E5%9B%B4"><span class="toc-text">12.5 范围</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">Article Directory</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ida%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-text">ida文件加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E6%A1%8C%E9%9D%A2%E7%AE%80%E4%BB%8B"><span class="toc-text">IDA桌面简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%B8%A6"><span class="toc-text">导航带</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E7%AA%97%E5%8F%A3"><span class="toc-text">反汇编窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AA%97%E5%8F%A3"><span class="toc-text">函数窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%AA%97%E5%8F%A3"><span class="toc-text">十六进制窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hex-view"><span class="toc-text">Hex view</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%AA%97%E5%8F%A3"><span class="toc-text">结构体窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%AA%97%E5%8F%A3"><span class="toc-text">枚举窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strings%E7%AA%97%E5%8F%A3"><span class="toc-text">Strings窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Names%E7%AA%97%E5%8F%A3"><span class="toc-text">Names窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACDU"><span class="toc-text">ACDU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8"><span class="toc-text">交叉引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%EF%BC%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%8C%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B7%B3%E8%BD%AC%EF%BC%89"><span class="toc-text">代码交叉引用（函数调用，顺序执行和跳转）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%95%B0%E6%8D%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8"><span class="toc-text">数据数据交叉引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8"><span class="toc-text">访问交叉引用列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0"><span class="toc-text">名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="toc-text">修改参数，局部变量，函数名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%9C%B0%E5%9D%80%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">修改地址的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">重命名寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E6%B3%A8%E9%87%8A"><span class="toc-text">IDA注释 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-text">函数操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-text">新建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-text">删除函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">代码和数据的相互转换 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84"><span class="toc-text">指定数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-text">显示汇编语言对应的机器码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Patch"><span class="toc-text">Patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9exe%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BF%9D%E5%AD%98%E8%BF%90%E8%A1%8C"><span class="toc-text">修改exe文件并保存运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%92%8CIDC%E8%AF%AD%E6%B3%95"><span class="toc-text">脚本的使用方式和IDC语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%8F%92%E4%BB%B6"><span class="toc-text">构建插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="toc-text">安装插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-text">插件配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDAPython"><span class="toc-text">IDAPython</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8%E9%80%9A%E5%B8%B8%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%A4%A7%E6%A6%82%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">调试器通常用于执行以下两种任务（大概了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">开始动态调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9"><span class="toc-text">断点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">软件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">硬件断点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA"><span class="toc-text">跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-text">寄存器变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86"><span class="toc-text">监视</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%9B%BE%E5%BD%A2"><span class="toc-text">IDA的第三方图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">外部流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E5%9B%BE"><span class="toc-text">外部调用图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E5%9B%BE"><span class="toc-text">外部交叉引用图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%AE%E5%BD%95"><span class="toc-text">二、目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85Pwntools"><span class="toc-text">三、安装Pwntools</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85"><span class="toc-text">3.1 验证安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B6%E5%AE%83%E6%9E%B6%E6%9E%84"><span class="toc-text">3.2 其它架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">四、管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E7%A1%80IO"><span class="toc-text">4.1 基础IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2 进程和基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%9A%E8%AF%9D%E4%BA%92%E5%8A%A8"><span class="toc-text">4.3 会话互动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BD%91%E7%BB%9C"><span class="toc-text">4.4 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%AE%89%E5%85%A8%E7%9A%84Shell"><span class="toc-text">4.5 安全的Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3"><span class="toc-text">4.6 串行端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">五、实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E6%95%B4%E6%95%B0"><span class="toc-text">5.1 打包和解包整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6I-O"><span class="toc-text">5.2 文件I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%93%88%E5%B8%8C%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-text">5.3 哈希和编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A0%B7%E4%BE%8B%E7%94%9F%E6%88%90"><span class="toc-text">5.4 样例生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Bytes-vs-Strings"><span class="toc-text">六、Bytes vs. Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Python2"><span class="toc-text">6.1 Python2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Python3"><span class="toc-text">6.2 Python3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%BA%BB%E7%83%A6"><span class="toc-text">6.3 麻烦</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%8E%AF%E5%A2%83"><span class="toc-text">七、环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="toc-text">7.1 环境设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81ELFs"><span class="toc-text">八、ELFs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8A%A0%E8%BD%BDELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.1 加载ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">8.2 使用符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%94%B9%E5%8F%98%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80"><span class="toc-text">8.3 改变基本地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%AF%BB%E5%8F%96ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.4 读取ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%AF%B9ELF%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E8%A1%A5"><span class="toc-text">8.5 对ELF文件进行修补</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%90%9C%E7%B4%A2ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.6 搜索ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E6%9E%84%E5%BB%BAELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.7 构建ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95ELF%E6%96%87%E4%BB%B6"><span class="toc-text">8.8 运行和调试ELF文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B1%87%E7%BC%96"><span class="toc-text">九、汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96"><span class="toc-text">9.1 基础汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%8E%B0%E6%88%90%E7%9A%84%E6%B1%87%E7%BC%96%EF%BC%88shellcraft%EF%BC%89"><span class="toc-text">9.2 现成的汇编（shellcraft）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.3 命令行工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">9.4 异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E7%8E%B0%E6%88%90%E6%B1%87%E7%BC%96"><span class="toc-text">9.4.1 现成汇编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">9.4.2 命令行工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">十、调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%85%88%E5%89%8D%E6%9D%A1%E4%BB%B6"><span class="toc-text">10.1 先前条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%9C%A8GDB%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.2 在GDB下启动一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E9%99%84%E5%8A%A0%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3 附加到一个正在运行的进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">10.3.1 本地进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">10.3.2 远程服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E8%B0%83%E8%AF%95%E5%BC%82%E6%9E%84%E6%9E%B6%E6%9E%84"><span class="toc-text">10.3 调试异构架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%8F%90%E7%A4%BA%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-text">10.3.1 提示和限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%EF%BC%88Pwntools%E8%87%AA%E8%BA%AB%EF%BC%89"><span class="toc-text">10.4 故障排除（Pwntools自身）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE%EF%BC%88%E5%B7%A5%E4%BD%9C%E8%AF%A6%E6%83%85%EF%BC%89"><span class="toc-text">10.4.1 幕后花絮（工作详情）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3"><span class="toc-text">10.4.2 指定一个终端窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">10.4.3 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-4-%E6%97%A0%E6%B3%95%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B%E4%B8%AD"><span class="toc-text">10.4.4 无法附加到进程中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-5-argv0-and-argc-0"><span class="toc-text">10.4.5 argv0 and argc&#x3D;&#x3D;0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81ROP"><span class="toc-text">十一、ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E8%83%8C%E6%99%AF"><span class="toc-text">11.1 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AAELF"><span class="toc-text">11.2 加载一个ELF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E4%BF%AE%E5%A4%8D%E5%9C%B0%E5%9D%80"><span class="toc-text">11.2.1 修复地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E6%A3%80%E6%9F%A5gadgets"><span class="toc-text">11.3 检查gadgets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89gadgets"><span class="toc-text">11.3.1 查看所有gadgets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E7%9C%9F%E6%AD%A3%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84gadgets"><span class="toc-text">11.3.2 真正查看所有的gadgets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-text">11.4 添加原始数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%AF%BC%E5%87%BAROP%E6%A0%88"><span class="toc-text">11.5 导出ROP栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E6%8F%90%E5%8F%96%E5%8E%9F%E5%A7%8B%E5%AD%97%E8%8A%82"><span class="toc-text">11.6 提取原始字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E7%A5%9E%E5%A5%87%E5%9C%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.7 神奇地调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%90%8D%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">11.8 使用函数名来调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9-%E5%A4%9A%E9%87%8DELF"><span class="toc-text">11.9 多重ELF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAshell"><span class="toc-text">11.10 获取一个shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-text">十二、日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%8A%9F%E8%83%BD"><span class="toc-text">12.1 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">12.2 命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E7%8E%AF%E5%A2%83"><span class="toc-text">12.3 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E7%AE%A1%E9%81%93"><span class="toc-text">12.4 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E8%8C%83%E5%9B%B4"><span class="toc-text">12.5 范围</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <p>转自:<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73644864/article/details/128376581">https://blog.csdn.net/m0_73644864/article/details/128376581</a></p>
<blockquote>
<p>学习<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B&spm=1001.2101.3001.7020">逆向工程</a>需要熟悉一个反汇编器的使用，学会阅读汇编语言，学会编写脚本和查找资料</p>
<p>IDA是功能很强大的一款<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E6%B1%87%E7%BC%96&spm=1001.2101.3001.7020">反汇编</a>机器，本文保姆级讲解了IDA的基本使用</p>
<p><img src="https://img-blog.csdnimg.cn/e6c53b96479a43de82c0af9e529476e3.jpeg"></p>
</blockquote>
<p><strong>目录</strong></p>
<p><a href="#t0">序言</a></p>
<p><a href="#t1">IDA Pro简介</a></p>
<p><a href="#t2">IDA的基本用法</a></p>
<p><a href="#t3">ida文件加载</a></p>
<p><a href="#t4">IDA桌面简介</a></p>
<p><a href="#t5">导航带</a></p>
<p><a href="#t6">反汇编窗口</a></p>
<p><a href="#t7">函数窗口</a></p>
<p><a href="#t8">十六进制窗口</a></p>
<p><a href="#t9">Hex view</a></p>
<p><a href="#t10">结构体窗口</a></p>
<p><a href="#t11">枚举窗口</a></p>
<p><a href="#t12">Strings窗口 </a></p>
<p><a href="#t13">Names窗口</a></p>
<p><a href="#t14">ACDU</a></p>
<p><a href="#t15">交叉引用</a></p>
<p><a href="#t16">概念</a></p>
<p><a href="#t17">代码交叉引用（函数调用，顺序执行和跳转）</a></p>
<p><a href="#t18">数据数据交叉引用</a></p>
<p><a href="#t19">访问交叉引用列表</a></p>
<p><a href="#t20">IDA静态分析</a></p>
<p><a href="#t21">名称</a></p>
<p><a href="#t22">修改参数，局部变量，函数名称</a></p>
<p><a href="#t23">修改地址的名称</a></p>
<p><a href="#t24">重命名寄存器</a></p>
<p><a href="#t25">IDA注释 </a></p>
<p><a href="#t26">函数操作</a></p>
<p><a href="#t27">新建函数</a></p>
<p><a href="#t28">删除函数</a></p>
<p><a href="#t29">代码和数据的相互转换 </a></p>
<p><a href="#t30">字符串</a></p>
<p><a href="#t31">指定数组</a></p>
<p><a href="#t32">显示汇编语言对应的机器码</a></p>
<p><a href="#t33">打补丁</a></p>
<p><a href="#t34">Patch</a></p>
<p><a href="#t35">修改exe文件并保存运行</a></p>
<p><a href="#t36">IDA脚本</a></p>
<p><a href="#t37">脚本的使用方式和IDC语法</a></p>
<p><a href="#t38">IDA插件</a></p>
<p><a href="#t39">概念</a></p>
<p><a href="#t40">构建插件</a></p>
<p><a href="#t41">安装插件</a></p>
<p><a href="#t42">插件配置</a></p>
<p><a href="#t43">IDAPython</a></p>
<p><a href="#t44">IDA动态调试</a></p>
<p><a href="#t45">调试器通常用于执行以下两种任务（大概了解）</a></p>
<p><a href="#t46">开始动态调试</a></p>
<p><a href="#t47">进程控制</a></p>
<p><a href="#t48">断点</a></p>
<p><a href="#t49">软件断点</a></p>
<p><a href="#t50">硬件断点</a></p>
<p><a href="#t51">跟踪</a></p>
<p><a href="#t52">寄存器变量</a></p>
<p><a href="#t53">监视</a></p>
<p><a href="#t54">IDA的拓展用法</a></p>
<p><a href="#t55">IDA的第三方图形</a></p>
<p><a href="#t56">外部流程图</a></p>
<p><a href="#t57">外部调用图</a></p>
<p><a href="#t58">外部交叉引用图</a></p>
<hr>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p><strong>It was the best of times,it was the worst of times,it was the age of wisdom,it was the age of foolishness,it was the epoch of belief,it was the epoch of incredulity.</strong></p>
<p><strong>it was the season of Light,it was the season of Darkness,it was the spring of hope,it was the winter of despair,we had everything before us,we had nothing before us.</strong></p>
<p><strong>we were all going direct to Heaven,we were all going direct the other way.</strong></p>
<p>**                                                                                                     ——<em>A Tale of Two Cities</em>**</p>
</blockquote>
<p>今天，万物互联，普适计算。整个世界的构造都由程序操纵起来。</p>
<p>A handful of people working at a handful of tech companies steer the thoughts of billions of people every day.</p>
<p>你可曾听过赛博朋克这个词，科幻作家布鲁斯·博斯克创造了这个词。</p>
<p>赛博朋克Cyberpunk是由网络Cyber和朋克Punk组成。</p>
<p>而cyber的词源是控制论cybernetics，是20世纪重要的思想运动。</p>
<p>punk则代表着治理与反叛两个概念的纠缠。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f4dc9e4f81c268f59add57aeb7e16548.jpeg"></p>
<p>科幻作家布鲁斯·博斯克创造了“赛博朋克”,并把该名设定为自己短篇小说的名字，形容迷失的年轻一代：他们是抗拒父母的权威、与主流社会格格不入、利用电脑技术钻漏洞和制造麻烦的技术宅。经典的赛博朋克角色是边缘且性格疏远的独行者。</p>
<p>赛博朋克深受科幻作者的喜爱，很成功的电影作品有《黑客帝国》。</p>
<p>赛博朋克类小说中的世界是反乌托邦式的，涉及日常生活受到急剧改变的科技影响，普及的计算机化信息笼罩全球，以及侵入性的人体改造。在赛博朋克的作品中，一边是闪烁着霓虹灯光的摩天大楼，富人们在此享受生活，但在阴暗的角落里，到处是黑帮、流氓、抢劫犯的身影，穷人们只能靠电子产品来麻痹自己。闪烁的霓虹灯和摩天大楼上五彩斑斓的大屏幕，让人联想到了《三体》中的超信息时代。</p>
<p>赛博朋克有时也专指这种视觉美学风格。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5cf94032a6a01c01dfa50256eac26f5e.png"></p>
<p>Hacker ，这个词是用来形容那些热衷于解决问题、克服限制的人。</p>
<p>他们是崇尚自由的，乐于追根究底、穷究问题的特质。</p>
<p>从广义上来说，任何职业都可以成为Hacker 。你可以是一个木匠黑客。不一定是高科技。只要与技能有关，并且倾心专注于你正在做的事情，你就可能成为黑客。</p>
<p>Hacker有别于Cracker，真正的Hacker遵守黑客守则，不破坏任何系统。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0cd6ba94670595b77bd4da7e04e00f1e.jpeg"></p>
<blockquote>
<p><strong>时代是朝前走的，发展不是情怀的敌人，相反，只有发展才会给情怀创造基础。</strong></p>
<p>**                                                                                ——人民日报**</p>
</blockquote>
<p>IDA是一个功能强大的反汇编器，学习逆向有别于按照一个框架去编写程序，需要灵活的头脑和痴迷于逆向分析的精神。你是在玩解密游戏而不是去建造一座大厦。</p>
<p>本文是将最核心的IDA的使用做了一个总结，删去了为了逻辑严密，内容全面的教科书式的讲解，只总结最和核心有用的实际操作，并且详细配置了图片，对于一些动态调试的具体内容，后续会有专门的博客，将链接贴在这篇文章中，希望大家在阅读完这篇文章之后就能上手使用IDA。</p>
<p>开始阅读核心部分吧</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b095e80418b3fde4b47aca392c730cf9.jpeg"></p>
<h1 id="IDA-Pro简介"><a href="#IDA-Pro简介" class="headerlink" title="IDA Pro简介"></a>IDA Pro简介</h1><p>IDA Pro就是一款递归下降反汇编器</p>
<p>反汇编器使用的算法包括：线性扫描反汇编算法、递归下降反汇编算法</p>
<p>IDA并非一款免费软件，为用户提供了一款功能有限的免费版本，不提供最新版本的功能</p>
<p>百度词条：</p>
<p>交互式反汇编器专业版（Interactive Disassembler Professional），人们常称其为IDA Pro，或简称为IDA。是最棒的一个静态反编译软件，为众多<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/0day/4885829?fromModule=lemma_inlink" title="0day">0day</a>世界的成员和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ShellCode?fromModule=lemma_inlink" title="ShellCode">ShellCode</a>安全分析人士不可缺少的利器！IDA Pro是一款交互式的，可编程的，可扩展的，多处理器的，交叉Windows或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Linux?fromModule=lemma_inlink" title="Linux">Linux</a> <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/WinCE?fromModule=lemma_inlink" title="WinCE">WinCE</a> <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MacOS?fromModule=lemma_inlink" title="MacOS">MacOS</a>平台主机来分析程序， 被公认为最好的花钱可以买到的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/5097433?fromModule=lemma_inlink" title="逆向工程">逆向工程</a>利器。IDA Pro已经成为事实上的分析敌意代码的标准并让其自身迅速成为攻击研究领域的重要工具。它支持数十种CPU指令集其中包括<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Intel%20x86?fromModule=lemma_inlink" title="Intel x86">Intel x86</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/x64/8161446?fromModule=lemma_inlink" title="x64">x64</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MIPS/2173143?fromModule=lemma_inlink" title="MIPS">MIPS</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/PowerPC?fromModule=lemma_inlink" title="PowerPC">PowerPC</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ARM/7518299?fromModule=lemma_inlink" title="ARM">ARM</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Z80?fromModule=lemma_inlink" title="Z80">Z80</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/68000/1255747?fromModule=lemma_inlink" title="68000">68000</a>，c8051等等。</p>
<h1 id="IDA的基本用法"><a href="#IDA的基本用法" class="headerlink" title="IDA的基本用法"></a>IDA的基本用法</h1><p>这一段介绍IDA最基本的界面信息和最基础的操作</p>
<h2 id="ida文件加载"><a href="#ida文件加载" class="headerlink" title="ida文件加载"></a>ida文件加载</h2><p>可以打开IDA-&gt;菜单栏file-&gt;open（选择一个二进制文件）</p>
<p>也可以将要分析的二进制文件拖到ida图标上</p>
<h2 id="IDA桌面简介"><a href="#IDA桌面简介" class="headerlink" title="IDA桌面简介"></a>IDA桌面简介</h2><p>你看过有关黑客的视频吗，一台性能很高的电脑上下着绿色的字符串雨，黑客盯紧屏幕检索其中的关键信息。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c6fa1a6bb820081793c9ad95a2aa231e.png"></p>
<p>当然这是有一定艺术化处理的，不一定都是绿色的界面。当然你可以根据自己的喜好配置成这样。但是有一点是肯定的，IDA的有关操作需要你查看很多界面，有很多不同的信息需要你整合分析。涉及栈，反汇编代码，反编译代码，程序中包含的字符串等等很多有关需要逆向分析的程序的信息。资深搞逆向工作可以考虑准备一台很大的显示屏。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f9dbf4b21e11457abd9fd1e484d78249.jpeg"></p>
<p>下面我们来认识一下IDA的这些窗口（View）。</p>
<h3 id="导航带"><a href="#导航带" class="headerlink" title="导航带"></a>导航带</h3><p><img src="https://img-blog.csdnimg.cn/250e9136c6604e9a8ef033b9be7ea4b0.png"></p>
<p> 概况导航栏，也叫作导航带，光标悬停在导航带任何位置会指出其在二进制文件中的位置</p>
<p>Options-color可以修改导航栏的颜色</p>
<h3 id="反汇编窗口"><a href="#反汇编窗口" class="headerlink" title="反汇编窗口"></a>反汇编窗口</h3><p><img src="https://img-blog.csdnimg.cn/8f3f7a0374e446e2a0e56659ff2ddbb1.png"></p>
<p>上图是图形视图，按空格键可以和文本视图相互切换，下图是文本视图</p>
<p><img src="https://img-blog.csdnimg.cn/99a991fef5714a16ba1da3651089b204.png"></p>
<p>.text:004028EE为区域名称加虚拟地址</p>
<p>图中.text是代码段</p>
<p> Ctrl+“+”可以或者Ctrl加鼠标滚轮实现界面的缩放</p>
<p>views-&gt;open subviews-&gt;Disassembly可以打开另一个反汇编窗口，每个反汇编窗口互相独立，可以一个查看图形，另一个查看文本</p>
<p><img src="https://img-blog.csdnimg.cn/5769c6b338d54c888be76f8b5ef7ac9f.png"></p>
<p> IDA使用不同的箭头颜色来表示不同的流</p>
<p>条件跳转Yes是绿色箭头，No是红色箭头，默认为蓝色箭头</p>
<p><img src="https://img-blog.csdnimg.cn/d1464ac58cb140a785f5c0823cab3cac.png"></p>
<p>文本窗口右边是箭头窗口</p>
<p>用于描述非线性流程 ，虚线是条件跳转，实线是非条件跳转</p>
<p>粗实线表示程序将控制权交给程序中的以前的某个地址，通常表示程序中存在循环</p>
<p><img src="https://img-blog.csdnimg.cn/9253b516d83f46f1a720d8179bf94ecf.png"></p>
<p>是反汇编形成的汇编语言代码</p>
<p><img src="https://img-blog.csdnimg.cn/08a2e0477b5141fa964ebf3c4fbe8294.png"></p>
<p>按下“；”可以添加注释，用于逆向分析时使用</p>
<p>图中  ; CODE XREF: _main+209↑j是自动生成的表示此处有交叉引用的注释</p>
<p>_main+209↑j表示一个地址，形式是函数+偏移量，↑表示该地址在上面</p>
<p>交叉引用暂不做介绍</p>
<p>图形视图可以用鼠标滚轮加Ctrl进行拖动，进行缩放</p>
<p><img src="https://img-blog.csdnimg.cn/8c64a65a6abe49858df9e5508d350e42.png"></p>
<p>有时我们需要用缩小的抽象图片来观察程序执行流程的一些特点 </p>
<h3 id="函数窗口"><a href="#函数窗口" class="headerlink" title="函数窗口"></a>函数窗口</h3><p><img src="https://img-blog.csdnimg.cn/f881e8ae1c3542f784c7efe273afddd3.png"></p>
<p>为 IDA在数据库中识别的每一个函数，双击一个函数，会跳转到反汇编窗口这个函数所在的位置</p>
<h3 id="十六进制窗口"><a href="#十六进制窗口" class="headerlink" title="十六进制窗口"></a>十六进制窗口</h3><h3 id="Hex-view"><a href="#Hex-view" class="headerlink" title="Hex view"></a>Hex view</h3><p><img src="https://img-blog.csdnimg.cn/b324701f0c3743a8beb7132f320142dd.png"></p>
<p> 显示的是程序内容和列表的标准十六进制代码</p>
<p>每行十六个字节</p>
<p>还会显示对应的ASCII字符（！！！所以有时string窗口显示的字符串不好查看时，可以打开Hex view查看）</p>
<p>右键-&gt;Sychronize with可以选择时是否与某个反汇编窗口相互关联，关联后，两个窗口会同时改变位置</p>
<h3 id="结构体窗口"><a href="#结构体窗口" class="headerlink" title="结构体窗口"></a>结构体窗口</h3><p><img src="https://img-blog.csdnimg.cn/59867bcaab154656aaba47aa9cab99e9.png"></p>
<p>显示二进制文件中使用的任何复杂的数据结构（C结构体和联合）</p>
<p>使用：</p>
<p>为标准数据结构的布局提供现成的参考</p>
<p>为你提供一种方法，发现程序使用的自定义数据结构时，帮助你创建自己的，可用作内存布局的数据结构</p>
<h3 id="枚举窗口"><a href="#枚举窗口" class="headerlink" title="枚举窗口"></a>枚举窗口</h3><p><img src="https://img-blog.csdnimg.cn/fd98607840d94153907c0d3dfc3524d4.png"></p>
<p>显示检测到的标准枚举数据类型（C enum)</p>
<p>可以自定义枚举类型</p>
<h3 id="Strings窗口"><a href="#Strings窗口" class="headerlink" title="Strings窗口"></a>Strings窗口</h3><p>views-&gt;open subviews-&gt;Strings打开窗口</p>
<p>显示的是从二进制文件中提取出来的一组字符串，以及字符串所在的地址</p>
<p><img src="https://img-blog.csdnimg.cn/42f442e268e84ae0aed090a24d174a31.png"></p>
<p>从中可以查找程序中使用的字符串（有时也可以用Hex view查勘字符串，但是一般在string窗口中检索想要的关键字符串）</p>
<p>与交叉引用相结合可以快速定位字符串，跟踪到程序中引用这个字符串的位置</p>
<h3 id="Names窗口"><a href="#Names窗口" class="headerlink" title="Names窗口"></a>Names窗口</h3><p><img src="https://img-blog.csdnimg.cn/65046984e569482f97f56ad9d654bc31.png"></p>
<p> 显示全局名称</p>
<p>名称是指对一个程序虚拟地址的符号引用</p>
<p>F常规函数</p>
<p>L库函数</p>
<p>I导入的名称</p>
<p>C命名代码</p>
<p>D数据</p>
<p>A字符串数据</p>
<h2 id="ACDU"><a href="#ACDU" class="headerlink" title="ACDU"></a>ACDU</h2><p>反汇编的代码并不是完美的，需要手动进行调试</p>
<p>ACDU可以将一段数据类型转化成代码（C)，数据（D)，未定义的二进制数据（U)，字符（A)</p>
<p>例如：</p>
<p><img src="https://img-blog.csdnimg.cn/02a564ca09a94986a59c836afbbb7ca4.png"></p>
<p> 选择一段数据，按下A</p>
<p><img src="https://img-blog.csdnimg.cn/5042c012424a4123b0768a55b236ec14.png"></p>
<h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>文件中存储的一些数据，我们知道计算机是存储程序式结构，代码部分会对数据进行操作，使用IDA的交叉引用可以查看对于一个地址处的数据被哪些地方的代码进行了引用</p>
<p>我们就可以根据一个数据进行跟踪</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>交叉引用是一个地址引用一个地址</p>
<p>根据图论的知识，可以把地址看成节点，把交叉引用看成边</p>
<p>分为代码交叉引用和数据交叉引用</p>
<h3 id="代码交叉引用（函数调用，顺序执行和跳转）"><a href="#代码交叉引用（函数调用，顺序执行和跳转）" class="headerlink" title="代码交叉引用（函数调用，顺序执行和跳转）"></a>代码交叉引用（函数调用，顺序执行和跳转）</h3><p>三种基本的流</p>
<p>普通流，跳转流，调用流</p>
<p>普通流：就是顺序执行，默认执行流，执行紧跟在后面的指令</p>
<p>跳转流：无条件分支和条件分支分配到一跳转流，注释中出现j后缀</p>
<p>调用流：调用一个函数使用调用流，使用后缀p</p>
<h3 id="数据数据交叉引用"><a href="#数据数据交叉引用" class="headerlink" title="数据数据交叉引用"></a>数据数据交叉引用</h3><p>读取交叉引用：访问某个内存位置</p>
<p>写入交叉引用：写入内内存</p>
<p>偏移量交叉引用：引用某个位置的地址</p>
<h3 id="访问交叉引用列表"><a href="#访问交叉引用列表" class="headerlink" title="访问交叉引用列表"></a>访问交叉引用列表</h3><p>将光标放在指定位置</p>
<p>指定位置Ctrl+X</p>
<p>指定位置Views-&gt;Open Subviews-&gt;Cross—References</p>
<p><img src="https://img-blog.csdnimg.cn/9cce1ed51a084869950cd80e81d20a65.png"></p>
<p> 双击一个位置就可以跳转到这个位置</p>
<h1 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h1><p>静态分析，就是根据反汇编器生成的结果，在不运行这个程序的情况下，逆向分析这个程序的运行过程。</p>
<p>当然反汇编器是机械的根据算法来生成反汇编代码，而逆向和防止逆向是相互竞争的，为了防止逆向，机器代码掺杂了脏字节之类的东西，导致反汇编算法不能正确分析，这是也需要我们手动来调整。而且反汇编生成的代码的变量没有任何实际意义，当我们分析清楚其功能的时候，可以重命名。也可以加注释辅助逆向分析。</p>
<p><img src="https://img-blog.csdnimg.cn/8337a294b47549a98dee9e29d8dfc02f.jpeg"></p>
<h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>IDA会自动生成生成与虚拟地址和与栈帧变量有关的名称，这些名称不能帮助我们认识位置和变量的用途，称为哑名</p>
<p>IDA可以修改名称</p>
<h3 id="修改参数，局部变量，函数名称"><a href="#修改参数，局部变量，函数名称" class="headerlink" title="修改参数，局部变量，函数名称"></a>修改参数，局部变量，函数名称</h3><p>按快捷键N可以将光标位置的变量，函数重命名，输入一个空名称IDA会生成默认名称</p>
<p><img src="https://img-blog.csdnimg.cn/85e03ba5bded4c7ba1d362001d68ebea.png"></p>
<h3 id="修改地址的名称"><a href="#修改地址的名称" class="headerlink" title="修改地址的名称"></a>修改地址的名称</h3><p>按快捷键N将光标位置的地址重命名</p>
<p><img src="https://img-blog.csdnimg.cn/08db388a2aef44d9a6f225c80decef52.png"></p>
<h3 id="重命名寄存器"><a href="#重命名寄存器" class="headerlink" title="重命名寄存器"></a>重命名寄存器</h3><p>按快捷键N将光标位置的寄存器重命名</p>
<p><img src="https://img-blog.csdnimg.cn/b3dffdfa41194ac985d9f5c986a54e1a.png"></p>
<p>当编译器将变量分配在寄存器中，而不是程序栈上时</p>
<p>为了更好地引用这个变量，需要重命名寄存器</p>
<h2 id="IDA注释"><a href="#IDA注释" class="headerlink" title="IDA注释 "></a>IDA注释 </h2><p>使用“：”，或者“；”快捷键</p>
<h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><h3 id="新建函数"><a href="#新建函数" class="headerlink" title="新建函数"></a>新建函数</h3><p><img src="https://img-blog.csdnimg.cn/e3115472ae8f41659c0c1c24411e00a8.png"></p>
<p>添加一个手动分析，IDA没有分析出来的函数</p>
<h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><p><img src="https://img-blog.csdnimg.cn/20d4fb5909f34cb88e36a3173c4a8abe.png"></p>
<p>删除一个认为IDA分析错误的函数</p>
<h2 id="代码和数据的相互转换"><a href="#代码和数据的相互转换" class="headerlink" title="代码和数据的相互转换 "></a>代码和数据的相互转换 </h2><p>使用快捷键ACDU</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>IDA能是识别大量的字符串格式，默认会搜索并格式化成C风格</p>
<p>可以切换字符串格式</p>
<p><img src="https://img-blog.csdnimg.cn/37c83fb1563444969fca073537c4dd90.png"></p>
<h2 id="指定数组"><a href="#指定数组" class="headerlink" title="指定数组"></a>指定数组</h2><p>IDA生成的反汇编代码很少提供数组大小的信息</p>
<p>只有数组第一个元素被引用</p>
<p>要生成一个便于分析的数组需要手动创建</p>
<p>选择数组第一个元素，菜单栏选择Edit-&gt;Array</p>
<p><img src="https://img-blog.csdnimg.cn/e7abea6f0dad4f8e9278431feb01a044.png"></p>
<p>创建数组的时候，确保将数组中的第一个元素的大小更改为适当的值，从而为数组的元素选择适当的大小 </p>
<h2 id="显示汇编语言对应的机器码"><a href="#显示汇编语言对应的机器码" class="headerlink" title="显示汇编语言对应的机器码"></a>显示汇编语言对应的机器码</h2><p><img src="https://img-blog.csdnimg.cn/952ca29cd08848e1910be12f55c67be5.png"></p>
<p>选中这部分汇编代码</p>
<p><img src="https://img-blog.csdnimg.cn/b5c78a7c306842dcb28fd36a61b65737.png"></p>
<p><img src="https://img-blog.csdnimg.cn/4ae8842d252e45e597f83ee260dc0cb8.png"></p>
<p> 将Number of opcode bytes改为10，OK</p>
<p> <img src="https://img-blog.csdnimg.cn/5fdc1c5bd4164d27a324197a97f7c34d.png"></p>
<h1 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h1><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>Patch就是打补丁，什么是打补丁，就是修改汇编代码</p>
<p>选中汇编代码</p>
<p><img src="https://img-blog.csdnimg.cn/22dca596fdfe4e3cbe848183e13dc5ec.png"></p>
<p>Chang bytes可以修改汇编语言对应的机器码</p>
<p><img src="https://img-blog.csdnimg.cn/18e8f294983840b1a46c7a72cb96d23a.png"></p>
<p>Assemble instruction可以修改汇编指令</p>
<p><img src="https://img-blog.csdnimg.cn/a98d45452248425aa259ed70de90922c.png"></p>
<h2 id="修改exe文件并保存运行"><a href="#修改exe文件并保存运行" class="headerlink" title="修改exe文件并保存运行"></a>修改exe文件并保存运行</h2><p>按照上述操作进行修改之后，我们修改的信息存在了数据库中</p>
<p><img src="https://img-blog.csdnimg.cn/e28bd31e1ffa4dc39c8600105f318e6c.png"></p>
<p>exe文件是不会修改的，若我们想得到修改后的一个exe文件 ，进行下面的操作</p>
<p><img src="https://img-blog.csdnimg.cn/650ec1eee7344e5296417e0973109322.png"></p>
<p><img src="https://img-blog.csdnimg.cn/185c28c668b448a58a3455dfd76fc6c9.png"></p>
<h1 id="IDA脚本"><a href="#IDA脚本" class="headerlink" title="IDA脚本"></a>IDA脚本</h1><p>脚本可以帮助我们完成很多重复的工作，IDA的脚本是针对IDA的工作的脚本。</p>
<p>脚本语言又被称为扩建的语言, 或者动态语言, 是一种编程语言, 用来控制软件应用程序。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4b3e1070e1bb5fb24f28034fab4f07ad.jpeg"></p>
<h2 id="脚本的使用方式和IDC语法"><a href="#脚本的使用方式和IDC语法" class="headerlink" title="脚本的使用方式和IDC语法"></a>脚本的使用方式和IDC语法</h2><p>脚本是什么</p>
<p>英文是Script，就是脚本，剧本的意思</p>
<p>就是我们可以将一些IDA的操作写在一个程序里面，让这个脚本程序运行这些操作，按照你定义的剧本让这个IDA运转</p>
<p>比如批量修改内存中的数据，批量打印内存中数据等等都需要脚本，人工一个一个修改或提取很麻烦</p>
<p>当对IDA的最基本操作有了解之后，我们可以尝试编写脚本来方便我们的工作</p>
<p><strong>速成IDC语法看下面这一篇</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73644864/article/details/129602307?spm=1001.2014.3001.5502" title="IDC语法">IDC语法</a></p>
<p><strong>了解更多看这一篇</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73644864/article/details/128380628" title="IDA脚本">IDA脚本</a></p>
<h1 id="IDA插件"><a href="#IDA插件" class="headerlink" title="IDA插件"></a>IDA插件</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/e7fe0fc1e6bfb0498c0436d2925a5459.jpeg"></p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>IDA插件是经过编译的，功能更加强大的IDC脚本</p>
<p>通常和热键，菜单关联</p>
<p>插件可能是通用的</p>
<p>处理各种二进制文件或者提供各种处理器体系结构使用</p>
<h2 id="构建插件"><a href="#构建插件" class="headerlink" title="构建插件"></a>构建插件</h2><p>插件在Windows上是有效的DLL文件，扩展名为.plx,.pmc,.plx64,lmc64</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>将编译好的插件模块复制到<IDADIR>plugins目录当中</p>
<p><img src="https://img-blog.csdnimg.cn/a688fe913cca4a288ed0a9c94f612932.png"></p>
<p>Windows不能覆写一个正在使用的可执行文件，安装一个插件必须确保IDA卸载了旧版本的插件</p>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>配置插件通过<IDADIR>/plugins/plugins.cfg文件中的设置 </p>
<p><img src="https://img-blog.csdnimg.cn/62c37388e7a84d44939a698859d06dde.png"></p>
<p>存有插件的如下信息</p>
<ul>
<li>  插件的一个备选菜单说明，这个值重写插件的want_name数据成员</li>
<li>  插件的一个非标准存储位置或文件扩展名。默认情况下，IDA在<IDADIR>/plugins下搜索插件，期待插件拥有一个默认的，特定于平台的文件扩展名</li>
<li>  插件的热键</li>
<li>  供调试器可选DEBUG标志</li>
</ul>
<h2 id="IDAPython"><a href="#IDAPython" class="headerlink" title="IDAPython"></a>IDAPython</h2><p>IDAPython最初由Gergely Erdelyi和Ero Carrera在2004年合作开发，目的是取代IDA自带的idc脚本引擎，提供更强大的扩展能力和自动化分析能力。</p>
<p>受到IDA用户的普遍欢迎。是一个开源项目，可以下载该插件。对其进行修改。</p>
<p><a target="_blank" rel="noopener" href="https://code.google.com/archive/p/idapython/" title="IDAPython信息">IDAPython信息</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/idapython/src/" title="存放IDAPython的github网址">存放IDAPython的github网址</a></p>
<h1 id="IDA动态调试"><a href="#IDA动态调试" class="headerlink" title="IDA动态调试"></a>IDA动态调试</h1><p>有时候程序在运行过程中会生成一些关键的数值，而人力通过静态分析的结果模拟程序的运行来推出这些中间的数值可能很麻烦。简单重复的工作是计算机所擅长的而不是人，所以我们可以让这个程序运行起来，得到这些中间过程的数值。这就是动态调试。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2186472ae16640ffe7750fa781ddc43b.jpeg"></p>
<h2 id="调试器通常用于执行以下两种任务（大概了解）"><a href="#调试器通常用于执行以下两种任务（大概了解）" class="headerlink" title="调试器通常用于执行以下两种任务（大概了解）"></a>调试器通常用于执行以下两种任务（大概了解）</h2><p>分析与已崩溃进程有关的内存映像，以一种完全受控的方式执行进程</p>
<p>调试会话以一个接受调试的进程为起点</p>
<p>大多数调试器能够依附在一个正在进行的进程上</p>
<p>选择一个进程之后，调试器将捕获该进程的内存快照，以此创建一个临时数据库。除这个正在运行进程的内存映像之外，临时数据库中还包含该进程加载的所有共享库，这使得这个数据库比我们常见的数据库要复杂得多</p>
<h2 id="开始动态调试"><a href="#开始动态调试" class="headerlink" title="开始动态调试"></a>开始动态调试</h2><p>1.Debugger-&gt;Select Debugger    或按快捷键F9</p>
<p>使用EXE文件可以使用Local Windows Debugger</p>
<p>如果是ELF文件应该放在Linux上用远程调试<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73644864/article/details/128683402?spm=1001.2014.3001.5502" title="IDA动态调试ELF文件_光无影的博客-CSDN博客">IDA动态调试ELF文件_光无影的博客-CSDN博客</a></p>
<p>2.Debuugger-&gt;Start Process 或者F9开始调试</p>
<p>3.IDA将显示警告信息</p>
<p><img src="https://img-blog.csdnimg.cn/d1e01cfd5cdd4751854c5ba229d56e7f.png"></p>
<p> 选择Yes,选择No会退出</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>调试器的功能是能严密监控并修改它所调试的进程的行为</p>
<p>所以有一些调试的命令</p>
<p><img src="https://img-blog.csdnimg.cn/c39db0f349034db993d458f0193aa704.png"></p>
<p>Continue 继续执行一个暂停的进程。执行将继续，直到遇到一个断点暂停 F9</p>
<p>Pause 暂停一个正在运行的进程  使用工具栏按钮</p>
<p>Terminate  终止一个正在运行的进程 </p>
<p>Step into 执行下一条指令，如果下一条是函数调用，就进入函数第一条 F7</p>
<p>Step over 执行下一条指令 如果下一条是一个函数调用，会跨过 F8</p>
<p>Run Until Return 执行当前函数到返回 Ctrl+F7</p>
<p>Run to  Cursor 执行进程，直到执行到达当前的光标位置 F9</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>调试时候执行到设置断点的位置会中断</p>
<p>指定位置F2快捷键设置断点</p>
<p><img src="https://img-blog.csdnimg.cn/6511a644e9be496783603b524af326b0.png"></p>
<p> 断点处红色显示</p>
<p>IDA调试器支持硬件断点和条件断点</p>
<h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p><img src="https://img-blog.csdnimg.cn/0a82b67b963b48caac04e14474f01f51.png"></p>
<p>在一个选定的断点处右击</p>
<p><img src="https://img-blog.csdnimg.cn/4f67cc320e0843b98376ed157dc359b0.png"></p>
<p>选Hareware，按照需求选择读写或者执行断点，一般打在数据区域</p>
<p><img src="https://img-blog.csdnimg.cn/44d992ad434e4144a103eac2e894e8a9.png"></p>
<h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>Debugger-&gt;Tracing-&gt;Tracing Options</p>
<p><img src="https://img-blog.csdnimg.cn/b84f4021687c4a3ca4a059a5fa6827e1.png"></p>
<p><img src="https://img-blog.csdnimg.cn/8edd0bcfccff40568c191a873d4eb84a.png"></p>
<h2 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h2><p>提供了一些特殊的寄存器，用于直接访问断点表达式中寄存器的内容</p>
<p>只有在调试器激活的时候才能使用寄存器变量</p>
<h2 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h2><p>可以持续监视一个或几个变量的值，不需要每次进程暂停后导航到相关内存的位置</p>
<p>显示监视列表</p>
<p><img src="https://img-blog.csdnimg.cn/aa96d675deb1464ca9338141886d8939.png"></p>
<h1 id="IDA的拓展用法"><a href="#IDA的拓展用法" class="headerlink" title="IDA的拓展用法"></a>IDA的拓展用法</h1><h2 id="IDA的第三方图形"><a href="#IDA的第三方图形" class="headerlink" title="IDA的第三方图形"></a>IDA的第三方图形</h2><h3 id="外部流程图"><a href="#外部流程图" class="headerlink" title="外部流程图"></a>外部流程图</h3><p>Views-&gt;Graphs-&gt;Flow Chart</p>
<h3 id="外部调用图"><a href="#外部调用图" class="headerlink" title="外部调用图"></a>外部调用图</h3><p>Views-&gt;Graphs-&gt;Function Calls</p>
<p>显示函数调用的层次结构</p>
<h3 id="外部交叉引用图"><a href="#外部交叉引用图" class="headerlink" title="外部交叉引用图"></a>外部交叉引用图</h3><p>Views-&gt;Graphs-&gt;Xrefs From</p>
<blockquote>
<p>Now, you can try to do some really interesting things with IDA.</p>
<p>Come!</p>
<p>Let’s act.</p>
<p><img src="https://img-blog.csdnimg.cn/85bfc453015d4e27971a0c1c1fe8709a.jpeg"></p>
</blockquote>
<ul>
<li>  Author：ZERO-A-ONE</li>
<li>  Date：2022-02-24</li>
</ul>
<blockquote>
<p>本文翻译自：<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/[pwntools](https://so.csdn.net/so/search?q=pwntools&amp;spm=1001.2101.3001.7020)-tutorial%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E8%80%83%E8%99%91%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%AD%E6%96%87%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8Dpwntools%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E6%96%87%E7%AB%A0%E9%83%BD%E6%AF%94%E8%BE%83%E8%80%81%E5%92%8C%E6%9D%82%E4%B9%B1%EF%BC%8C%E4%B8%94%E8%BD%AC%E6%8D%A2%E4%B8%BAPython3%E5%90%8E%E5%8F%88%E6%9C%89%E8%AE%B8%E5%A4%9A%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E5%BE%88%E5%A4%9A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%84%9F%E5%88%B0%E5%8F%AF%E4%BB%A5%E7%BF%BB%E8%AF%91%E4%B8%80%E4%B8%8B">https://github.com/Gallopsled/[pwntools](https://so.csdn.net/so/search?q=pwntools&amp;spm=1001.2101.3001.7020)-tutorial，主要是考虑到目前中文互联网中关于系统介绍pwntools使用方法的文章都比较老和杂乱，且转换为Python3后又有许多零零散散的问题，看到这个仓库中包含了很多使用技巧和调试问题的解决方案，感到可以翻译一下</a></p>
</blockquote>
<p>这个资源库包含了一些开始使用pwntools（和pwntools）的基本教程。</p>
<p>这些教程并不致力于解释<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B&spm=1001.2101.3001.7020">逆向工程</a>或利用，而是假定读者有这方面的知识。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>Pwntools</code>是一个工具包，使选手们在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CTF&spm=1001.2101.3001.7020">CTF</a>期间的尽可能容易的编写EXP，并使EXP尽可能的容易阅读。</p>
<p>有些代码每个人都写过无数次，而且每个人都有自己的方法。Pwntools的目标是以半标准的方式提供所有这些，这样你就可以停止复制粘贴相同的<code>struct.unpack(&#39;&gt;I&#39;, x)</code>代码，而是使用更多稍微清晰的包装器，如<code>pac</code>k或<code>p32</code>甚至<code>p64(..., endian=&#39;big&#39;, sign=True)</code>。</p>
<p>除了对日常的功能进行方便的包装外，它还提供了一套非常丰富的IO管道，将所有你曾经执行过的IO封装在一个统一的界面中。从本地攻击切换到远程攻击，或者通过SSH进行本地攻击，都只是修改一行代码的工作。</p>
<p>最后但并非最不重要的是，它还包括一系列用于中级到高级使用情况的开发协助工具。这些工具包括给定内存泄露基元的远程符号解析（<code>MemLeak</code>和<code>DynELF</code>），ELF解析和修补（<code>ELF</code>），以及ROP小工具发现和调用链构建（<code>ROP</code>）。</p>
<h2 id="二、目录"><a href="#二、目录" class="headerlink" title="二、目录"></a>二、目录</h2><ul>
<li>Installing Pwntools</li>
<li>Tubes<ul>
<li>  Basic Tubes</li>
<li>  Interactive Shells</li>
<li>  Processes</li>
<li>  Networking</li>
<li>  Secure Shell</li>
<li>  Serial Ports</li>
</ul>
</li>
<li>Utility<ul>
<li>  Encoding and Hashing</li>
<li>  Packing / unpacking integers</li>
<li>  Pattern generation</li>
<li>  Safe evaluation</li>
</ul>
</li>
<li>Bytes vs. Strings<ul>
<li>Python2</li>
<li>Python3<ul>
<li>  Gotchas</li>
</ul>
</li>
</ul>
</li>
<li>Context<ul>
<li>  Architecture</li>
<li>  Endianness</li>
<li>  Log verbosity</li>
<li>  Timeout</li>
</ul>
</li>
<li>ELFs<ul>
<li>  Reading and writing</li>
<li>  Patching</li>
<li>  Symbols</li>
</ul>
</li>
<li>Assembly<ul>
<li>  Assembling shellcode</li>
<li>  Disassembling bytes</li>
<li>  Shellcraft library</li>
<li>  Constants</li>
</ul>
</li>
<li>Debugging<ul>
<li>  Debugging local processes</li>
<li>  Breaking at the entry point</li>
<li>  Debugging shellcode</li>
</ul>
</li>
<li>ROP<ul>
<li>  Dumping gadgets</li>
<li>  Searching for gadgets</li>
<li>  ROP stack generation</li>
<li>  Helper functions</li>
</ul>
</li>
<li>Logging<ul>
<li>  Basic logging</li>
<li>  Log verbosity</li>
<li>  Progress spinners</li>
</ul>
</li>
<li>Leaking Remote Memory<ul>
<li>  Declaring a leak function</li>
<li>  Leaking arbitrary memory</li>
<li>  Remote symbol resolution</li>
</ul>
</li>
</ul>
<h2 id="三、安装Pwntools"><a href="#三、安装Pwntools" class="headerlink" title="三、安装Pwntools"></a>三、安装Pwntools</h2><p>这个过程可以说是简单明了，Ubuntu 18.04和20.04是唯一 “官方支持 “的平台，因为它们是官方对软件进行自动化测试的唯二平台。</p>
<pre><code>$ apt-get update
$ apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
$ python3 -m pip install --upgrade pip
$ python3 -m pip install --upgrade pwntools
</code></pre>
<h3 id="3-1-验证安装"><a href="#3-1-验证安装" class="headerlink" title="3.1 验证安装"></a>3.1 验证安装</h3><p>如果以下命令成功，一切都应该是OK的</p>
<pre><code>$ python -c &#39;from pwn import *&#39;
</code></pre>
<h3 id="3-2-其它架构"><a href="#3-2-其它架构" class="headerlink" title="3.2 其它架构"></a>3.2 其它架构</h3><p>如果你想为其它的架构组装或反汇编代码，你需要安装一个合适的<code>binutils</code>。对于Ubuntu和Mac OS X用户，安装说明可在<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/install/binutils.html">docs.pwntools.com</a>上找到。</p>
<pre><code>$ apt-get install binutils-*
</code></pre>
<h2 id="四、管道"><a href="#四、管道" class="headerlink" title="四、管道"></a>四、管道</h2><p>管道是方便高校的I/O包装器，里面包含了你需要执行的大多数类型的I/O。</p>
<ul>
<li>  Local processes</li>
<li>  Remote TCP or UDP connections</li>
<li>  Processes running on a remote server over SSH</li>
<li>  Serial port I/O</li>
</ul>
<p>本介绍提供了一些所提供功能的例子，但更复杂的组合是可能的。关于如何进行正则表达式匹配，以及将管道连接在一起的更多信息，请参阅完整的<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/tubes.html">文档</a>。</p>
<h3 id="4-1-基础IO"><a href="#4-1-基础IO" class="headerlink" title="4.1 基础IO"></a>4.1 基础IO</h3><p>下面介绍一些IO中的基本功能：</p>
<p><strong>接收数据</strong></p>
<ul>
<li>  <code>recv(n)</code> - 接收任何数量的可用字节</li>
<li>  <code>recvline()</code> - 接收数据，直到遇到换行</li>
<li>  <code>recvuntil(delim)</code> - 接收数据，直到找到一个分隔符</li>
<li>  <code>recvregex(pattern)</code> - 接收数据，直到满足一个与pattern重合的内容为止</li>
<li>  <code>recvrepeat(timeout)</code> - 继续接收数据，直到发生超时</li>
<li>  <code>clean()</code> - 丢弃所有缓冲的数据</li>
</ul>
<p><strong>发送数据</strong></p>
<ul>
<li>  <code>send(data)</code> - 发送数据</li>
<li>  <code>sendline(line)</code> - 发送数据加一个换行</li>
</ul>
<p><strong>操作整数</strong></p>
<ul>
<li>  <code>pack(int)</code> - 打包发送一个字（word）大小的整数</li>
<li>  <code>unpack()</code> - 接收并解包一个字（word）大小的整数</li>
</ul>
<h3 id="4-2-进程和基本功能"><a href="#4-2-进程和基本功能" class="headerlink" title="4.2 进程和基本功能"></a>4.2 进程和基本功能</h3><p>为了创建一个与进程对话的管道，你只需创建一个进程对象并给它一个目标二进制的名字。</p>
<pre><code>from pwn import *

io = process(&#39;sh&#39;)
io.sendline(&#39;echo Hello, world&#39;)
io.recvline()
# &#39;Hello, world\n&#39;
</code></pre>
<p>如果你需要提供命令行参数，或设置环境，可以使用额外的选项。更多信息请参见完整的<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/tubes/processes.html">文档</a>。</p>
<pre><code>from pwn import *

io = process([&#39;sh&#39;, &#39;-c&#39;, &#39;echo $MYENV&#39;], env=&#123;&#39;MYENV&#39;: &#39;MYVAL&#39;&#125;)
io.recvline()
# &#39;MYVAL\n&#39;
</code></pre>
<p>读取二进制数据也不是一个问题。你可以用<code>recv</code>接收多达若干字节的数据，或者用<code>recvn</code>接受精确的字节数。</p>
<pre><code>from pwn import *

io = process([&#39;sh&#39;, &#39;-c&#39;, &#39;echo A; sleep 1; echo B; sleep 1; echo C; sleep 1; echo DDD&#39;])

io.recv()
# &#39;A\n&#39;

io.recvn(4)
# &#39;B\nC\n&#39;

hex(io.unpack())
# 0xa444444
</code></pre>
<h3 id="4-3-会话互动"><a href="#4-3-会话互动" class="headerlink" title="4.3 会话互动"></a>4.3 会话互动</h3><p>你在游戏服务器中获取了一个shell吗？赶快！互动地使用它是很容易的。</p>
<pre><code>from pwn import *

# Let&#39;s pretend we&#39;re uber 1337 and landed a shell.
io = process(&#39;sh&#39;)

# &lt;exploit goes here&gt;

io.interactive()
</code></pre>
<h3 id="4-4-网络"><a href="#4-4-网络" class="headerlink" title="4.4 网络"></a>4.4 网络</h3><p>创建一个网络连接也很容易，而且有完全相同的接口。一个<code>remote</code>对象连接到其他地方，而一个<code>listen</code>对象则在等待连接。</p>
<pre><code>from pwn import *

io = remote(&#39;google.com&#39;, 80)
io.send(&#39;GET /\r\n\r\n&#39;)
io.recvline()
# &#39;HTTP/1.0 200 OK\r\n&#39;
</code></pre>
<p>如果你需要指定协议信息，也是很直接方便的。</p>
<pre><code>from pwn import *

dns  = remote(&#39;8.8.8.8&#39;, 53, typ=&#39;udp&#39;)
tcp6 = remote(&#39;google.com&#39;, 80, fam=&#39;ipv6&#39;)
</code></pre>
<p>侦听连接并没有多复杂。请注意，这正好是在监听一个连接，然后停止监听。</p>
<pre><code>from pwn import *

client = listen(8080).wait_for_connection()
</code></pre>
<h3 id="4-5-安全的Shell"><a href="#4-5-安全的Shell" class="headerlink" title="4.5 安全的Shell"></a>4.5 安全的Shell</h3><p>SSH连接也同样简单。可以将下面的代码与上面 “Hello Process “中的代码进行比较。</p>
<p>你还可以用SSH做更复杂的事情，如端口转发和文件上传/下载。更多信息请参见<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/ssh.md">SSH</a>教程。</p>
<pre><code>from pwn import *

session = ssh(&#39;bandit0&#39;, &#39;bandit.labs.overthewire.org&#39;, password=&#39;bandit0&#39;)

io = session.process(&#39;sh&#39;, env=&#123;&quot;PS1&quot;:&quot;&quot;&#125;)
io.sendline(&#39;echo Hello, world!&#39;)
io.recvline()
# &#39;Hello, world!\n&#39;
</code></pre>
<h3 id="4-6-串行端口"><a href="#4-6-串行端口" class="headerlink" title="4.6 串行端口"></a>4.6 串行端口</h3><p>如果你需要在本地进行一些黑客攻击，也有一个串行管道。一如既往，在完整的<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/tubes/serial.html">在线文档</a>中有更多信息。</p>
<pre><code>from pwn import *

io = serialtube(&#39;/dev/ttyUSB0&#39;, baudrate=115200)
</code></pre>
<h2 id="五、实用功能"><a href="#五、实用功能" class="headerlink" title="五、实用功能"></a>五、实用功能</h2><p>Pwntools大约有一半的内容是实用功能，这样你就不再需要到处复制粘贴这样的东西。</p>
<pre><code>import struct

def p(x):
    return struct.pack(&#39;I&#39;, x)
def u(x):
    return struct.unpack(&#39;I&#39;, x)[0]

1234 == u(p(1234))
</code></pre>
<p>此外，你不仅得到了漂亮的小包装，作为额外的奖励，在阅读别人的漏洞代码时，一切都更清晰，更容易理解。</p>
<pre><code>from pwn import *

1234 == unpack(pack(1234))
</code></pre>
<h3 id="5-1-打包和解包整数"><a href="#5-1-打包和解包整数" class="headerlink" title="5.1 打包和解包整数"></a>5.1 打包和解包整数</h3><p>这可能是你最常做的事情，所以它在最前面。主要的<code>pack</code>和<code>unpack</code>函数都知道<code>context</code>中的全局设置，如<code>endian</code>、<code>bits</code>和<code>sign</code>。</p>
<p>你也可以在函数调用中明确指定它们。</p>
<pre><code>pack(1)
# &#39;\x01\x00\x00\x00&#39;

pack(-1)
# &#39;\xff\xff\xff\xff&#39;

pack(2**32 - 1)
# &#39;\xff\xff\xff\xff&#39;

pack(1, endian=&#39;big&#39;)
# &#39;\x00\x00\x00\x01&#39;

p16(1)
# &#39;\x01\x00&#39;

hex(unpack(&#39;AAAA&#39;))
# &#39;0x41414141&#39;

hex(u16(&#39;AA&#39;))
# &#39;0x4141&#39;
</code></pre>
<h3 id="5-2-文件I-O"><a href="#5-2-文件I-O" class="headerlink" title="5.2 文件I/O"></a>5.2 文件I/O</h3><p>只需调用一个函数，它就能做你想做的事。</p>
<pre><code>from pwn import *

write(&#39;filename&#39;, &#39;data&#39;)
read(&#39;filename&#39;)
# &#39;data&#39;
read(&#39;filename&#39;, 1)
# &#39;d&#39;
</code></pre>
<h3 id="5-3-哈希和编码"><a href="#5-3-哈希和编码" class="headerlink" title="5.3 哈希和编码"></a>5.3 哈希和编码</h3><p>能够快速的将你的数据转换成你需要的任何格式。</p>
<p><strong>Base64</strong></p>
<pre><code>&#39;hello&#39; == b64d(b64e(&#39;hello&#39;))
</code></pre>
<p><strong>Hashes</strong></p>
<pre><code>md5sumhex(&#39;hello&#39;) == &#39;5d41402abc4b2a76b9719d911017c592&#39;
write(&#39;file&#39;, &#39;hello&#39;)
md5filehex(&#39;file&#39;) == &#39;5d41402abc4b2a76b9719d911017c592&#39;
sha1sumhex(&#39;hello&#39;) == &#39;aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d&#39;
</code></pre>
<p><strong>URL Encoding</strong></p>
<pre><code>urlencode(&quot;Hello, World!&quot;) == &#39;%48%65%6c%6c%6f%2c%20%57%6f%72%6c%64%21&#39;
</code></pre>
<p><strong>Hex Encoding</strong></p>
<pre><code>enhex(&#39;hello&#39;)
# &#39;68656c6c6f&#39;
unhex(&#39;776f726c64&#39;)
# &#39;world&#39;
</code></pre>
<p><strong>Bit Manipulation and Hex Dumping</strong></p>
<pre><code>bits(0b1000001) == bits(&#39;A&#39;)
# [0, 0, 0, 1, 0, 1, 0, 1]
unbits([0,1,0,1,0,1,0,1])
# &#39;U&#39;
</code></pre>
<p><strong>Hex Dumping</strong></p>
<pre><code>print hexdump(read(&#39;/dev/urandom&#39;, 32))
# 00000000  65 4c b6 62  da 4f 1d 1b  d8 44 a6 59  a3 e8 69 2c  │eL·b│·O··│·D·Y│··i,│
# 00000010  09 d8 1c f2  9b 4a 9e 94  14 2b 55 7c  4e a8 52 a5  │····│·J··│·+U|│N·R·│
# 00000020
</code></pre>
<h3 id="5-4-样例生成"><a href="#5-4-样例生成" class="headerlink" title="5.4 样例生成"></a>5.4 样例生成</h3><p>样例生成是一种非常方便的方法，可以在不需要进行数学计算的情况下找到偏移量。</p>
<p>假设我们有一个直接的缓冲区溢出，我们生成一个样例并提供给目标应用程序。</p>
<pre><code>io = process(...)
io.send(cyclic(512))
</code></pre>
<p>在核心转储中，我们可能看到崩溃发生在0x61616178。我们可以不用对崩溃帧做任何分析，只需把这个数字打回去，得到一个偏移量。</p>
<pre><code>cyclic_find(0x61616178)
# 92
</code></pre>
<h2 id="六、Bytes-vs-Strings"><a href="#六、Bytes-vs-Strings" class="headerlink" title="六、Bytes vs. Strings"></a>六、Bytes vs. Strings</h2><p>当Pwntools最初（重新）编写时，大约在十年前，Python2是最受欢迎的。</p>
<pre><code>commit e692277db8533eaf62dd3d2072144ccf0f673b2e
Author: Morten Brøns-Pedersen &lt;mortenbp@gmail.com&gt;
Date:   Thu Jun 7 17:34:48 2012 +0200

    ALL THE THINGS
</code></pre>
<p>多年来在Python中编写的许多EXP都假定<code>str</code>对象与<code>bytes</code>对象有1:1的映射，因为这是Python2上的工作原理。 在这一节中，我们讨论在Python3上编写EXP所需的一些变化，并阐述与Python2的对应关系。</p>
<h3 id="6-1-Python2"><a href="#6-1-Python2" class="headerlink" title="6.1 Python2"></a>6.1 Python2</h3><p>在Python2中，<code>str</code>类和<code>bytes</code>类是一样的，而且有一个1:1的映射。从来不需要对任何东西调用<code>encode</code>或<code>decode</code> – 文本就是字节，字节就是文本。</p>
<p>这对编写EXP来说是非常方便的，因为你只需写”\x90\x90\x90\x90 “就可以得到一个NOP滑块。Python2上所有的Pwntools管道和数据操作都支持字符串或字节。</p>
<p>从来没有人使用<code>unicode</code>对象来编写漏洞，所以<code>unicode</code>到字节的转换极其罕见。</p>
<h3 id="6-2-Python3"><a href="#6-2-Python3" class="headerlink" title="6.2 Python3"></a>6.2 Python3</h3><p>在 Python3 中，<code>unicode</code>类实际上就是<code>str</code>类。这有一些直接和明显的影响。</p>
<p>乍一看，Python3似乎让事情变得更难了，因为<code>bytes</code>声明的是单个的八位数（正如名字<code>bytes</code>所暗示的），而<code>str</code>用于任何基于文本的数据表示。</p>
<p>Pwntools花了很大力气来遵循 “最小惊喜原则”——也就是说，事情会按照你预期的方式进行。</p>
<pre><code>&gt;&gt;&gt; r.send(&#39;❤️&#39;)
[DEBUG] Sent 0x6 bytes:
    00000000  e2 9d a4 ef  b8 8f                                  │····│··│
    00000006
&gt;&gt;&gt; r.send(&#39;\x00\xff\x7f\x41\x41\x41\x41&#39;)
[DEBUG] Sent 0x7 bytes:
    00000000  00 ff 7f 41  41 41 41                               │···A│AAA│
    00000007
</code></pre>
<p>然而，有时事情会出现一些故障。注意这里99f7e2如何被转换为c299c3b7c3a2。</p>
<pre><code>&gt;&gt;&gt; shellcode = &quot;\x99\xf7\xe2&quot;
&gt;&gt;&gt; print(hexdump(flat(&quot;padding\x00&quot;, shellcode)))
00000000  70 61 64 64  69 6e 67 00  c2 99 c3 b7  c3 a2        │padd│ing·│····│··│
0000000e
</code></pre>
<p>这是因为文本字符串”\x99\xf7\xe2 “被自动转换为UTF-8代码。这不可能是用户想要的。</p>
<p>作为解决方案，我们只需要以b为前缀：</p>
<pre><code>&gt;&gt;&gt; shellcode = b&quot;\x99\xf7\xe2&quot;
&gt;&gt;&gt; print(hexdump(flat(b&quot;padding\x00&quot;, shellcode)))
00000000  70 61 64 64  69 6e 67 00  99 f7 e2                  │padd│ing·│···│
0000000b
</code></pre>
<p>好极了！</p>
<p>一般来说，Python3上的Pwntools的修复方法是确保你所有的字符串都有一个<code>b</code>前缀。这就解决了歧义，并使一切变得简单明了。</p>
<h3 id="6-3-麻烦"><a href="#6-3-麻烦" class="headerlink" title="6.3 麻烦"></a>6.3 麻烦</h3><p>关于Python3的<code>bytes</code>对象，有一个值得一提的 “麻烦”。当对它们进行迭代时，你会得到整数，而不是<code>bytes</code>对象。这是与Python2的巨大差异，也是一个主要的烦恼。</p>
<pre><code>&gt;&gt;&gt; x=b&#39;123&#39;
&gt;&gt;&gt; for i in x:
...     print(i)
...
49
50
51
</code></pre>
<p>为了解决这个问题，我们建议使用切片，它产生长度为1<code>bytes</code>的对象。</p>
<pre><code>&gt;&gt;&gt; for i in range(len(x)):
...     print(x[i:i+1])
...
b&#39;1&#39;
b&#39;2&#39;
b&#39;3&#39;
</code></pre>
<h2 id="七、环境"><a href="#七、环境" class="headerlink" title="七、环境"></a>七、环境</h2><p><code>context</code>对象是一个全局的、线程感知的对象，包含了<code>pwntools</code>使用的各种设置。</p>
<p>一般来说，在一个EXP的首部，你会发现类似的东西：</p>
<pre><code>from pwn import *
context.arch = &#39;amd64&#39;
</code></pre>
<p>这通知pwntools生成的shellcode将用于amd64，并且默认字大小为64位。</p>
<h3 id="7-1-环境设置"><a href="#7-1-环境设置" class="headerlink" title="7.1 环境设置"></a>7.1 环境设置</h3><p><strong>arch</strong></p>
<p>目标架构。有效值是<code>&quot;arch64&quot;</code>、<code>&quot;arm&quot;</code>、<code>&quot;i386&quot;</code>、<code>&quot;amd64&quot;</code>，等等。默认是 <code>&quot;i386&quot;</code>。</p>
<p>第一次设置时，它会自动将默认的context.bits和context.endian设置为最可能的值。</p>
<p><strong>bits</strong></p>
<p>在目标二进制中，有多少位组成一个字，如<code>32</code>或<code>64</code>。</p>
<p><strong>binary</strong></p>
<p>从ELF文件中获取配置。例如：<code>context.binary=&#39;/bin/sh&#39;</code></p>
<p><strong>log_file</strong></p>
<p>将所有的日志输出送入的文件。</p>
<p><strong>log_level</strong></p>
<p>日志的详细程度。有效值是整数（越小越详细），以及<code>&quot;debug&quot;</code>、<code>&quot;info &quot;</code>和<code>&quot;error &quot;</code>等字符串值。</p>
<p><strong>sign</strong></p>
<p>设置整数打包/解包的是否有符号。默认为 <code>&quot;unsigned&quot;</code>。</p>
<p><strong>terminal</strong></p>
<p>用来打开新窗口的首选终端程序。默认情况下，使用<code>x-terminal-emulator</code>或<code>tmux</code>。</p>
<p><strong>timeout</strong></p>
<p>管道操作的默认超时范围。</p>
<p><strong>update</strong></p>
<p>一次设置多个值，例如<code>context.update(arch=&#39;mips&#39;, bits=64, endian=&#39;big&#39;)</code></p>
<h2 id="八、ELFs"><a href="#八、ELFs" class="headerlink" title="八、ELFs"></a>八、ELFs</h2><p>Pwntools通过ELF类使与ELF文件的交互变得相对简单。你可以在<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/elf.html">RTD</a>上找到完整的文档。</p>
<h3 id="8-1-加载ELF文件"><a href="#8-1-加载ELF文件" class="headerlink" title="8.1 加载ELF文件"></a>8.1 加载ELF文件</h3><p>ELF文件是按路径加载的。在被加载后，一些与安全有关的文件属性被打印出来。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)
# [*] &#39;/bin/bash&#39;
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE
#     FORTIFY:  Enabled
</code></pre>
<h3 id="8-2-使用符号表"><a href="#8-2-使用符号表" class="headerlink" title="8.2 使用符号表"></a>8.2 使用符号表</h3><p>ELF文件有几组不同的符号表可用，每组都包含在<code>&#123;name: data&#125;</code>的字典中。</p>
<ul>
<li>  <code>ELF.symbols</code> 列出所有已知的符号，包括下面的符号。优先考虑PLT条目，而不是GOT条目。</li>
<li>  <code>ELF.got</code> 只包含GOT表</li>
<li>  <code>ELF.plt</code> 只包含PLT表</li>
<li>  <code>ELF.functions</code> 只包含函数符号表（需要DWARF符号表）</li>
</ul>
<p>这对于保持漏洞的稳健性非常有用，因为它消除了对硬编码地址的需要。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

print &quot;%#x -&gt; license&quot; % e.symbols[&#39;bash_license&#39;]
print &quot;%#x -&gt; execve&quot; % e.symbols[&#39;execve&#39;]
print &quot;%#x -&gt; got.execve&quot; % e.got[&#39;execve&#39;]
print &quot;%#x -&gt; plt.execve&quot; % e.plt[&#39;execve&#39;]
print &quot;%#x -&gt; list_all_jobs&quot; % e.functions[&#39;list_all_jobs&#39;].address
</code></pre>
<p>这将打印出类似下面的内容：</p>
<pre><code>0x4ba738 -&gt; license
0x41db60 -&gt; execve
0x6f0318 -&gt; got.execve
0x41db60 -&gt; plt.execve
0x446420 -&gt; list_all_jobs
</code></pre>
<h3 id="8-3-改变基本地址"><a href="#8-3-改变基本地址" class="headerlink" title="8.3 改变基本地址"></a>8.3 改变基本地址</h3><p>使用pwntools改变ELF文件的基址（比如为ASLR做调整）是非常直接和简单的。让我们改变bash的基址，看看所有的符号都有什么变化。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

print &quot;%#x -&gt; base address&quot; % e.address
print &quot;%#x -&gt; entry point&quot; % e.entry
print &quot;%#x -&gt; execve&quot; % e.symbols[&#39;execve&#39;]

print &quot;---&quot;
e.address = 0x12340000

print &quot;%#x -&gt; base address&quot; % e.address
print &quot;%#x -&gt; entry point&quot; % e.entry
print &quot;%#x -&gt; execve&quot; % e.symbols[&#39;execve&#39;]
</code></pre>
<p>这应该打印出类似的内容：</p>
<pre><code>0x400000 -&gt; base address
0x42020b -&gt; entry point
0x41db60 -&gt; execve
---
0x12340000 -&gt; base address
0x1236020b -&gt; entry point
0x1235db60 -&gt; execve
</code></pre>
<h3 id="8-4-读取ELF文件"><a href="#8-4-读取ELF文件" class="headerlink" title="8.4 读取ELF文件"></a>8.4 读取ELF文件</h3><p>我们可以通过pwntools直接与ELF互动，就像它被加载到内存中一样，使用<code>read</code>、<code>write</code>和与<code>packing</code>模块中的函数命名相同。此外，你可以通过<code>disasm</code>方法看到反汇编。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

print repr(e.read(e.address, 4))

p_license = e.symbols[&#39;bash_license&#39;]
license   = e.unpack(p_license)
print &quot;%#x -&gt; %#x&quot; % (p_license, license)

print e.read(license, 14)
print e.disasm(e.symbols[&#39;main&#39;], 12)
</code></pre>
<p>打印出来的东西应该如下：</p>
<pre><code>&#39;\x7fELF&#39;
0x4ba738 -&gt; 0x4ba640
License GPLv3+
  41eab0:       41 57                   push   r15
  41eab2:       41 56                   push   r14
  41eab4:       41 55                   push   r13
</code></pre>
<h3 id="8-5-对ELF文件进行修补"><a href="#8-5-对ELF文件进行修补" class="headerlink" title="8.5 对ELF文件进行修补"></a>8.5 对ELF文件进行修补</h3><p>对ELF文件的修补也同样简单。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

# Cause a debug break on the &#39;exit&#39; command
e.asm(e.symbols[&#39;exit_builtin&#39;], &#39;int3&#39;)

# Disable chdir and just print it out instead
e.pack(e.got[&#39;chdir&#39;], e.plt[&#39;puts&#39;])

# Change the license
p_license = e.symbols[&#39;bash_license&#39;]
license = e.unpack(p_license)
e.write(license, &#39;Hello, world!\n\x00&#39;)

e.save(&#39;./bash-modified&#39;)
</code></pre>
<p>然后我们可以运行我们修改过的bash版本。</p>
<pre><code>$ chmod +x ./bash-modified
$ ./bash-modified -c &#39;exit&#39;
Trace/breakpoint trap (core dumped)
$ ./bash-modified --version | grep &quot;Hello&quot;
Hello, world!
$ ./bash-modified -c &#39;cd &quot;No chdir for you!&quot;&#39;
/home/user/No chdir for you!
No chdir for you!
./bash-modified: line 0: cd: No chdir for you!: No such file or directory
</code></pre>
<h3 id="8-6-搜索ELF文件"><a href="#8-6-搜索ELF文件" class="headerlink" title="8.6 搜索ELF文件"></a>8.6 搜索ELF文件</h3><p>在编写EXP的时候，你经常需要找到一些字节序列。最常见的例子是搜索例如<code>&quot;/bin/sh\x00 &quot;</code>的<code>execve</code>调用。<code>search</code>方法返回一个迭代器，允许你选择第一个结果，或者如果你需要一些特殊的东西（比如地址中没有坏字符），可以继续搜索。你可以选择传递一个<code>writable</code>参数给<code>search</code>，表示它应该只返回可写段的地址。</p>
<pre><code>from pwn import *

e = ELF(&#39;/bin/bash&#39;)

for address in e.search(&#39;/bin/sh\x00&#39;):
    print hex(address)
</code></pre>
<p>上面的例子打印的内容应该如下：</p>
<pre><code>0x420b82
0x420c5e
</code></pre>
<h3 id="8-7-构建ELF文件"><a href="#8-7-构建ELF文件" class="headerlink" title="8.7 构建ELF文件"></a>8.7 构建ELF文件</h3><p>通过pwntools我们可以很方便地从头开始创建一个ELF文件。所有这些功能都是上下文感知的。相关的函数是<code>from_bytes</code>和<code>from_assembly</code>。每一个都返回一个<code>ELF</code>对象，它可以很容易地被保存到文件中。</p>
<pre><code>from pwn import *

ELF.from_bytes(&#39;\xcc&#39;).save(&#39;int3-1&#39;)
ELF.from_assembly(&#39;int3&#39;).save(&#39;int3-2&#39;)
ELF.from_assembly(&#39;nop&#39;, arch=&#39;powerpc&#39;).save(&#39;powerpc-nop&#39;)
</code></pre>
<h3 id="8-8-运行和调试ELF文件"><a href="#8-8-运行和调试ELF文件" class="headerlink" title="8.8 运行和调试ELF文件"></a>8.8 运行和调试ELF文件</h3><p>如果你有一个ELF对象，你可以直接运行或调试它。以下两个代码是等同的：</p>
<pre><code>&gt;&gt;&gt; io = elf.process()
# vs
&gt;&gt;&gt; io = process(elf.path)
</code></pre>
<p>同样地，你可以启动一个调试器，并将其连接到ELF上。这在测试shellcode时是非常有用的，不需要用C语言包装器来加载和调试它。</p>
<pre><code>&gt;&gt;&gt; io = elf.debug()
# vs
&gt;&gt;&gt; io = gdb.debug(elf.path)
</code></pre>
<h2 id="九、汇编"><a href="#九、汇编" class="headerlink" title="九、汇编"></a>九、汇编</h2><p>Pwntools使得用户在几乎所有的架构中进行汇编变得非常容易，并带有各种可以开箱即用已经生成好且依然可定制的shellcode。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/walkthrough">walkthrough</a>目录中，有几个较长的shellcode教程。本页为您提供了基础知识。</p>
<h3 id="9-1-基础汇编"><a href="#9-1-基础汇编" class="headerlink" title="9.1 基础汇编"></a>9.1 基础汇编</h3><p>最基本的例子，是将汇编代码转换成shellcode。</p>
<pre><code>from pwn import *

print repr(asm(&#39;xor edi, edi&#39;))
# &#39;1\xff&#39;

print enhex(asm(&#39;xor edi, edi&#39;))
# 31ff
</code></pre>
<h3 id="9-2-现成的汇编（shellcraft）"><a href="#9-2-现成的汇编（shellcraft）" class="headerlink" title="9.2 现成的汇编（shellcraft）"></a>9.2 现成的汇编（<code>shellcraft</code>）</h3><p><code>shellcraft</code>模块会提供给你一些现成的汇编代码。它通常是可定制的。找出存在哪些<code>shellcraft</code>模板的最简单方法是查看<a target="_blank" rel="noopener" href="https://pwntools.readthedocs.org/en/latest/shellcraft.html">RTD</a>上的文档。</p>
<pre><code>from pwn import *
help(shellcraft.sh)
print &#39;---&#39;
print shellcraft.sh()
print &#39;---&#39;
print enhex(asm(shellcraft.sh()))


Help on function sh in module pwnlib.shellcraft.internal:

sh()
    Execute /bin/sh
---
    /* push &#39;/bin///sh\x00&#39; */
    push 0x68
    push 0x732f2f2f
    push 0x6e69622f

    /* call execve(&#39;esp&#39;, 0, 0) */
    push (SYS_execve) /* 0xb */
    pop eax
    mov ebx, esp
    xor ecx, ecx
    cdq /* edx=0 */
    int 0x80
---
6a68682f2f2f73682f62696e6a0b5889e331c999cd80
</code></pre>
<h3 id="9-3-命令行工具"><a href="#9-3-命令行工具" class="headerlink" title="9.3 命令行工具"></a>9.3 命令行工具</h3><p>有三个命令行工具用于与汇编进行交互。</p>
<ul>
<li>  <code>asm</code></li>
<li>  <code>disasm</code></li>
<li>  <code>shellcraft</code></li>
</ul>
<p><strong>asm</strong></p>
<p><code>asm</code>工具的功能正如其名，它将汇编码转换为机器码，它为汇编指令输出的格式化提供了几个选项，当输出是一个终端时，它默认为十六进制编码。</p>
<pre><code>$ asm nop
90
</code></pre>
<p>当输出是其他东西时，它显示的是原始数据。</p>
<pre><code>$ asm nop | xxd
0000000: 90                                       .
</code></pre>
<p>如果在命令行上没有提供指令，它将在stdin上获取数据。</p>
<pre><code>$ echo &#39;push ebx; pop edi&#39; | asm
535f
</code></pre>
<p>最后，它支持一些不同的选项，通过<code>--format</code>选项来指定输出格式。支持的参数有<code>raw</code>、<code>hex</code>、<code>string</code>和<code>elf</code>。</p>
<pre><code>$ asm --format=elf &#39;int3&#39; &gt; ./int3
$ ./halt
Trace/breakpoint trap (core dumped)
</code></pre>
<p><strong>disasm</strong></p>
<p>Disasm是<code>asm</code>的反义词，也就是将16进制的机器码反汇编成汇编指令。</p>
<pre><code>$ disasm cd80
   0:    cd 80                    int    0x80
$ asm nop | disasm
   0:    90                       nop
</code></pre>
<p><strong>shellcraft</strong></p>
<p><code>shellcraft</code>命令是内部<code>shellcraft</code>模块的命令行接口。在命令行中，必须按<code>arch.os.template</code>的顺序指定完整的环境信息。</p>
<pre><code>$ shellcraft i386.linux.sh
6a68682f2f2f73682f62696e6a0b5889e331c999cd80
</code></pre>
<h3 id="9-4-异构架构"><a href="#9-4-异构架构" class="headerlink" title="9.4 异构架构"></a>9.4 异构架构</h3><p>为其它非X86架构进行汇编交互，你需要自行安装适当版本的<code>binutils</code>。你应该看看<a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/installing.md">installing.md</a>以了解更多这方面的信息。我们唯一需要改变的是在全局环境变量中设置架构。你可以在 <a target="_blank" rel="noopener" href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/context.md">context.md</a> 中看到更多关于<code>context</code>的信息。</p>
<pre><code>from pwn import *

context.arch = &#39;arm&#39;

print repr(asm(&#39;mov r0, r1&#39;))
# &#39;\x01\x00\xa0\xe1&#39;

print enhex(asm(&#39;mov r0, r1&#39;))
# 0100a0e1
</code></pre>
<h4 id="9-4-1-现成汇编"><a href="#9-4-1-现成汇编" class="headerlink" title="9.4.1 现成汇编"></a>9.4.1 现成汇编</h4><p><code>shellcraft</code>模块会自动切换到相应的架构。</p>
<pre><code>from pwn import *

context.arch = &#39;arm&#39;

print shellcraft.sh()
print enhex(asm(shellcraft.sh()))


    adr r0, bin_sh
    mov r2, #0
    mov r1, r2
    svc SYS_execve
bin_sh: .asciz &quot;/bin/sh&quot;

08008fe20020a0e30210a0e10b0000ef2f62696e2f736800
</code></pre>
<h4 id="9-4-2-命令行工具"><a href="#9-4-2-命令行工具" class="headerlink" title="9.4.2 命令行工具"></a>9.4.2 命令行工具</h4><p>你也可以通过使用<code>--context</code>命令行选项，使用命令行来汇编生成其它架构的<code>shellcode</code>。</p>
<pre><code>$ asm --context=arm &#39;mov r0, r1&#39;
0100a0e1
$ shellcraft arm.linux.sh
08008fe20020a0e30210a0e10b0000ef2f62696e2f736800
</code></pre>
<h2 id="十、调试"><a href="#十、调试" class="headerlink" title="十、调试"></a>十、调试</h2><p>Pwntools对在你的漏洞工作流程中使用调试器有丰富的支持，在开发EXP的问题出现时，调试器非常有用。</p>
<p>除了这里的调试资源外，你可能想通过以下项目来增强你的GDB经验：</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://pwndbg.re/">Pwndbg</a></li>
<li>  <a target="_blank" rel="noopener" href="https://github.com/hugsy/gef">GDB Enhanced Features (GEF)</a></li>
</ul>
<h3 id="10-1-先前条件"><a href="#10-1-先前条件" class="headerlink" title="10.1 先前条件"></a>10.1 先前条件</h3><p>你的机器上应该同时安装了<code>gdb</code>和<code>gdbserver</code>。你可以用<code>which gdb</code>或<code>which gdbserver</code>来轻松检查。</p>
<p>如果你发现你没有安装它们，它们可以很容易地从大多数软件包管理器中安装。</p>
<pre><code>$ sudo apt-get install gdb gdbserver
</code></pre>
<h3 id="10-2-在GDB下启动一个进程"><a href="#10-2-在GDB下启动一个进程" class="headerlink" title="10.2 在GDB下启动一个进程"></a>10.2 在GDB下启动一个进程</h3><p>在GDB下启动一个进程，同时还能从pwntools与该进程进行交互，这在之前是一个棘手的过程，但幸运的是，这一切都已经被解决了，而且这个过程是相当无感和便捷的。</p>
<p>要在GDB下从第一条指令开始启动一个进程，只需使用<a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/gdb.html#pwnlib.gdb.debug">gdb.debug</a>。</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug(&quot;/bin/bash&quot;, gdbscript=&#39;continue&#39;)
&gt;&gt;&gt; io.sendline(&#39;echo hello&#39;)
&gt;&gt;&gt; io.recvline()
# b&#39;hello\n&#39;
&gt;&gt;&gt; io.interactive()
</code></pre>
<p>这应该会自动在一个新的窗口中启动调试器，以便你进行交互。如果不是这样，或者你看到关于<code>context.terminal</code>的错误，请查看指定终端窗口的章节。</p>
<p>在这个例子中，我们传入了<code>gdbscript=&#39;continue&#39;</code>，以使调试器恢复执行，但是你可以传入任何有效的GDB脚本命令，它们将在调试进程启动时被执行。</p>
<h3 id="10-3-附加到一个正在运行的进程"><a href="#10-3-附加到一个正在运行的进程" class="headerlink" title="10.3 附加到一个正在运行的进程"></a>10.3 附加到一个正在运行的进程</h3><p>有时你不想在调试器下启动你的目标，但想在开发过程的某个阶段附加到它。这也已经被Pwntools便捷无缝的实现了。</p>
<h4 id="10-3-1-本地进程"><a href="#10-3-1-本地进程" class="headerlink" title="10.3.1 本地进程"></a>10.3.1 本地进程</h4><p>一般来说，你会创建一个<code>process()</code>管道，以便与目标可执行文件交互。你可以简单地把它传递给<code>gdb.attach()</code>，它将神奇地打开一个新的终端窗口，在调试器中运行目标二进制文件。</p>
<pre><code>&gt;&gt;&gt; io = process(&#39;/bin/sh&#39;)
&gt;&gt;&gt; gdb.attach(io, gdbscript=&#39;continue&#39;)
</code></pre>
<p>一个新的窗口应该出现，你可以继续与进程进行互动，就像你通常在Pwntools中做的一样。</p>
<h4 id="10-3-2-远程服务器"><a href="#10-3-2-远程服务器" class="headerlink" title="10.3.2 远程服务器"></a>10.3.2 远程服务器</h4><p>有时你想调试的二进制文件运行在一个远程服务器上，你想调试你所连接的进程（而不是服务器本身）。只要服务器在当前机器上运行，这也可以无缝地完成。</p>
<p>让我们用socat伪造一个服务器!</p>
<pre><code>&gt;&gt;&gt; socat = process([&#39;socat&#39;, &#39;TCP-LISTEN:4141,reuseaddr,fork&#39;, &#39;EXEC:/bin/bash -i&#39;])
</code></pre>
<p>然后我们像往常一样用远程管道连接到远程进程。</p>
<pre><code>&gt;&gt;&gt; io = remote(&#39;localhost&#39;, 4141)
[x] Opening connection to localhost on port 4141
[x] Opening connection to localhost on port 4141: Trying 127.0.0.1
[+] Opening connection to localhost on port 4141: Done
&gt;&gt;&gt; io.sendline(&#39;echo hello&#39;)
&gt;&gt;&gt; io.recvline()
b&#39;hello\n&#39;
&gt;&gt;&gt; io.lport, io.rport
</code></pre>
<p>它是有效的！为了调试特定的<code>bash</code>进程，只要把它我们的远程对象传给<code>gdb.attach()</code>。Pwntools将查找连接的远程端的PID，并尝试自动连接到它。</p>
<pre><code>&gt;&gt;&gt; gdb.attach(io)
</code></pre>
<p>调试器应该自动出现，你可以与进程进行交互。</p>
<h3 id="10-3-调试异构架构"><a href="#10-3-调试异构架构" class="headerlink" title="10.3 调试异构架构"></a>10.3 调试异构架构</h3><p>从基于英特尔的系统中在pwntools下调试异构架构（如ARM或PowerPC）是十分容易的。</p>
<pre><code>&gt;&gt;&gt; context.arch = &#39;arm&#39;
&gt;&gt;&gt; elf = ELF.from_assembly(shellcraft.echo(&quot;Hello, world!\n&quot;) + shellcraft.exit())
&gt;&gt;&gt; process(elf.path).recvall()
b&#39;Hello, world!\n&#39;
</code></pre>
<p>用<code>gdb.debug(...)</code>来代替调用<code>process(...)</code></p>
<pre><code>&gt;&gt;&gt; gdb.debug(elf.path).recvall()
b&#39;Hello, world!\n&#39;
</code></pre>
<h4 id="10-3-1-提示和限制"><a href="#10-3-1-提示和限制" class="headerlink" title="10.3.1 提示和限制"></a>10.3.1 提示和限制</h4><p>运行异构架构的进程必须用<code>gdb.debug</code>启动，以便对其进行调试，由于QEMU的工作方式，不可能附加到一个正在运行的进程上。</p>
<p>需要注意的是，QEMU有一个非常有限的用来通知GDB各种库的位置存根，所以调试可能会更加困难，一些命令也无法工作。</p>
<p>Pwntools推荐使用Pwndbg来处理这种情况，因为它拥有专门处理QEMU存根下调试程序的能力。</p>
<h3 id="10-4-故障排除（Pwntools自身）"><a href="#10-4-故障排除（Pwntools自身）" class="headerlink" title="10.4 故障排除（Pwntools自身）"></a>10.4 故障排除（Pwntools自身）</h3><h4 id="10-4-1-幕后花絮（工作详情）"><a href="#10-4-1-幕后花絮（工作详情）" class="headerlink" title="10.4.1 幕后花絮（工作详情）"></a>10.4.1 幕后花絮（工作详情）</h4><p>有时程序就是不正常工作，你需要看看Pwntools内部在调试器的设置下发生了什么。</p>
<p>你可以在全局范围内设置日志上下文（例如通过<code>context.log_level=&#39;debug&#39;</code>），也可以通过传递相同的参数，只为GDB会话设置。</p>
<p>你应该看到在幕后为你处理的一切操作。比如说：</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug(&#39;/bin/sh&#39;, log_level=&#39;debug&#39;)
[x] Starting local process &#39;/home/user/bin/gdbserver&#39; argv=[b&#39;/home/user/bin/gdbserver&#39;, b&#39;--multi&#39;, b&#39;--no-disable-randomization&#39;, b&#39;localhost:0&#39;, b&#39;/bin/sh&#39;]
[+] Starting local process &#39;/home/user/bin/gdbserver&#39; argv=[b&#39;/home/user/bin/gdbserver&#39;, b&#39;--multi&#39;, b&#39;--no-disable-randomization&#39;, b&#39;localhost:0&#39;, b&#39;/bin/sh&#39;] : pid 34282
[DEBUG] Received 0x25 bytes:
    b&#39;Process /bin/sh created; pid = 34286\n&#39;
[DEBUG] Received 0x18 bytes:
    b&#39;Listening on port 45145\n&#39;
[DEBUG] Wrote gdb script to &#39;/tmp/user/pwnxcd1zbyx.gdb&#39;
    target remote 127.0.0.1:45145
[*] running in new terminal: /usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb
[DEBUG] Launching a new terminal: [&#39;/usr/local/bin/tmux&#39;, &#39;splitw&#39;, &#39;/usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb&#39;]
[DEBUG] Received 0x25 bytes:
    b&#39;Remote debugging from host 127.0.0.1\n&#39;
</code></pre>
<h4 id="10-4-2-指定一个终端窗口"><a href="#10-4-2-指定一个终端窗口" class="headerlink" title="10.4.2 指定一个终端窗口"></a>10.4.2 指定一个终端窗口</h4><p>Pwntools[attempts to launch a new window][run_in_new_terminal]，根据你当前使用的任何窗口系统来展示你的调试器。</p>
<p>默认情况下，它是自动检测的：</p>
<ul>
<li>  tmux or screen</li>
<li>  X11-based terminals like GNOME Terminal</li>
</ul>
<p>如果你没有使用支持的终端环境，或者它没有以你想要的方式工作（例如，水平与垂直分割），你可以通过设置<code>context.terminal</code>环境变量来增加支持。</p>
<p>例如，下面将使用TMUX进行水平分割，而不是默认设置。</p>
<pre><code>&gt;&gt;&gt; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
</code></pre>
<p>也许你是一个GNOME终端的用户，而默认的设置并不工作？</p>
<pre><code>&gt;&gt;&gt; context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]
</code></pre>
<p>你可以指定任何你喜欢的终端，甚至可以把设置放在<code>~/.pwn.conf</code>里面，这样它就会被用于你的所有脚本了</p>
<pre><code>[context]
terminal=[&#39;x-terminal-emulator&#39;, &#39;-e&#39;]
</code></pre>
<h4 id="10-4-3-环境变量"><a href="#10-4-3-环境变量" class="headerlink" title="10.4.3 环境变量"></a>10.4.3 环境变量</h4><p>Pwntools允许你通过<code>process()</code>指定任何你喜欢的环境变量，对于<code>gdb.debug()</code>也是如此。</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug([&#39;bash&#39;, &#39;-c&#39;, &#39;echo $HELLO&#39;], env=&#123;&#39;HELLO&#39;: &#39;WORLD&#39;&#125;)
&gt;&gt;&gt; io.recvline()
b&#39;WORLD\n&#39;
</code></pre>
<p><strong>CWD</strong></p>
<p>不幸的是，当使用<code>gdb.debug()</code>时，该进程是在<code>gdbserver</code>下启动的，它增加了自己的环境变量。当环境必须被非常仔细地控制时，这可能会带来复杂的情况。</p>
<pre><code>&gt;&gt;&gt; io = gdb.debug([&#39;env&#39;], env=&#123;&#39;FOO&#39;:&#39;BAR&#39;&#125;, gdbscript=&#39;continue&#39;)
&gt;&gt;&gt; print(io.recvallS())
   =/home/user/bin/gdbserver
FOO=BAR

Child exited with status 0
GDBserver exiting
</code></pre>
<p>这只在你用<code>gdb.debug()</code>在调试器下启动进程时发生。如果你能够启动你的进程，然后用<code>gdb.attach()</code>附加，你就可以避免这个问题。</p>
<p><strong>环境变量排序</strong></p>
<p>一些漏洞可能需要某些环境变量以特定的顺序出现。但是Python2的字典是没有顺序的，这可能会加剧这个问题。</p>
<p>为了让你的环境变量有一个特定的顺序，我们建议使用Python3（它基于插入顺序对字典进行排序），或者使用<code>collection.OrderedDict</code>。</p>
<h4 id="10-4-4-无法附加到进程中"><a href="#10-4-4-无法附加到进程中" class="headerlink" title="10.4.4 无法附加到进程中"></a>10.4.4 无法附加到进程中</h4><p>现代的Linux系统有一个叫做<code>trace_scope</code>的设置，它可以阻止非子进程的进程被调试。Pwntools对于它自己启动的任何进程都能解决这个问题，但是如果你必须在Pwntools之外启动一个进程，并试图通过pid附加到它（例如<code>gdb.attach(1234)</code>），你可能被阻止附加。</p>
<p>你可以通过禁用安全设置和重启机器来解决这个问题：</p>
<pre><code>sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF
kernel.yama.ptrace_scope = 0
EOF
</code></pre>
<h4 id="10-4-5-argv0-and-argc-0"><a href="#10-4-5-argv0-and-argc-0" class="headerlink" title="10.4.5 argv0 and argc==0"></a>10.4.5 argv0 and argc==0</h4><p>有些题目要求在启动时将<code>argv[0]</code>设置为一个特定的值，甚至要求它是NULL（即<code>argc==0</code>）。</p>
<p>通过<code>gdb.debug()</code>不可能用这种配置启动一个processs，但你可以使用<code>gdb.attach()</code>。这是因为在gdbserver下启动二进制文件的限制。</p>
<h2 id="十一、ROP"><a href="#十一、ROP" class="headerlink" title="十一、ROP"></a>十一、ROP</h2><h3 id="11-1-背景"><a href="#11-1-背景" class="headerlink" title="11.1 背景"></a>11.1 背景</h3><p>面向返回的编程（ROP）是一种绕过NX（no-execute，也称为预防数据执行（DEP））的技术。</p>
<p>Pwntools有几个特点，使ROP的利用更简单，但只适用于i386和amd64架构。</p>
<h3 id="11-2-加载一个ELF"><a href="#11-2-加载一个ELF" class="headerlink" title="11.2 加载一个ELF"></a>11.2 加载一个ELF</h3><p>要创建一个<code>ROP</code>对象，只需向它传递一个<code>ELF</code>文件。</p>
<pre><code>elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
</code></pre>
<p>这将自动加载二进制文件，并从其中提取大多数简单的gadgets。例如，如果你想加载<code>rbx</code>寄存器。</p>
<pre><code>rop.rbx
# Gadget(0x5fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x8)
</code></pre>
<h4 id="11-2-1-修复地址"><a href="#11-2-1-修复地址" class="headerlink" title="11.2.1 修复地址"></a>11.2.1 修复地址</h4><p>在这里，我们可以看到gadgets的地址，它的反汇编内容，它加载了什么寄存器，以及gadgets执行时堆栈被调整了多少。</p>
<p>由于在我们的例子中，<code>/bin/sh</code>是地址无关的（即使用ASLR），我们可以先调整ELF对象上的加载地址。</p>
<pre><code>elf.address = 0xff000000
rop = ROP(elf)
rop.rbx
# Gadget(0xff005fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x8)
</code></pre>
<h3 id="11-3-检查gadgets"><a href="#11-3-检查gadgets" class="headerlink" title="11.3 检查gadgets"></a>11.3 检查gadgets</h3><p>你可以通过魔法访问器询问ROP对象如何加载你想要的任何寄存器。我们在上面使用了<code>rbx</code>，但是我们也可以寻找其他的寄存器。</p>
<pre><code>rop.rbx
# Gadget(0xff005fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x8)
</code></pre>
<p>如果寄存器不能被加载，返回值为<code>None</code>。在我们的例子中，假如没有<code>pop rcx; ret</code>的gadgets：</p>
<pre><code>rop.rcx
# None
</code></pre>
<h4 id="11-3-1-查看所有gadgets"><a href="#11-3-1-查看所有gadgets" class="headerlink" title="11.3.1 查看所有gadgets"></a>11.3.1 查看所有gadgets</h4><p>Pwntools有意排除了大多数非实质性的gadgets，但你可以通过查看<code>ROP.gadgets</code>属性看到它已经加载的列表，该属性将一个gadgets的地址映射到gadgets本身。</p>
<pre><code>rop.gadgets
# &#123;4278225723: Gadget(0xff008b3b, [&#39;add esp, 0x10&#39;, &#39;pop rbx&#39;, &#39;pop rbp&#39;, &#39;pop r12&#39;, &#39;ret&#39;], [&#39;rbx&#39;, &#39;rbp&#39;, &#39;r12&#39;], 0x20),
#  4278278088: Gadget(0xff0157c8, [&#39;add esp, 0x130&#39;, &#39;pop rbp&#39;, &#39;ret&#39;], [&#39;rbp&#39;], 0x138),
#  4278284789: Gadget(0xff0171f5, [&#39;add esp, 0x138&#39;, &#39;pop rbx&#39;, &#39;pop rbp&#39;, &#39;ret&#39;], [&#39;rbx&#39;, &#39;rbp&#39;], 0x144),
#  4278272966: Gadget(0xff0143c6, [&#39;add esp, 0x18&#39;, &#39;ret&#39;], [], 0x1c),
#  4278239612: Gadget(0xff00c17c, [&#39;add esp, 0x20&#39;, &#39;pop rbx&#39;, &#39;pop rbp&#39;, &#39;pop r12&#39;, &#39;ret&#39;], [&#39;rbx&#39;, &#39;rbp&#39;, &#39;r12&#39;], 0x30),
#  4278259611: Gadget(0xff010f9b, [&#39;add esp, 0x28&#39;, &#39;pop rbp&#39;, &#39;pop r12&#39;, &#39;ret&#39;], [&#39;rbp&#39;, &#39;r12&#39;], 0x34),
# ...
#  4278216828: Gadget(0xff00687c, [&#39;pop rsp&#39;, &#39;pop r13&#39;, &#39;ret&#39;], [&#39;rsp&#39;, &#39;r13&#39;], 0xc),
#  4278214225: Gadget(0xff005e51, [&#39;pop rsp&#39;, &#39;ret&#39;], [&#39;rsp&#39;], 0x8),
#  4278210586: Gadget(0xff00501a, [&#39;ret&#39;], [], 0x4)&#125;
</code></pre>
<h4 id="11-3-2-真正查看所有的gadgets"><a href="#11-3-2-真正查看所有的gadgets" class="headerlink" title="11.3.2 真正查看所有的gadgets"></a>11.3.2 真正查看所有的gadgets</h4><p>Pwntools的ROP过滤掉了非实质性的小工具，所以如果它没有你想要的东西，我们建议使用ROPGadget来检查二进制文件。</p>
<h3 id="11-4-添加原始数据"><a href="#11-4-添加原始数据" class="headerlink" title="11.4 添加原始数据"></a>11.4 添加原始数据</h3><p>为了将原始数据添加到ROP栈中，只需调用<code>ROP.raw()</code>。</p>
<pre><code>rop.raw(0xdeadbeef)
rop.raw(0xcafebabe)
rop.raw(&#39;asdf&#39;)
</code></pre>
<h3 id="11-5-导出ROP栈"><a href="#11-5-导出ROP栈" class="headerlink" title="11.5 导出ROP栈"></a>11.5 导出ROP栈</h3><p>现在我们有了一些gadgets，让我们看看ROP栈上有什么：</p>
<pre><code>print(rop.dump())
# 0x0000:       0xdeadbeef
# 0x0004:       0xcafebabe
# 0x0008:          b&#39;asdf&#39; &#39;asdf&#39;
</code></pre>
<h3 id="11-6-提取原始字节"><a href="#11-6-提取原始字节" class="headerlink" title="11.6 提取原始字节"></a>11.6 提取原始字节</h3><p>现在我们有了一个ROP栈，我们想从它那里得到原始字节。我们可以使用<code>byte()</code>方法来实现这个功能。</p>
<pre><code>print(hexdump(bytes(rop)))
# 00000000  ef be ad de  be ba fe ca  61 73 64 66               │····│····│asdf│
# 0000000c
</code></pre>
<h3 id="11-7-神奇地调用函数"><a href="#11-7-神奇地调用函数" class="headerlink" title="11.7 神奇地调用函数"></a>11.7 神奇地调用函数</h3><p>Pwntools的ROP工具的真正威力在于能够调用任意的函数，无论是通过神奇的访问器还是通过<code>ROP.call()</code>例程。</p>
<pre><code>elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
rop.call(0xdeadbeef, [0, 1])
print(rop.dump())
# 0x0000:       0xdeadbeef 0xdeadbeef(0, 1, 2, 3)
# 0x0004:          b&#39;baaa&#39; &lt;return address&gt;
# 0x0008:              0x0 arg0
# 0x000c:              0x1 arg1
</code></pre>
<p>注意这里它使用的是32位ABI，这是不正确的。我们也可以对64位二进制文件进行ROP，但我们需要相应地设置<code>context.arch</code>。我们可以使用<code>context.binary</code>来自动完成这个工作。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
rop.call(0xdeadbeef, [0, 1])
print(rop.dump())
# 0x0000:           0x61aa pop rdi; ret
# 0x0008:              0x0 [arg0] rdi = 0
# 0x0010:           0x5f73 pop rsi; ret
# 0x0018:              0x1 [arg1] rsi = 1
# 0x0020:       0xdeadbeef
</code></pre>
<h3 id="11-8-使用函数名来调用函数"><a href="#11-8-使用函数名来调用函数" class="headerlink" title="11.8 使用函数名来调用函数"></a>11.8 使用函数名来调用函数</h3><p>如果你的库在其GOT/PLT中有你想调用的函数，或者有二进制的符号，你可以直接调用函数名。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
rop = ROP(elf)
rop.execve(0xdeadbeef)
print(rop.dump())
# 0x0000:           0x61aa pop rdi; ret
# 0x0008:       0xdeadbeef [arg0] rdi = 3735928559
# 0x0010:           0x5824 execve
</code></pre>
<h3 id="11-9-多重ELF"><a href="#11-9-多重ELF" class="headerlink" title="11.9 多重ELF"></a>11.9 多重ELF</h3><p>一般来说，在你的进程的地址空间中，一次有一个以上的ELF可用。让我们看一个使用<code>/bin/sh</code>以及其<code>libc</code>的例子。最初，我们看了<code>rop.rcx</code>，这个gadgets是不存在的，因为bash中没有<code>pop rcx; ret</code>这个gadgets。然后，现在我们也有来自libc的所有gadgets了。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
libc = elf.libc

elf.address = 0xAA000000
libc.address = 0xBB000000

rop.rax
# Gadget(0xaa00eb87, [&#39;pop rax&#39;, &#39;ret&#39;], [&#39;rax&#39;], 0x10)
rop.rbx
# Gadget(0xaa005fd5, [&#39;pop rbx&#39;, &#39;ret&#39;], [&#39;rbx&#39;], 0x10)
rop.rcx
# Gadget(0xbb09f822, [&#39;pop rcx&#39;, &#39;ret&#39;], [&#39;rcx&#39;], 0x10)
rop.rdx
# Gadget(0xbb117960, [&#39;pop rdx&#39;, &#39;add rsp, 0x38&#39;, &#39;ret&#39;], [&#39;rdx&#39;], 0x48)
</code></pre>
<p>注意<code>rax</code>和<code>rbx</code>的gadgets是在主二进制文件中（0xAA…），而后两个是在libc（0xBB…）。</p>
<p>现在，让我们做一个更复杂的函数调用吧!</p>
<pre><code>rop.memcpy(0xaaaaaaaa, 0xbbbbbbbb, 0xcccccccc)
print(rop.dump())
# 0x0000:       0xbb11c1e1 pop rdx; pop r12; ret
# 0x0008:       0xcccccccc [arg2] rdx = 3435973836
# 0x0010:      b&#39;eaaafaaa&#39; &lt;pad r12&gt;
# 0x0018:       0xaa0061aa pop rdi; ret
# 0x0020:       0xaaaaaaaa [arg0] rdi = 2863311530
# 0x0028:       0xaa005f73 pop rsi; ret
# 0x0030:       0xbbbbbbbb [arg1] rsi = 3149642683
# 0x0038:       0xaa0058a4 memcpy
</code></pre>
<p>请注意，Pwntools能够使用<code>pop rdx; pop r12; ret</code>gadgets，并说明堆栈上需要的额外值。还要注意的是，每个项目的符号值都在<code>rop.dump()</code>中获取。例如，它显示我们正在设置<code>rdx=3435973836</code>。</p>
<h3 id="11-10-获取一个shell"><a href="#11-10-获取一个shell" class="headerlink" title="11.10 获取一个shell"></a>11.10 获取一个shell</h3><p>当我们了解了pwntools的ROP功能时，获得一个shell是很容易的！我们直接调用<code>execve</code>，并从内存中的某个地方找到一个<code>&quot;/bin/sh/x00 &quot;</code>的实例作为第一个参数传递进去。</p>
<pre><code>context.binary = elf = ELF(&#39;/bin/sh&#39;)
libc = elf.libc

elf.address = 0xAA000000
libc.address = 0xBB000000

rop = ROP([elf, libc])

binsh = next(libc.search(b&quot;/bin/sh\x00&quot;))
rop.execve(binsh, 0, 0)
</code></pre>
<p>显示我们的ROP栈</p>
<pre><code>print(rop.dump())
# 0x0000:       0xbb11c1e1 pop rdx; pop r12; ret
# 0x0008:              0x0 [arg2] rdx = 0
# 0x0010:      b&#39;eaaafaaa&#39; &lt;pad r12&gt;
# 0x0018:       0xaa0061aa pop rdi; ret
# 0x0020:       0xbb1b75aa [arg0] rdi = 3139138986
# 0x0028:       0xaa005f73 pop rsi; ret
# 0x0030:              0x0 [arg1] rsi = 0
# 0x0038:       0xaa005824 execve
</code></pre>
<p>提取ROP的原始字节</p>
<pre><code>print(hexdump(bytes(rop)))
# 00000000  e1 c1 11 bb  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
# 00000010  65 61 61 61  66 61 61 61  aa 61 00 aa  00 00 00 00  │eaaa│faaa│·a··│····│
# 00000020  aa 75 1b bb  00 00 00 00  73 5f 00 aa  00 00 00 00  │·u··│····│s_··│····│
# 00000030  00 00 00 00  00 00 00 00  24 58 00 aa  00 00 00 00  │····│····│$X··│····│
# 00000040
</code></pre>
<h2 id="十二、日志"><a href="#十二、日志" class="headerlink" title="十二、日志"></a>十二、日志</h2><p>Pwntools有一个丰富的内部调试系统，可用于你自己的调试，以及弄清Pwntools幕后发生的事情。</p>
<h3 id="12-1-功能"><a href="#12-1-功能" class="headerlink" title="12.1 功能"></a>12.1 功能</h3><p>当你从pwn导入*时，日志功能就导入了。这些功能如下：</p>
<ul>
<li>  <code>error</code></li>
<li>  <code>warn</code></li>
<li>  <code>info</code></li>
<li>  <code>debug</code></li>
</ul>
<p>例如：</p>
<pre><code>&gt;&gt;&gt; warn(&#39;Warning!&#39;)
[!] Warning!
&gt;&gt;&gt; info(&#39;Info!&#39;)
[*] Info!
&gt;&gt;&gt; debug(&#39;Debug!&#39;)
</code></pre>
<p>注意，最后一行默认不显示，因为默认的日志级别是 “info”。</p>
<p>你可以在你的开发脚本中使用这些，而不是打印，这可以让你准确地调控你看到的调试信息量</p>
<p>你可以通过各种方式控制哪些日志信息是可见的，所有这些都将在下面解释。</p>
<h3 id="12-2-命令行"><a href="#12-2-命令行" class="headerlink" title="12.2 命令行"></a>12.2 命令行</h3><p>最简单的方法是在运行你的脚本时加入神奇的参数DEBUG，例如：打开最大限度的日志记录功能：</p>
<pre><code>$ python exploit.py DEBUG
</code></pre>
<p>这对于查看正在发送/接收的确切字节，以及在pwntools内部发生的事情，以使你的EXP发挥作用是很有用的。</p>
<h3 id="12-3-环境"><a href="#12-3-环境" class="headerlink" title="12.3 环境"></a>12.3 环境</h3><p>你也可以通过context.log_level来设置日志的粗略程度，就像你设置目标架构等的方式一样。这与在命令行中控制所有的日志语句的方式相同。</p>
<pre><code>&gt;&gt;&gt; context.log_level = &#39;debug&#39;
</code></pre>
<p><code>log_console</code></p>
<p>默认情况下，所有的日志都转到STDOUT。如果你想把它改成一个不同的文件，例如STDERR，你可以通过log_console设置来实现。</p>
<pre><code>&gt;&gt;&gt; context.log_console = sys.stderr
</code></pre>
<p><code>log_file</code></p>
<p>有时你想让你的日志转到一个特定的文件，例如log.txt，以便以后查看。你可以通过设置context.log_file来添加一个日志文件。</p>
<pre><code>&gt;&gt;&gt; context.log_file = &#39;./log.txt&#39;
</code></pre>
<h3 id="12-4-管道"><a href="#12-4-管道" class="headerlink" title="12.4 管道"></a>12.4 管道</h3><p>每个管子在创建时都可以单独控制其日志的粗略程度。只需将<code>level=&#39;...&#39;</code>传递给对象的构造。</p>
<pre><code>&gt;&gt;&gt; io = process(&#39;sh&#39;, level=&#39;debug&#39;)
[x] Starting local process &#39;/usr/bin/sh&#39; argv=[b&#39;sh&#39;]
[+] Starting local process &#39;/usr/bin/sh&#39; argv=[b&#39;sh&#39;] : pid 34475
&gt;&gt;&gt; io.sendline(&#39;echo hello&#39;)
[DEBUG] Sent 0xb bytes:
    b&#39;echo hello\n&#39;
&gt;&gt;&gt; io.recvline()
[DEBUG] Received 0x6 bytes:
    b&#39;hello\n&#39;
b&#39;hello\n&#39;
</code></pre>
<p>这适用于所有的管子（<code>process</code>、<code>remote</code>等），也适用于类似管子的东西（如<code>gdb.attach</code>和<code>gdb.debug</code>）以及其他许多例程。</p>
<p>例如，如果你想确切地看到一些shellcode是如何组装的。</p>
<pre><code>&gt;&gt;&gt; asm(&#39;nop&#39;, log_level=&#39;debug&#39;)
[DEBUG] cpp -C -nostdinc -undef -P -I/home/user/pwntools/pwnlib/data/includes /dev/stdin
[DEBUG] Assembling
    .section .shellcode,&quot;awx&quot;
    .global _start
    .global __start
    _start:
    __start:
    .intel_syntax noprefix
    nop
[DEBUG] /usr/bin/x86_64-linux-gnu-as -32 -o /tmp/user/pwn-asm-0yy12n6i/step2 /tmp/user/pwn-asm-0yy12n6i/step1
[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/user/pwn-asm-0yy12n6i/step3 /tmp/user/pwn-asm-0yy12n6i/step4
b&#39;\x90&#39;
</code></pre>
<h3 id="12-5-范围"><a href="#12-5-范围" class="headerlink" title="12.5 范围"></a>12.5 范围</h3><p>有时你希望所有的日志都被启用，但只针对部分漏洞脚本。你可以手动切换<code>context.log_level</code>，或者你可以使用一个范围内的助手。</p>
<pre><code>io = process(...)
with context.local(log_level=&#39;debug&#39;):
    # Things inside the &#39;with&#39; block are logged verbosely
    io.recvall()
</code></pre>

    </div>
     
    <div class="post-footer__meta"><p>updated at 2023-05-11</p></div> 
    <div class="post-entry__tags"><a href="/tags/pwn/" class="post-tags__link button"># pwn</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
        </div>
        <div class="nav__next">
            
                <a href="/2023/05/11/pwntools/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            pwntools
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
    
        <span id="leancloud_container_site_uv" hidden>
            <span>总访问人</span>
            <span id="leancloud_value_site_uv"></span>
            <span></span>
            
                <span> </span>
            
        </span>
    
    
        <span id="leancloud_container_site_pv" hidden>
            <span>总访问量</span>
            <span id="leancloud_value_site_pv"></span>
            <span></span>
            
                <span> </span>
            
        </span>
    

     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2023 <a href="/">Gwoo</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 



 



 


    
    <script>
        (function () {
            function getRecord(Counter, target) {
                return new Promise(function (resolve, reject) {
                    Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
                        .then(response => response.json())
                        .then(({results}) => {
                            if (results && results.length > 0) {
                                var record = results[0];
                                resolve(record);
                            } else {
                                Counter('post', '/classes/Counter', {
                                        target, time: 0
                                    })
                                    .then(response => response.json())
                                    .then(record => {
                                        resolve(record);
                                    }).catch(error => {
                                        console.error('Failed to create', error);
                                        reject(error);
                                    });
                            }
                        }).catch(error => {
                            console.error('LeanCloud Counter Error', error);
                            reject(error);
                        });
                })
            }
        
            function buildIncrement(objectId) {
                return {
                    "method": "PUT",
                    "path": `/1.1/classes/Counter/${ objectId }`,
                    "body": {
                        "time": {
                            '__op': 'Increment',
                            'amount': 1
                        }
                    }
                }
            }
        
            function increment(Counter, incrArr) {
                return new Promise(function (resolve, reject) {
                    Counter('post', '/batch', {
                        "requests": incrArr
                    }).then((res) => {
                        resolve(res);
                    }).catch(error => {
                        console.error('Failed to save visitor count', error);
                        reject(error);
                    });
                });
            }
        
            function validUV() {
                var key = 'LeanCloud_UV_Flag';
                var flag = localStorage.getItem(key);
                if (flag) {
                    if (new Date().getTime() - parseInt(flag) <= 86400000) {
                        return false;
                    }
                }
                localStorage.setItem(key, new Date().getTime().toString());
                return true;
            }
        
            function addCount(Counter) {
                var enableIncr = 'leancloud' === 'leancloud';
                var getterArr = [];
                var incrArr = [];
                var pvCtn = document.querySelector('#leancloud_container_site_pv');
                if (pvCtn || enableIncr) {
                    var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
                        incrArr.push(buildIncrement(record.objectId))
                        var ele = document.querySelector('#leancloud_value_site_pv');
                        if (ele) {
                            ele.innerText = record.time + 1;
                            if (pvCtn) {
                                pvCtn.style.display = 'inline';
                            }
                        }
                    });
                    getterArr.push(pvGetter);
                }
                var uvCtn = document.querySelector('#leancloud_container_site_uv');
                if (uvCtn || enableIncr) {
                    var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
                        var vuv = validUV();
                        vuv && incrArr.push(buildIncrement(record.objectId))
                        var ele = document.querySelector('#leancloud_value_site_uv');
                        if (ele) {
                            ele.innerText = record.time + (vuv ? 1 : 0);
                            if (uvCtn) {
                                uvCtn.style.display = 'inline';
                            }
                        }
                    });
                    getterArr.push(uvGetter);
                }
                if ('true' === 'true') {
                    var viewCtn = document.querySelector('#leancloud_container_page_pv');
                    if (viewCtn || enableIncr) {
                        var target = decodeURI('/2023/05/11/IDA/');
                        var viewGetter = getRecord(Counter, target).then((record) => {
                            incrArr.push(buildIncrement(record.objectId))
                            if (viewCtn) {
                                var ele = document.querySelector('#leancloud_value_page_pv');
                                if (ele) {
                                    ele.innerText = (record.time || 0) + 1;
                                    viewCtn.style.display = 'inline';
                                }
                            }
                        });
                        getterArr.push(viewGetter);
                    }
                }
                if (enableIncr) {
                    Promise.all(getterArr).then(() => {
                        incrArr.length > 0 && increment(Counter, incrArr);
                    })
                }
            }
        
            var app_id = 'bJN1qKDryqdQMB2GyyxMcO8b-gzGzoHsz';
            var app_key = 'J2HWpTbi7MLIsrnuJaALYcw2';
            var server_url = '';
        
            function fetchData(api_server) {
                var Counter = (method, url, data) => {
                    return fetch(`${ api_server }/1.1${ url }`, {
                        method,
                        headers: {
                                'X-LC-Id': app_id,
                                'X-LC-Key': app_key,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(data)
                    });
                };
                addCount(Counter);
            }
            var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
            if (api_server) {
                fetchData(api_server);
            } else {
                fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
                    .then(response => response.json())
                    .then(({api_server}) => {
                        fetchData('https://' + api_server);
                    });
            }
        })();
    </script>

 

 

 

 

 

 




    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
