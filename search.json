[{"title":"hw","date":"2023-05-28T13:17:22.000Z","url":"/2023/05/28/hw/","categories":[[" ",""]],"content":"蓝队知识溯源如果挂了代理怎么做 收集信息—-获取代理服务器的日志 分析信息 尝试联系代理服务器的管理员 进一步溯源 Nginx的日志放在哪里？如何进行分析？ 配置文件 访问日志 和 错误日志 分析 access_log 分析 error_log 护网中用到的安全设备了解过吗？ cookie和session的原理。哪个更安全？ 如果有一个webshell已经被上传,如何排查webshell是如何上传的,有什么思路? 全面扫描 手动全面查杀 分析应用日志，中间件日志，系统日志等。 使用流量设备定位webshell 网络设备有使用过吗,防火墙,路由器,交换机 交换机负责连接设备 路由器负责连接网络 防火墙负责网络访问限制 态势感知 蓝队常用的反制方法 蜜罐 对攻击目标反渗透（IP定位、端口扫描、web站点渗透） 应用漏洞挖掘与利用（菜刀、Goby、Xray、蚁剑） id–&gt;社交特征关联 钓鱼网站–&gt;后台扫描、xss盲打 木马文件–&gt;同源样本关联–&gt;敏感字符串特征检测 溯源反制方法 安全设备报价 日志与流量分析 服务器资源异常 邮件钓鱼 蜜罐系统 如何区分扫描流量和手动流量？ 查看流量来源 检测流量频率和规律 观察流量的请求路径和参数 分析流量的响应状态码和长度 普通的加固手段 更新补丁 强化口令策略 加强身份验证 安装防病毒软件 关闭不必要的服务 限制访问权限 数据备份与恢复 研判的思路 首先对攻击的来源进行判断 是内对内，外对内还是内对外的情况。 依据设备的告警信息结合具体情况来分析攻击行为的类型 然后就是根据攻击特征来分析攻击行为使用了什么技术或者说工具 比如说攻击的频率，数据包的信息等等。同使结合告警信息和具体情况来判断攻击行为的危害程度，比如说检测到多条攻击成功告警和内对内及内对外攻击告警，这个时候就需要尽快的交给应急组了。 结合设备告警信息及具体情况分析攻击意图 比如说攻击者的目标是主站还是旁站，是主机还是域控，不同的攻击意图对于后续的处理也不同。 最后根据我们掌握的信息采取相应的处置方式 应急响应的基本思路是什么？ 收集信息 收集告警信息、客户反馈信息、设备主机信息等 判断类型 控制范围 分析研判 处置 输出报告 应急排查 自动化查杀 手动排查 检查异常端口和进程 启动项排查 windows应急排查 系统账号排查（通过本地用户组去可疑账号、隐藏账号，有的话就删除） 事件管理器检测登陆日志，用微软的Log parser导出后分析 可疑端口，建立的链接，排查他对应的进程，用微软的msinfo32查看进程的路径和签名是否可疑 后门排查：（权限位置：一个进程杀掉了，过段时间重新派生） Linux应急排查 和windows应急思路相同，登陆账号检测 后门排查（检测定时任务、开机启动项、异常端口、进程排查）update留意系统运行到现在登陆多久、多少用户 影子账户，/etc/shadow/因为/etc/passwd任何用户都可疑访问，密码信息就分离到shadow,shadow文件只有root权限才能访问，如果说，stat命令发现，shodow文件选项变化了，这检测就有问题 SSH公钥，linux的机子22端口基本都是开的，如果写公钥进去，就是明显的后门 木马驻留系统的方式有哪些？ 注册表 服务 启动目录 计划任务 关联文件类型 常用的威胁情报平台有哪些？ name site Viurstotal virustotal.com 微步威胁情报中心 x.threatbook.cn 360威胁情报中心 ti.360.cn 奇安信威胁情报中心 ti.qianxin.com 绿盟威胁情报中心 nti.nsfocus.com 安恒威胁情报中心 ti.dbappsecurity.com.cn VenuseEye威胁情报中心 venuseye.com.cn 常用的webshell检测工具有哪些？ D盾 河马webshell 百度webdir+ web shell detector sangfor webshellkill [深信服] php malware finder [支持linux] 基础知识如何识别CDN 使用nslookup进行查询，看返回的域名解析情况 超级ping工具查看IP结果 如何手动判断靶标站点是windows/linux？ 大小写检测：windows大小写步敏感，而linux大小写敏感 ping指令：根据返回的TTL值，windows一般情况下&gt;100，linux一般情况下&lt;100 无法连接3389服务器的几种情况？ 3389端口处于关闭状态 远程桌面默认端口号已被更改 防火墙/杀软拦截 处于内网环境 超过了服务器的最大连接数管理员设置了权限，指定用户才能通过3389端口进行访问 为什么mysql的站点无法访问 站库分离 3306端口未对外开放 管理员修改了mysql的默认端口 管理员限制之特定IP访问 正向shell和反向shell的区别是什么？ 正向shell 攻击者连接被攻击者，用于攻击者处于内网，被攻击者处于外网 反向shell 被攻击者连接攻击者，用于攻击者处于外网，被攻击者处于内网 正向代理和反向代理的区别是什么？ 正向代理 是一个位于客户端和目标服务器之间的服务器（代理服务器），为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端 反向代理 是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器 总结 正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。 正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。 正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。 正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、 安全防护等作用。二者均能提高访问速度。 Socks协议走的是tcp，不支持icmp，所以不能pingmysql的用户名密码是存放在哪张表里面 mysql密码采用的哪种加密方式蚁剑/菜刀/c刀/冰蝎的相同与不相同之处 相同 都是用来连接webshell的工具 不同 不同于其他三款，冰蝎有流量动态加密 web打点外网大点基本流程靶标确认，信息收集，漏洞挖掘，漏洞利用，权限提升，横向移动，最终目标是为了获得靶标的系统权限/关键信息 在外网打点最重要的就是信息收集，掌握目标机器的情报越多，后续就可疑尝试越多的攻击方式进行打点。如钓鱼邮件、web漏洞、边界网络哦设备漏洞、弱口令等。 如果在web层面找不到哦可疑利用的漏洞，可以尝试社会工程学攻击，比如钓鱼，近源渗透等方式 常用的渗透工具 信息收集类 网页 程序 Fofa Oneforall Zoomeye 0.zone 外网打点常用的工具 name intro ENScan 企业信息查询工具 Oneforall 子域名收集工具 水泽 信息收集自动化工具 Fofa,Zoomey,0.zone,Goby 网络空间资产检索/攻击面测绘工具 Masscan,nmap,rustscan 端口扫描工具 ARL 资产安全灯塔，快速侦察与目标关联的资产工具 常见未授权漏洞有哪些？ MongoDB 未授权访问漏洞 Redis 未授权访问漏洞 Memcached 未授权访问漏洞 CVE-2013-7239 JBOSS 未授权访问漏洞 VNC 未授权访问漏洞 Docker 未授权访问漏洞 ZooKeeper 未授权访问漏洞 Rsync 未授权访问漏洞 常见的中间件有哪些？他们有哪些漏洞？ IIS 解析漏洞、PUT漏洞、短文件名猜解、远程代码执行（MS15-034、RCE-CVE-2017-7269） Apache 解析漏洞、目录遍历 Nginx 文件解析、目录遍历，CRLF注入、目录超越 tomcat 反序列化漏洞、任意文件写入、弱口令破解+后门getshell、war后们文件部署 JBoss 反序列化漏洞、war后门文件部署、Administration Console 弱口令 Weblogic 反序列化漏洞（cve-2023-21839）、弱口令破解+后门getshell、ssrf任意文件上传、war后门文件部署 apache shiro反序列化 shiro-550（shiro rememberMe）、shiro-721（shiro padding oracle attack） XSS如何配合组合拳进行getshell？ XSS配合CSRF组合拳 XSS配合钓鱼页面 利用XSS进行水坑攻击 怎么通过SSRF拿shell可以借助gopher协议探测内网的web服务sql注入，直接在url后门拼接内网的地址，后面加上sql注入语句就行 Web top 10漏洞有哪些？ Sql注入漏洞 失效的身份认证 敏感数据泄露 XML外部实体 无效的访问控制 安全配置错误 跨站脚本（xss） 不安全的反序列化 使用含有已知漏洞的组件漏洞 日志记录和监控不足导致的风险 打点一般会用什么漏洞打点一般会选择比较常见的nday，比如shiro，fastjson，weblogic，spring等反序列化漏洞，还有一些oa管理系统nday，还有最近才出的比较新1day，0day 拿到webshell不出网情况下怎么办reg上传去正向连接。探测出网协议，如dns，icmp，smb，然后再根据出网的协议上线cs 工具sqlmapsqlmap -u “url（网站）” 查询是否存在注入点 --dbs [检测站点有那些数据库 ] --current-db [检测当前使用的数据库名 ] --tables -D “db_name” [列出指定数据库的所有表名,-D后面接数据库名称] --columns -T “table_name” -D “db_name” [列出指定数据库中指定数据表的列(字段)] --dump -C “columns_name” -T “table_name” -D “db_name”i [列出数据表中的行（内容）] 常用指令| 指令 | 作用 || :—- | :—– || --purge | 重新扫描，会删除原先扫描记录 || --tables | 获取表名 || --dbs | 检测站点包含哪些数据库 || --current-db | 获取当前的数据库名 || --current-user | 检测当前用户 || --is-dba | 判断站点的当前用户是否为数据库管理员 || --batch | 默认确认，不询问你是否输入 || --search | 后面跟参数 -D -T -C搜索列（C），表（T）和数据库名称（D） || --threads 10 | 线程，参数后空格接数字，sqlmap线程最高设置为10 || --level 3 | sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5 || --risk 3 | 执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全 || --privileges | 查看权限 || --proxy “目标地址″ | 使用代理注入 | Nmap -sS （TCP SYN扫描）：速度快，不易被防火墙发现。 -sA （TCP ACK扫描）：速度快，不易被防火墙发现，但是无法判断端口是否开放。 -sT：会获取存活的IP地址、开放的端口，但是这种方法会在主机中留下大量的日志文件 -Pn：可以穿透防火墙进行扫描 -O：操作系统探测 -sV：查看目标主机的版本信息，还可以借助-A选项进行操作系统探测和版本探测 -Pn：可以穿透防火墙进行扫描 -sn：只对主机进行扫描，不进行端口扫描 Web 漏洞sql注入漏洞原理攻击者的输入被当成sql语句执行 xss漏洞原理攻击者将恶意的代码插入到网页中，正常用户浏览该页面时，恶意的代码就会执行 文件上传漏洞原理攻击者将恶意的代码文件上传到服务器 SSRF漏洞原理攻击者构造恶意请求借助服务端实现访问其本无权访问的URL。 XXE漏洞原理攻击者构造一个带有恶意外部实体的XML请求，发送到服务端。当服务端解析该XML请求时，恶意外部实体会被解析器识别并执行，从而导致攻击者可以访问应用程序不应该公开的文件和数据。"},{"title":"IDA","date":"2023-05-11T13:09:36.000Z","url":"/2023/05/11/IDA/","tags":[["pwn","/tags/pwn/"]],"categories":[[" ",""]],"content":"转自: 学习逆向工程需要熟悉一个反汇编器的使用，学会阅读汇编语言，学会编写脚本和查找资料 IDA是功能很强大的一款反汇编机器，本文保姆级讲解了IDA的基本使用 目录 序言 IDA Pro简介 IDA的基本用法 ida文件加载 IDA桌面简介 导航带 反汇编窗口 函数窗口 十六进制窗口 Hex view 结构体窗口 枚举窗口 Strings窗口 Names窗口 ACDU 交叉引用 概念 代码交叉引用（函数调用，顺序执行和跳转） 数据数据交叉引用 访问交叉引用列表 IDA静态分析 名称 修改参数，局部变量，函数名称 修改地址的名称 重命名寄存器 IDA注释 函数操作 新建函数 删除函数 代码和数据的相互转换 字符串 指定数组 显示汇编语言对应的机器码 打补丁 Patch 修改exe文件并保存运行 IDA脚本 脚本的使用方式和IDC语法 IDA插件 概念 构建插件 安装插件 插件配置 IDAPython IDA动态调试 调试器通常用于执行以下两种任务（大概了解） 开始动态调试 进程控制 断点 软件断点 硬件断点 跟踪 寄存器变量 监视 IDA的拓展用法 IDA的第三方图形 外部流程图 外部调用图 外部交叉引用图 序言 It was the best of times,it was the worst of times,it was the age of wisdom,it was the age of foolishness,it was the epoch of belief,it was the epoch of incredulity. it was the season of Light,it was the season of Darkness,it was the spring of hope,it was the winter of despair,we had everything before us,we had nothing before us. we were all going direct to Heaven,we were all going direct the other way. ** ——A Tale of Two Cities** 今天，万物互联，普适计算。整个世界的构造都由程序操纵起来。 A handful of people working at a handful of tech companies steer the thoughts of billions of people every day. 你可曾听过赛博朋克这个词，科幻作家布鲁斯·博斯克创造了这个词。 赛博朋克Cyberpunk是由网络Cyber和朋克Punk组成。 而cyber的词源是控制论cybernetics，是20世纪重要的思想运动。 punk则代表着治理与反叛两个概念的纠缠。 科幻作家布鲁斯·博斯克创造了“赛博朋克”,并把该名设定为自己短篇小说的名字，形容迷失的年轻一代：他们是抗拒父母的权威、与主流社会格格不入、利用电脑技术钻漏洞和制造麻烦的技术宅。经典的赛博朋克角色是边缘且性格疏远的独行者。 赛博朋克深受科幻作者的喜爱，很成功的电影作品有《黑客帝国》。 赛博朋克类小说中的世界是反乌托邦式的，涉及日常生活受到急剧改变的科技影响，普及的计算机化信息笼罩全球，以及侵入性的人体改造。在赛博朋克的作品中，一边是闪烁着霓虹灯光的摩天大楼，富人们在此享受生活，但在阴暗的角落里，到处是黑帮、流氓、抢劫犯的身影，穷人们只能靠电子产品来麻痹自己。闪烁的霓虹灯和摩天大楼上五彩斑斓的大屏幕，让人联想到了《三体》中的超信息时代。 赛博朋克有时也专指这种视觉美学风格。 Hacker ，这个词是用来形容那些热衷于解决问题、克服限制的人。 他们是崇尚自由的，乐于追根究底、穷究问题的特质。 从广义上来说，任何职业都可以成为Hacker 。你可以是一个木匠黑客。不一定是高科技。只要与技能有关，并且倾心专注于你正在做的事情，你就可能成为黑客。 Hacker有别于Cracker，真正的Hacker遵守黑客守则，不破坏任何系统。 时代是朝前走的，发展不是情怀的敌人，相反，只有发展才会给情怀创造基础。 ** ——人民日报** IDA是一个功能强大的反汇编器，学习逆向有别于按照一个框架去编写程序，需要灵活的头脑和痴迷于逆向分析的精神。你是在玩解密游戏而不是去建造一座大厦。 本文是将最核心的IDA的使用做了一个总结，删去了为了逻辑严密，内容全面的教科书式的讲解，只总结最和核心有用的实际操作，并且详细配置了图片，对于一些动态调试的具体内容，后续会有专门的博客，将链接贴在这篇文章中，希望大家在阅读完这篇文章之后就能上手使用IDA。 开始阅读核心部分吧 IDA Pro简介IDA Pro就是一款递归下降反汇编器 反汇编器使用的算法包括：线性扫描反汇编算法、递归下降反汇编算法 IDA并非一款免费软件，为用户提供了一款功能有限的免费版本，不提供最新版本的功能 百度词条： 交互式反汇编器专业版（Interactive Disassembler Professional），人们常称其为IDA Pro，或简称为IDA。是最棒的一个静态反编译软件，为众多0day世界的成员和ShellCode安全分析人士不可缺少的利器！IDA Pro是一款交互式的，可编程的，可扩展的，多处理器的，交叉Windows或Linux WinCE MacOS平台主机来分析程序， 被公认为最好的花钱可以买到的逆向工程利器。IDA Pro已经成为事实上的分析敌意代码的标准并让其自身迅速成为攻击研究领域的重要工具。它支持数十种CPU指令集其中包括Intel x86，x64，MIPS，PowerPC，ARM，Z80，68000，c8051等等。 IDA的基本用法这一段介绍IDA最基本的界面信息和最基础的操作 ida文件加载可以打开IDA-&gt;菜单栏file-&gt;open（选择一个二进制文件） 也可以将要分析的二进制文件拖到ida图标上 IDA桌面简介你看过有关黑客的视频吗，一台性能很高的电脑上下着绿色的字符串雨，黑客盯紧屏幕检索其中的关键信息。 当然这是有一定艺术化处理的，不一定都是绿色的界面。当然你可以根据自己的喜好配置成这样。但是有一点是肯定的，IDA的有关操作需要你查看很多界面，有很多不同的信息需要你整合分析。涉及栈，反汇编代码，反编译代码，程序中包含的字符串等等很多有关需要逆向分析的程序的信息。资深搞逆向工作可以考虑准备一台很大的显示屏。 下面我们来认识一下IDA的这些窗口（View）。 导航带 概况导航栏，也叫作导航带，光标悬停在导航带任何位置会指出其在二进制文件中的位置 Options-color可以修改导航栏的颜色 反汇编窗口 上图是图形视图，按空格键可以和文本视图相互切换，下图是文本视图 .text:004028EE为区域名称加虚拟地址 图中.text是代码段 Ctrl+“+”可以或者Ctrl加鼠标滚轮实现界面的缩放 views-&gt;open subviews-&gt;Disassembly可以打开另一个反汇编窗口，每个反汇编窗口互相独立，可以一个查看图形，另一个查看文本 IDA使用不同的箭头颜色来表示不同的流 条件跳转Yes是绿色箭头，No是红色箭头，默认为蓝色箭头 文本窗口右边是箭头窗口 用于描述非线性流程 ，虚线是条件跳转，实线是非条件跳转 粗实线表示程序将控制权交给程序中的以前的某个地址，通常表示程序中存在循环 是反汇编形成的汇编语言代码 按下“；”可以添加注释，用于逆向分析时使用 图中 ; CODE XREF: _main+209↑j是自动生成的表示此处有交叉引用的注释 _main+209↑j表示一个地址，形式是函数+偏移量，↑表示该地址在上面 交叉引用暂不做介绍 图形视图可以用鼠标滚轮加Ctrl进行拖动，进行缩放 有时我们需要用缩小的抽象图片来观察程序执行流程的一些特点 函数窗口 为 IDA在数据库中识别的每一个函数，双击一个函数，会跳转到反汇编窗口这个函数所在的位置 十六进制窗口Hex view 显示的是程序内容和列表的标准十六进制代码 每行十六个字节 还会显示对应的ASCII字符（！！！所以有时string窗口显示的字符串不好查看时，可以打开Hex view查看） 右键-&gt;Sychronize with可以选择时是否与某个反汇编窗口相互关联，关联后，两个窗口会同时改变位置 结构体窗口 显示二进制文件中使用的任何复杂的数据结构（C结构体和联合） 使用： 为标准数据结构的布局提供现成的参考 为你提供一种方法，发现程序使用的自定义数据结构时，帮助你创建自己的，可用作内存布局的数据结构 枚举窗口 显示检测到的标准枚举数据类型（C enum) 可以自定义枚举类型 Strings窗口views-&gt;open subviews-&gt;Strings打开窗口 显示的是从二进制文件中提取出来的一组字符串，以及字符串所在的地址 从中可以查找程序中使用的字符串（有时也可以用Hex view查勘字符串，但是一般在string窗口中检索想要的关键字符串） 与交叉引用相结合可以快速定位字符串，跟踪到程序中引用这个字符串的位置 Names窗口 显示全局名称 名称是指对一个程序虚拟地址的符号引用 F常规函数 L库函数 I导入的名称 C命名代码 D数据 A字符串数据 ACDU反汇编的代码并不是完美的，需要手动进行调试 ACDU可以将一段数据类型转化成代码（C)，数据（D)，未定义的二进制数据（U)，字符（A) 例如： 选择一段数据，按下A 交叉引用文件中存储的一些数据，我们知道计算机是存储程序式结构，代码部分会对数据进行操作，使用IDA的交叉引用可以查看对于一个地址处的数据被哪些地方的代码进行了引用 我们就可以根据一个数据进行跟踪 概念交叉引用是一个地址引用一个地址 根据图论的知识，可以把地址看成节点，把交叉引用看成边 分为代码交叉引用和数据交叉引用 代码交叉引用（函数调用，顺序执行和跳转）三种基本的流 普通流，跳转流，调用流 普通流：就是顺序执行，默认执行流，执行紧跟在后面的指令 跳转流：无条件分支和条件分支分配到一跳转流，注释中出现j后缀 调用流：调用一个函数使用调用流，使用后缀p 数据数据交叉引用读取交叉引用：访问某个内存位置 写入交叉引用：写入内内存 偏移量交叉引用：引用某个位置的地址 访问交叉引用列表将光标放在指定位置 指定位置Ctrl+X 指定位置Views-&gt;Open Subviews-&gt;Cross—References 双击一个位置就可以跳转到这个位置 IDA静态分析静态分析，就是根据反汇编器生成的结果，在不运行这个程序的情况下，逆向分析这个程序的运行过程。 当然反汇编器是机械的根据算法来生成反汇编代码，而逆向和防止逆向是相互竞争的，为了防止逆向，机器代码掺杂了脏字节之类的东西，导致反汇编算法不能正确分析，这是也需要我们手动来调整。而且反汇编生成的代码的变量没有任何实际意义，当我们分析清楚其功能的时候，可以重命名。也可以加注释辅助逆向分析。 名称IDA会自动生成生成与虚拟地址和与栈帧变量有关的名称，这些名称不能帮助我们认识位置和变量的用途，称为哑名 IDA可以修改名称 修改参数，局部变量，函数名称按快捷键N可以将光标位置的变量，函数重命名，输入一个空名称IDA会生成默认名称 修改地址的名称按快捷键N将光标位置的地址重命名 重命名寄存器按快捷键N将光标位置的寄存器重命名 当编译器将变量分配在寄存器中，而不是程序栈上时 为了更好地引用这个变量，需要重命名寄存器 IDA注释 使用“：”，或者“；”快捷键 函数操作新建函数 添加一个手动分析，IDA没有分析出来的函数 删除函数 删除一个认为IDA分析错误的函数 代码和数据的相互转换 使用快捷键ACDU 字符串IDA能是识别大量的字符串格式，默认会搜索并格式化成C风格 可以切换字符串格式 指定数组IDA生成的反汇编代码很少提供数组大小的信息 只有数组第一个元素被引用 要生成一个便于分析的数组需要手动创建 选择数组第一个元素，菜单栏选择Edit-&gt;Array 创建数组的时候，确保将数组中的第一个元素的大小更改为适当的值，从而为数组的元素选择适当的大小 显示汇编语言对应的机器码 选中这部分汇编代码 将Number of opcode bytes改为10，OK 打补丁PatchPatch就是打补丁，什么是打补丁，就是修改汇编代码 选中汇编代码 Chang bytes可以修改汇编语言对应的机器码 Assemble instruction可以修改汇编指令 修改exe文件并保存运行按照上述操作进行修改之后，我们修改的信息存在了数据库中 exe文件是不会修改的，若我们想得到修改后的一个exe文件 ，进行下面的操作 IDA脚本脚本可以帮助我们完成很多重复的工作，IDA的脚本是针对IDA的工作的脚本。 脚本语言又被称为扩建的语言, 或者动态语言, 是一种编程语言, 用来控制软件应用程序。 脚本的使用方式和IDC语法脚本是什么 英文是Script，就是脚本，剧本的意思 就是我们可以将一些IDA的操作写在一个程序里面，让这个脚本程序运行这些操作，按照你定义的剧本让这个IDA运转 比如批量修改内存中的数据，批量打印内存中数据等等都需要脚本，人工一个一个修改或提取很麻烦 当对IDA的最基本操作有了解之后，我们可以尝试编写脚本来方便我们的工作 速成IDC语法看下面这一篇 IDC语法 了解更多看这一篇 IDA脚本 IDA插件 概念IDA插件是经过编译的，功能更加强大的IDC脚本 通常和热键，菜单关联 插件可能是通用的 处理各种二进制文件或者提供各种处理器体系结构使用 构建插件插件在Windows上是有效的DLL文件，扩展名为.plx,.pmc,.plx64,lmc64 安装插件将编译好的插件模块复制到plugins目录当中 Windows不能覆写一个正在使用的可执行文件，安装一个插件必须确保IDA卸载了旧版本的插件 插件配置配置插件通过/plugins/plugins.cfg文件中的设置 存有插件的如下信息 插件的一个备选菜单说明，这个值重写插件的want_name数据成员 插件的一个非标准存储位置或文件扩展名。默认情况下，IDA在/plugins下搜索插件，期待插件拥有一个默认的，特定于平台的文件扩展名 插件的热键 供调试器可选DEBUG标志 IDAPythonIDAPython最初由Gergely Erdelyi和Ero Carrera在2004年合作开发，目的是取代IDA自带的idc脚本引擎，提供更强大的扩展能力和自动化分析能力。 受到IDA用户的普遍欢迎。是一个开源项目，可以下载该插件。对其进行修改。 IDAPython信息 存放IDAPython的github网址 IDA动态调试有时候程序在运行过程中会生成一些关键的数值，而人力通过静态分析的结果模拟程序的运行来推出这些中间的数值可能很麻烦。简单重复的工作是计算机所擅长的而不是人，所以我们可以让这个程序运行起来，得到这些中间过程的数值。这就是动态调试。 调试器通常用于执行以下两种任务（大概了解）分析与已崩溃进程有关的内存映像，以一种完全受控的方式执行进程 调试会话以一个接受调试的进程为起点 大多数调试器能够依附在一个正在进行的进程上 选择一个进程之后，调试器将捕获该进程的内存快照，以此创建一个临时数据库。除这个正在运行进程的内存映像之外，临时数据库中还包含该进程加载的所有共享库，这使得这个数据库比我们常见的数据库要复杂得多 开始动态调试1.Debugger-&gt;Select Debugger 或按快捷键F9 使用EXE文件可以使用Local Windows Debugger 如果是ELF文件应该放在Linux上用远程调试IDA动态调试ELF文件_光无影的博客-CSDN博客 2.Debuugger-&gt;Start Process 或者F9开始调试 3.IDA将显示警告信息 选择Yes,选择No会退出 进程控制调试器的功能是能严密监控并修改它所调试的进程的行为 所以有一些调试的命令 Continue 继续执行一个暂停的进程。执行将继续，直到遇到一个断点暂停 F9 Pause 暂停一个正在运行的进程 使用工具栏按钮 Terminate 终止一个正在运行的进程 Step into 执行下一条指令，如果下一条是函数调用，就进入函数第一条 F7 Step over 执行下一条指令 如果下一条是一个函数调用，会跨过 F8 Run Until Return 执行当前函数到返回 Ctrl+F7 Run to Cursor 执行进程，直到执行到达当前的光标位置 F9 断点软件断点调试时候执行到设置断点的位置会中断 指定位置F2快捷键设置断点 断点处红色显示 IDA调试器支持硬件断点和条件断点 硬件断点 在一个选定的断点处右击 选Hareware，按照需求选择读写或者执行断点，一般打在数据区域 跟踪Debugger-&gt;Tracing-&gt;Tracing Options 寄存器变量提供了一些特殊的寄存器，用于直接访问断点表达式中寄存器的内容 只有在调试器激活的时候才能使用寄存器变量 监视可以持续监视一个或几个变量的值，不需要每次进程暂停后导航到相关内存的位置 显示监视列表 IDA的拓展用法IDA的第三方图形外部流程图Views-&gt;Graphs-&gt;Flow Chart 外部调用图Views-&gt;Graphs-&gt;Function Calls 显示函数调用的层次结构 外部交叉引用图Views-&gt;Graphs-&gt;Xrefs From Now, you can try to do some really interesting things with IDA. Come! Let’s act. Author：ZERO-A-ONE Date：2022-02-24 本文翻译自：[pwntools]()-tutorial，主要是考虑到目前中文互联网中关于系统介绍pwntools使用方法的文章都比较老和杂乱，且转换为Python3后又有许多零零散散的问题，看到这个仓库中包含了很多使用技巧和调试问题的解决方案，感到可以翻译一下 这个资源库包含了一些开始使用pwntools（和pwntools）的基本教程。 这些教程并不致力于解释逆向工程或利用，而是假定读者有这方面的知识。 一、简介Pwntools是一个工具包，使选手们在CTF期间的尽可能容易的编写EXP，并使EXP尽可能的容易阅读。 有些代码每个人都写过无数次，而且每个人都有自己的方法。Pwntools的目标是以半标准的方式提供所有这些，这样你就可以停止复制粘贴相同的struct.unpack(&#39;&gt;I&#39;, x)代码，而是使用更多稍微清晰的包装器，如pack或p32甚至p64(..., endian=&#39;big&#39;, sign=True)。 除了对日常的功能进行方便的包装外，它还提供了一套非常丰富的IO管道，将所有你曾经执行过的IO封装在一个统一的界面中。从本地攻击切换到远程攻击，或者通过SSH进行本地攻击，都只是修改一行代码的工作。 最后但并非最不重要的是，它还包括一系列用于中级到高级使用情况的开发协助工具。这些工具包括给定内存泄露基元的远程符号解析（MemLeak和DynELF），ELF解析和修补（ELF），以及ROP小工具发现和调用链构建（ROP）。 二、目录 Installing Pwntools Tubes Basic Tubes Interactive Shells Processes Networking Secure Shell Serial Ports Utility Encoding and Hashing Packing / unpacking integers Pattern generation Safe evaluation Bytes vs. Strings Python2 Python3 Gotchas Context Architecture Endianness Log verbosity Timeout ELFs Reading and writing Patching Symbols Assembly Assembling shellcode Disassembling bytes Shellcraft library Constants Debugging Debugging local processes Breaking at the entry point Debugging shellcode ROP Dumping gadgets Searching for gadgets ROP stack generation Helper functions Logging Basic logging Log verbosity Progress spinners Leaking Remote Memory Declaring a leak function Leaking arbitrary memory Remote symbol resolution 三、安装Pwntools这个过程可以说是简单明了，Ubuntu 18.04和20.04是唯一 “官方支持 “的平台，因为它们是官方对软件进行自动化测试的唯二平台。 3.1 验证安装如果以下命令成功，一切都应该是OK的 3.2 其它架构如果你想为其它的架构组装或反汇编代码，你需要安装一个合适的binutils。对于Ubuntu和Mac OS X用户，安装说明可在docs.pwntools.com上找到。 四、管道管道是方便高校的I/O包装器，里面包含了你需要执行的大多数类型的I/O。 Local processes Remote TCP or UDP connections Processes running on a remote server over SSH Serial port I/O 本介绍提供了一些所提供功能的例子，但更复杂的组合是可能的。关于如何进行正则表达式匹配，以及将管道连接在一起的更多信息，请参阅完整的文档。 4.1 基础IO下面介绍一些IO中的基本功能： 接收数据 recv(n) - 接收任何数量的可用字节 recvline() - 接收数据，直到遇到换行 recvuntil(delim) - 接收数据，直到找到一个分隔符 recvregex(pattern) - 接收数据，直到满足一个与pattern重合的内容为止 recvrepeat(timeout) - 继续接收数据，直到发生超时 clean() - 丢弃所有缓冲的数据 发送数据 send(data) - 发送数据 sendline(line) - 发送数据加一个换行 操作整数 pack(int) - 打包发送一个字（word）大小的整数 unpack() - 接收并解包一个字（word）大小的整数 4.2 进程和基本功能为了创建一个与进程对话的管道，你只需创建一个进程对象并给它一个目标二进制的名字。 如果你需要提供命令行参数，或设置环境，可以使用额外的选项。更多信息请参见完整的文档。 读取二进制数据也不是一个问题。你可以用recv接收多达若干字节的数据，或者用recvn接受精确的字节数。 4.3 会话互动你在游戏服务器中获取了一个shell吗？赶快！互动地使用它是很容易的。 4.4 网络创建一个网络连接也很容易，而且有完全相同的接口。一个remote对象连接到其他地方，而一个listen对象则在等待连接。 如果你需要指定协议信息，也是很直接方便的。 侦听连接并没有多复杂。请注意，这正好是在监听一个连接，然后停止监听。 4.5 安全的ShellSSH连接也同样简单。可以将下面的代码与上面 “Hello Process “中的代码进行比较。 你还可以用SSH做更复杂的事情，如端口转发和文件上传/下载。更多信息请参见SSH教程。 4.6 串行端口如果你需要在本地进行一些黑客攻击，也有一个串行管道。一如既往，在完整的在线文档中有更多信息。 五、实用功能Pwntools大约有一半的内容是实用功能，这样你就不再需要到处复制粘贴这样的东西。 此外，你不仅得到了漂亮的小包装，作为额外的奖励，在阅读别人的漏洞代码时，一切都更清晰，更容易理解。 5.1 打包和解包整数这可能是你最常做的事情，所以它在最前面。主要的pack和unpack函数都知道context中的全局设置，如endian、bits和sign。 你也可以在函数调用中明确指定它们。 5.2 文件I/O只需调用一个函数，它就能做你想做的事。 5.3 哈希和编码能够快速的将你的数据转换成你需要的任何格式。 Base64 Hashes URL Encoding Hex Encoding Bit Manipulation and Hex Dumping Hex Dumping 5.4 样例生成样例生成是一种非常方便的方法，可以在不需要进行数学计算的情况下找到偏移量。 假设我们有一个直接的缓冲区溢出，我们生成一个样例并提供给目标应用程序。 在核心转储中，我们可能看到崩溃发生在0x61616178。我们可以不用对崩溃帧做任何分析，只需把这个数字打回去，得到一个偏移量。 六、Bytes vs. Strings当Pwntools最初（重新）编写时，大约在十年前，Python2是最受欢迎的。 多年来在Python中编写的许多EXP都假定str对象与bytes对象有1:1的映射，因为这是Python2上的工作原理。 在这一节中，我们讨论在Python3上编写EXP所需的一些变化，并阐述与Python2的对应关系。 6.1 Python2在Python2中，str类和bytes类是一样的，而且有一个1:1的映射。从来不需要对任何东西调用encode或decode – 文本就是字节，字节就是文本。 这对编写EXP来说是非常方便的，因为你只需写”\\x90\\x90\\x90\\x90 “就可以得到一个NOP滑块。Python2上所有的Pwntools管道和数据操作都支持字符串或字节。 从来没有人使用unicode对象来编写漏洞，所以unicode到字节的转换极其罕见。 6.2 Python3在 Python3 中，unicode类实际上就是str类。这有一些直接和明显的影响。 乍一看，Python3似乎让事情变得更难了，因为bytes声明的是单个的八位数（正如名字bytes所暗示的），而str用于任何基于文本的数据表示。 Pwntools花了很大力气来遵循 “最小惊喜原则”——也就是说，事情会按照你预期的方式进行。 然而，有时事情会出现一些故障。注意这里99f7e2如何被转换为c299c3b7c3a2。 这是因为文本字符串”\\x99\\xf7\\xe2 “被自动转换为UTF-8代码。这不可能是用户想要的。 作为解决方案，我们只需要以b为前缀： 好极了！ 一般来说，Python3上的Pwntools的修复方法是确保你所有的字符串都有一个b前缀。这就解决了歧义，并使一切变得简单明了。 6.3 麻烦关于Python3的bytes对象，有一个值得一提的 “麻烦”。当对它们进行迭代时，你会得到整数，而不是bytes对象。这是与Python2的巨大差异，也是一个主要的烦恼。 为了解决这个问题，我们建议使用切片，它产生长度为1bytes的对象。 七、环境context对象是一个全局的、线程感知的对象，包含了pwntools使用的各种设置。 一般来说，在一个EXP的首部，你会发现类似的东西： 这通知pwntools生成的shellcode将用于amd64，并且默认字大小为64位。 7.1 环境设置arch 目标架构。有效值是&quot;arch64&quot;、&quot;arm&quot;、&quot;i386&quot;、&quot;amd64&quot;，等等。默认是 &quot;i386&quot;。 第一次设置时，它会自动将默认的context.bits和context.endian设置为最可能的值。 bits 在目标二进制中，有多少位组成一个字，如32或64。 binary 从ELF文件中获取配置。例如：context.binary=&#39;/bin/sh&#39; log_file 将所有的日志输出送入的文件。 log_level 日志的详细程度。有效值是整数（越小越详细），以及&quot;debug&quot;、&quot;info &quot;和&quot;error &quot;等字符串值。 sign 设置整数打包/解包的是否有符号。默认为 &quot;unsigned&quot;。 terminal 用来打开新窗口的首选终端程序。默认情况下，使用x-terminal-emulator或tmux。 timeout 管道操作的默认超时范围。 update 一次设置多个值，例如context.update(arch=&#39;mips&#39;, bits=64, endian=&#39;big&#39;) 八、ELFsPwntools通过ELF类使与ELF文件的交互变得相对简单。你可以在RTD上找到完整的文档。 8.1 加载ELF文件ELF文件是按路径加载的。在被加载后，一些与安全有关的文件属性被打印出来。 8.2 使用符号表ELF文件有几组不同的符号表可用，每组都包含在&#123;name: data&#125;的字典中。 ELF.symbols 列出所有已知的符号，包括下面的符号。优先考虑PLT条目，而不是GOT条目。 ELF.got 只包含GOT表 ELF.plt 只包含PLT表 ELF.functions 只包含函数符号表（需要DWARF符号表） 这对于保持漏洞的稳健性非常有用，因为它消除了对硬编码地址的需要。 这将打印出类似下面的内容： 8.3 改变基本地址使用pwntools改变ELF文件的基址（比如为ASLR做调整）是非常直接和简单的。让我们改变bash的基址，看看所有的符号都有什么变化。 这应该打印出类似的内容： 8.4 读取ELF文件我们可以通过pwntools直接与ELF互动，就像它被加载到内存中一样，使用read、write和与packing模块中的函数命名相同。此外，你可以通过disasm方法看到反汇编。 打印出来的东西应该如下： 8.5 对ELF文件进行修补对ELF文件的修补也同样简单。 然后我们可以运行我们修改过的bash版本。 8.6 搜索ELF文件在编写EXP的时候，你经常需要找到一些字节序列。最常见的例子是搜索例如&quot;/bin/sh\\x00 &quot;的execve调用。search方法返回一个迭代器，允许你选择第一个结果，或者如果你需要一些特殊的东西（比如地址中没有坏字符），可以继续搜索。你可以选择传递一个writable参数给search，表示它应该只返回可写段的地址。 上面的例子打印的内容应该如下： 8.7 构建ELF文件通过pwntools我们可以很方便地从头开始创建一个ELF文件。所有这些功能都是上下文感知的。相关的函数是from_bytes和from_assembly。每一个都返回一个ELF对象，它可以很容易地被保存到文件中。 8.8 运行和调试ELF文件如果你有一个ELF对象，你可以直接运行或调试它。以下两个代码是等同的： 同样地，你可以启动一个调试器，并将其连接到ELF上。这在测试shellcode时是非常有用的，不需要用C语言包装器来加载和调试它。 九、汇编Pwntools使得用户在几乎所有的架构中进行汇编变得非常容易，并带有各种可以开箱即用已经生成好且依然可定制的shellcode。 在walkthrough目录中，有几个较长的shellcode教程。本页为您提供了基础知识。 9.1 基础汇编最基本的例子，是将汇编代码转换成shellcode。 9.2 现成的汇编（shellcraft）shellcraft模块会提供给你一些现成的汇编代码。它通常是可定制的。找出存在哪些shellcraft模板的最简单方法是查看RTD上的文档。 9.3 命令行工具有三个命令行工具用于与汇编进行交互。 asm disasm shellcraft asm asm工具的功能正如其名，它将汇编码转换为机器码，它为汇编指令输出的格式化提供了几个选项，当输出是一个终端时，它默认为十六进制编码。 当输出是其他东西时，它显示的是原始数据。 如果在命令行上没有提供指令，它将在stdin上获取数据。 最后，它支持一些不同的选项，通过--format选项来指定输出格式。支持的参数有raw、hex、string和elf。 disasm Disasm是asm的反义词，也就是将16进制的机器码反汇编成汇编指令。 shellcraft shellcraft命令是内部shellcraft模块的命令行接口。在命令行中，必须按arch.os.template的顺序指定完整的环境信息。 9.4 异构架构为其它非X86架构进行汇编交互，你需要自行安装适当版本的binutils。你应该看看installing.md以了解更多这方面的信息。我们唯一需要改变的是在全局环境变量中设置架构。你可以在 context.md 中看到更多关于context的信息。 9.4.1 现成汇编shellcraft模块会自动切换到相应的架构。 9.4.2 命令行工具你也可以通过使用--context命令行选项，使用命令行来汇编生成其它架构的shellcode。 十、调试Pwntools对在你的漏洞工作流程中使用调试器有丰富的支持，在开发EXP的问题出现时，调试器非常有用。 除了这里的调试资源外，你可能想通过以下项目来增强你的GDB经验： Pwndbg GDB Enhanced Features (GEF) 10.1 先前条件你的机器上应该同时安装了gdb和gdbserver。你可以用which gdb或which gdbserver来轻松检查。 如果你发现你没有安装它们，它们可以很容易地从大多数软件包管理器中安装。 10.2 在GDB下启动一个进程在GDB下启动一个进程，同时还能从pwntools与该进程进行交互，这在之前是一个棘手的过程，但幸运的是，这一切都已经被解决了，而且这个过程是相当无感和便捷的。 要在GDB下从第一条指令开始启动一个进程，只需使用gdb.debug。 这应该会自动在一个新的窗口中启动调试器，以便你进行交互。如果不是这样，或者你看到关于context.terminal的错误，请查看指定终端窗口的章节。 在这个例子中，我们传入了gdbscript=&#39;continue&#39;，以使调试器恢复执行，但是你可以传入任何有效的GDB脚本命令，它们将在调试进程启动时被执行。 10.3 附加到一个正在运行的进程有时你不想在调试器下启动你的目标，但想在开发过程的某个阶段附加到它。这也已经被Pwntools便捷无缝的实现了。 10.3.1 本地进程一般来说，你会创建一个process()管道，以便与目标可执行文件交互。你可以简单地把它传递给gdb.attach()，它将神奇地打开一个新的终端窗口，在调试器中运行目标二进制文件。 一个新的窗口应该出现，你可以继续与进程进行互动，就像你通常在Pwntools中做的一样。 10.3.2 远程服务器有时你想调试的二进制文件运行在一个远程服务器上，你想调试你所连接的进程（而不是服务器本身）。只要服务器在当前机器上运行，这也可以无缝地完成。 让我们用socat伪造一个服务器! 然后我们像往常一样用远程管道连接到远程进程。 它是有效的！为了调试特定的bash进程，只要把它我们的远程对象传给gdb.attach()。Pwntools将查找连接的远程端的PID，并尝试自动连接到它。 调试器应该自动出现，你可以与进程进行交互。 10.3 调试异构架构从基于英特尔的系统中在pwntools下调试异构架构（如ARM或PowerPC）是十分容易的。 用gdb.debug(...)来代替调用process(...) 10.3.1 提示和限制运行异构架构的进程必须用gdb.debug启动，以便对其进行调试，由于QEMU的工作方式，不可能附加到一个正在运行的进程上。 需要注意的是，QEMU有一个非常有限的用来通知GDB各种库的位置存根，所以调试可能会更加困难，一些命令也无法工作。 Pwntools推荐使用Pwndbg来处理这种情况，因为它拥有专门处理QEMU存根下调试程序的能力。 10.4 故障排除（Pwntools自身）10.4.1 幕后花絮（工作详情）有时程序就是不正常工作，你需要看看Pwntools内部在调试器的设置下发生了什么。 你可以在全局范围内设置日志上下文（例如通过context.log_level=&#39;debug&#39;），也可以通过传递相同的参数，只为GDB会话设置。 你应该看到在幕后为你处理的一切操作。比如说： 10.4.2 指定一个终端窗口Pwntools[attempts to launch a new window][run_in_new_terminal]，根据你当前使用的任何窗口系统来展示你的调试器。 默认情况下，它是自动检测的： tmux or screen X11-based terminals like GNOME Terminal 如果你没有使用支持的终端环境，或者它没有以你想要的方式工作（例如，水平与垂直分割），你可以通过设置context.terminal环境变量来增加支持。 例如，下面将使用TMUX进行水平分割，而不是默认设置。 也许你是一个GNOME终端的用户，而默认的设置并不工作？ 你可以指定任何你喜欢的终端，甚至可以把设置放在~/.pwn.conf里面，这样它就会被用于你的所有脚本了 10.4.3 环境变量Pwntools允许你通过process()指定任何你喜欢的环境变量，对于gdb.debug()也是如此。 CWD 不幸的是，当使用gdb.debug()时，该进程是在gdbserver下启动的，它增加了自己的环境变量。当环境必须被非常仔细地控制时，这可能会带来复杂的情况。 这只在你用gdb.debug()在调试器下启动进程时发生。如果你能够启动你的进程，然后用gdb.attach()附加，你就可以避免这个问题。 环境变量排序 一些漏洞可能需要某些环境变量以特定的顺序出现。但是Python2的字典是没有顺序的，这可能会加剧这个问题。 为了让你的环境变量有一个特定的顺序，我们建议使用Python3（它基于插入顺序对字典进行排序），或者使用collection.OrderedDict。 10.4.4 无法附加到进程中现代的Linux系统有一个叫做trace_scope的设置，它可以阻止非子进程的进程被调试。Pwntools对于它自己启动的任何进程都能解决这个问题，但是如果你必须在Pwntools之外启动一个进程，并试图通过pid附加到它（例如gdb.attach(1234)），你可能被阻止附加。 你可以通过禁用安全设置和重启机器来解决这个问题： 10.4.5 argv0 and argc==0有些题目要求在启动时将argv[0]设置为一个特定的值，甚至要求它是NULL（即argc==0）。 通过gdb.debug()不可能用这种配置启动一个processs，但你可以使用gdb.attach()。这是因为在gdbserver下启动二进制文件的限制。 十一、ROP11.1 背景面向返回的编程（ROP）是一种绕过NX（no-execute，也称为预防数据执行（DEP））的技术。 Pwntools有几个特点，使ROP的利用更简单，但只适用于i386和amd64架构。 11.2 加载一个ELF要创建一个ROP对象，只需向它传递一个ELF文件。 这将自动加载二进制文件，并从其中提取大多数简单的gadgets。例如，如果你想加载rbx寄存器。 11.2.1 修复地址在这里，我们可以看到gadgets的地址，它的反汇编内容，它加载了什么寄存器，以及gadgets执行时堆栈被调整了多少。 由于在我们的例子中，/bin/sh是地址无关的（即使用ASLR），我们可以先调整ELF对象上的加载地址。 11.3 检查gadgets你可以通过魔法访问器询问ROP对象如何加载你想要的任何寄存器。我们在上面使用了rbx，但是我们也可以寻找其他的寄存器。 如果寄存器不能被加载，返回值为None。在我们的例子中，假如没有pop rcx; ret的gadgets： 11.3.1 查看所有gadgetsPwntools有意排除了大多数非实质性的gadgets，但你可以通过查看ROP.gadgets属性看到它已经加载的列表，该属性将一个gadgets的地址映射到gadgets本身。 11.3.2 真正查看所有的gadgetsPwntools的ROP过滤掉了非实质性的小工具，所以如果它没有你想要的东西，我们建议使用ROPGadget来检查二进制文件。 11.4 添加原始数据为了将原始数据添加到ROP栈中，只需调用ROP.raw()。 11.5 导出ROP栈现在我们有了一些gadgets，让我们看看ROP栈上有什么： 11.6 提取原始字节现在我们有了一个ROP栈，我们想从它那里得到原始字节。我们可以使用byte()方法来实现这个功能。 11.7 神奇地调用函数Pwntools的ROP工具的真正威力在于能够调用任意的函数，无论是通过神奇的访问器还是通过ROP.call()例程。 注意这里它使用的是32位ABI，这是不正确的。我们也可以对64位二进制文件进行ROP，但我们需要相应地设置context.arch。我们可以使用context.binary来自动完成这个工作。 11.8 使用函数名来调用函数如果你的库在其GOT/PLT中有你想调用的函数，或者有二进制的符号，你可以直接调用函数名。 11.9 多重ELF一般来说，在你的进程的地址空间中，一次有一个以上的ELF可用。让我们看一个使用/bin/sh以及其libc的例子。最初，我们看了rop.rcx，这个gadgets是不存在的，因为bash中没有pop rcx; ret这个gadgets。然后，现在我们也有来自libc的所有gadgets了。 注意rax和rbx的gadgets是在主二进制文件中（0xAA…），而后两个是在libc（0xBB…）。 现在，让我们做一个更复杂的函数调用吧! 请注意，Pwntools能够使用pop rdx; pop r12; retgadgets，并说明堆栈上需要的额外值。还要注意的是，每个项目的符号值都在rop.dump()中获取。例如，它显示我们正在设置rdx=3435973836。 11.10 获取一个shell当我们了解了pwntools的ROP功能时，获得一个shell是很容易的！我们直接调用execve，并从内存中的某个地方找到一个&quot;/bin/sh/x00 &quot;的实例作为第一个参数传递进去。 显示我们的ROP栈 提取ROP的原始字节 十二、日志Pwntools有一个丰富的内部调试系统，可用于你自己的调试，以及弄清Pwntools幕后发生的事情。 12.1 功能当你从pwn导入*时，日志功能就导入了。这些功能如下： error warn info debug 例如： 注意，最后一行默认不显示，因为默认的日志级别是 “info”。 你可以在你的开发脚本中使用这些，而不是打印，这可以让你准确地调控你看到的调试信息量 你可以通过各种方式控制哪些日志信息是可见的，所有这些都将在下面解释。 12.2 命令行最简单的方法是在运行你的脚本时加入神奇的参数DEBUG，例如：打开最大限度的日志记录功能： 这对于查看正在发送/接收的确切字节，以及在pwntools内部发生的事情，以使你的EXP发挥作用是很有用的。 12.3 环境你也可以通过context.log_level来设置日志的粗略程度，就像你设置目标架构等的方式一样。这与在命令行中控制所有的日志语句的方式相同。 log_console 默认情况下，所有的日志都转到STDOUT。如果你想把它改成一个不同的文件，例如STDERR，你可以通过log_console设置来实现。 log_file 有时你想让你的日志转到一个特定的文件，例如log.txt，以便以后查看。你可以通过设置context.log_file来添加一个日志文件。 12.4 管道每个管子在创建时都可以单独控制其日志的粗略程度。只需将level=&#39;...&#39;传递给对象的构造。 这适用于所有的管子（process、remote等），也适用于类似管子的东西（如gdb.attach和gdb.debug）以及其他许多例程。 例如，如果你想确切地看到一些shellcode是如何组装的。 12.5 范围有时你希望所有的日志都被启用，但只针对部分漏洞脚本。你可以手动切换context.log_level，或者你可以使用一个范围内的助手。 "},{"title":"pwntools","date":"2023-05-10T16:51:30.000Z","url":"/2023/05/11/pwntools/","tags":[["pwn","/tags/pwn/"]],"categories":[[" ",""]],"content":"转自:  Author：ZERO-A-ONE Date：2022-02-24 本文翻译自：[pwntools]()-tutorial，主要是考虑到目前中文互联网中关于系统介绍pwntools使用方法的文章都比较老和杂乱，且转换为Python3后又有许多零零散散的问题，看到这个仓库中包含了很多使用技巧和调试问题的解决方案，感到可以翻译一下 这个资源库包含了一些开始使用pwntools（和pwntools）的基本教程。 这些教程并不致力于解释逆向工程或利用，而是假定读者有这方面的知识。 一、简介Pwntools是一个工具包，使选手们在CTF期间的尽可能容易的编写EXP，并使EXP尽可能的容易阅读。 有些代码每个人都写过无数次，而且每个人都有自己的方法。Pwntools的目标是以半标准的方式提供所有这些，这样你就可以停止复制粘贴相同的struct.unpack(&#39;&gt;I&#39;, x)代码，而是使用更多稍微清晰的包装器，如pack或p32甚至p64(..., endian=&#39;big&#39;, sign=True)。 除了对日常的功能进行方便的包装外，它还提供了一套非常丰富的IO管道，将所有你曾经执行过的IO封装在一个统一的界面中。从本地攻击切换到远程攻击，或者通过SSH进行本地攻击，都只是修改一行代码的工作。 最后但并非最不重要的是，它还包括一系列用于中级到高级使用情况的开发协助工具。这些工具包括给定内存泄露基元的远程符号解析（MemLeak和DynELF），ELF解析和修补（ELF），以及ROP小工具发现和调用链构建（ROP）。 二、目录 Installing Pwntools Tubes Basic Tubes Interactive Shells Processes Networking Secure Shell Serial Ports Utility Encoding and Hashing Packing / unpacking integers Pattern generation Safe evaluation Bytes vs. Strings Python2 Python3 Gotchas Context Architecture Endianness Log verbosity Timeout ELFs Reading and writing Patching Symbols Assembly Assembling shellcode Disassembling bytes Shellcraft library Constants Debugging Debugging local processes Breaking at the entry point Debugging shellcode ROP Dumping gadgets Searching for gadgets ROP stack generation Helper functions Logging Basic logging Log verbosity Progress spinners Leaking Remote Memory Declaring a leak function Leaking arbitrary memory Remote symbol resolution 三、安装Pwntools这个过程可以说是简单明了，Ubuntu 18.04和20.04是唯一 “官方支持 “的平台，因为它们是官方对软件进行自动化测试的唯二平台。 3.1 验证安装如果以下命令成功，一切都应该是OK的 3.2 其它架构如果你想为其它的架构组装或反汇编代码，你需要安装一个合适的binutils。对于Ubuntu和Mac OS X用户，安装说明可在docs.pwntools.com上找到。 四、管道管道是方便高校的I/O包装器，里面包含了你需要执行的大多数类型的I/O。 Local processes Remote TCP or UDP connections Processes running on a remote server over SSH Serial port I/O 本介绍提供了一些所提供功能的例子，但更复杂的组合是可能的。关于如何进行正则表达式匹配，以及将管道连接在一起的更多信息，请参阅完整的文档。 4.1 基础IO下面介绍一些IO中的基本功能： 接收数据 recv(n) - 接收任何数量的可用字节 recvline() - 接收数据，直到遇到换行 recvuntil(delim) - 接收数据，直到找到一个分隔符 recvregex(pattern) - 接收数据，直到满足一个与pattern重合的内容为止 recvrepeat(timeout) - 继续接收数据，直到发生超时 clean() - 丢弃所有缓冲的数据 发送数据 send(data) - 发送数据 sendline(line) - 发送数据加一个换行 操作整数 pack(int) - 打包发送一个字（word）大小的整数 unpack() - 接收并解包一个字（word）大小的整数 4.2 进程和基本功能为了创建一个与进程对话的管道，你只需创建一个进程对象并给它一个目标二进制的名字。 如果你需要提供命令行参数，或设置环境，可以使用额外的选项。更多信息请参见完整的文档。 读取二进制数据也不是一个问题。你可以用recv接收多达若干字节的数据，或者用recvn接受精确的字节数。 4.3 会话互动你在游戏服务器中获取了一个shell吗？赶快！互动地使用它是很容易的。 4.4 网络创建一个网络连接也很容易，而且有完全相同的接口。一个remote对象连接到其他地方，而一个listen对象则在等待连接。 如果你需要指定协议信息，也是很直接方便的。 侦听连接并没有多复杂。请注意，这正好是在监听一个连接，然后停止监听。 4.5 安全的ShellSSH连接也同样简单。可以将下面的代码与上面 “Hello Process “中的代码进行比较。 你还可以用SSH做更复杂的事情，如端口转发和文件上传/下载。更多信息请参见SSH教程。 4.6 串行端口如果你需要在本地进行一些黑客攻击，也有一个串行管道。一如既往，在完整的在线文档中有更多信息。 五、实用功能Pwntools大约有一半的内容是实用功能，这样你就不再需要到处复制粘贴这样的东西。 此外，你不仅得到了漂亮的小包装，作为额外的奖励，在阅读别人的漏洞代码时，一切都更清晰，更容易理解。 5.1 打包和解包整数这可能是你最常做的事情，所以它在最前面。主要的pack和unpack函数都知道context中的全局设置，如endian、bits和sign。 你也可以在函数调用中明确指定它们。 5.2 文件I/O只需调用一个函数，它就能做你想做的事。 5.3 哈希和编码能够快速的将你的数据转换成你需要的任何格式。 Base64 Hashes URL Encoding Hex Encoding Bit Manipulation and Hex Dumping Hex Dumping 5.4 样例生成样例生成是一种非常方便的方法，可以在不需要进行数学计算的情况下找到偏移量。 假设我们有一个直接的缓冲区溢出，我们生成一个样例并提供给目标应用程序。 在核心转储中，我们可能看到崩溃发生在0x61616178。我们可以不用对崩溃帧做任何分析，只需把这个数字打回去，得到一个偏移量。 六、Bytes vs. Strings当Pwntools最初（重新）编写时，大约在十年前，Python2是最受欢迎的。 多年来在Python中编写的许多EXP都假定str对象与bytes对象有1:1的映射，因为这是Python2上的工作原理。 在这一节中，我们讨论在Python3上编写EXP所需的一些变化，并阐述与Python2的对应关系。 6.1 Python2在Python2中，str类和bytes类是一样的，而且有一个1:1的映射。从来不需要对任何东西调用encode或decode – 文本就是字节，字节就是文本。 这对编写EXP来说是非常方便的，因为你只需写”\\x90\\x90\\x90\\x90 “就可以得到一个NOP滑块。Python2上所有的Pwntools管道和数据操作都支持字符串或字节。 从来没有人使用unicode对象来编写漏洞，所以unicode到字节的转换极其罕见。 6.2 Python3在 Python3 中，unicode类实际上就是str类。这有一些直接和明显的影响。 乍一看，Python3似乎让事情变得更难了，因为bytes声明的是单个的八位数（正如名字bytes所暗示的），而str用于任何基于文本的数据表示。 Pwntools花了很大力气来遵循 “最小惊喜原则”——也就是说，事情会按照你预期的方式进行。 然而，有时事情会出现一些故障。注意这里99f7e2如何被转换为c299c3b7c3a2。 这是因为文本字符串”\\x99\\xf7\\xe2 “被自动转换为UTF-8代码。这不可能是用户想要的。 作为解决方案，我们只需要以b为前缀： 好极了！ 一般来说，Python3上的Pwntools的修复方法是确保你所有的字符串都有一个b前缀。这就解决了歧义，并使一切变得简单明了。 6.3 麻烦关于Python3的bytes对象，有一个值得一提的 “麻烦”。当对它们进行迭代时，你会得到整数，而不是bytes对象。这是与Python2的巨大差异，也是一个主要的烦恼。 为了解决这个问题，我们建议使用切片，它产生长度为1bytes的对象。 七、环境context对象是一个全局的、线程感知的对象，包含了pwntools使用的各种设置。 一般来说，在一个EXP的首部，你会发现类似的东西： 这通知pwntools生成的shellcode将用于amd64，并且默认字大小为64位。 7.1 环境设置arch 目标架构。有效值是&quot;arch64&quot;、&quot;arm&quot;、&quot;i386&quot;、&quot;amd64&quot;，等等。默认是 &quot;i386&quot;。 第一次设置时，它会自动将默认的context.bits和context.endian设置为最可能的值。 bits 在目标二进制中，有多少位组成一个字，如32或64。 binary 从ELF文件中获取配置。例如：context.binary=&#39;/bin/sh&#39; log_file 将所有的日志输出送入的文件。 log_level 日志的详细程度。有效值是整数（越小越详细），以及&quot;debug&quot;、&quot;info &quot;和&quot;error &quot;等字符串值。 sign 设置整数打包/解包的是否有符号。默认为 &quot;unsigned&quot;。 terminal 用来打开新窗口的首选终端程序。默认情况下，使用x-terminal-emulator或tmux。 timeout 管道操作的默认超时范围。 update 一次设置多个值，例如context.update(arch=&#39;mips&#39;, bits=64, endian=&#39;big&#39;) 八、ELFsPwntools通过ELF类使与ELF文件的交互变得相对简单。你可以在RTD上找到完整的文档。 8.1 加载ELF文件ELF文件是按路径加载的。在被加载后，一些与安全有关的文件属性被打印出来。 8.2 使用符号表ELF文件有几组不同的符号表可用，每组都包含在&#123;name: data&#125;的字典中。 ELF.symbols 列出所有已知的符号，包括下面的符号。优先考虑PLT条目，而不是GOT条目。 ELF.got 只包含GOT表 ELF.plt 只包含PLT表 ELF.functions 只包含函数符号表（需要DWARF符号表） 这对于保持漏洞的稳健性非常有用，因为它消除了对硬编码地址的需要。 这将打印出类似下面的内容： 8.3 改变基本地址使用pwntools改变ELF文件的基址（比如为ASLR做调整）是非常直接和简单的。让我们改变bash的基址，看看所有的符号都有什么变化。 这应该打印出类似的内容： 8.4 读取ELF文件我们可以通过pwntools直接与ELF互动，就像它被加载到内存中一样，使用read、write和与packing模块中的函数命名相同。此外，你可以通过disasm方法看到反汇编。 打印出来的东西应该如下： 8.5 对ELF文件进行修补对ELF文件的修补也同样简单。 然后我们可以运行我们修改过的bash版本。 8.6 搜索ELF文件在编写EXP的时候，你经常需要找到一些字节序列。最常见的例子是搜索例如&quot;/bin/sh\\x00 &quot;的execve调用。search方法返回一个迭代器，允许你选择第一个结果，或者如果你需要一些特殊的东西（比如地址中没有坏字符），可以继续搜索。你可以选择传递一个writable参数给search，表示它应该只返回可写段的地址。 上面的例子打印的内容应该如下： 8.7 构建ELF文件通过pwntools我们可以很方便地从头开始创建一个ELF文件。所有这些功能都是上下文感知的。相关的函数是from_bytes和from_assembly。每一个都返回一个ELF对象，它可以很容易地被保存到文件中。 8.8 运行和调试ELF文件如果你有一个ELF对象，你可以直接运行或调试它。以下两个代码是等同的： 同样地，你可以启动一个调试器，并将其连接到ELF上。这在测试shellcode时是非常有用的，不需要用C语言包装器来加载和调试它。 九、汇编Pwntools使得用户在几乎所有的架构中进行汇编变得非常容易，并带有各种可以开箱即用已经生成好且依然可定制的shellcode。 在walkthrough目录中，有几个较长的shellcode教程。本页为您提供了基础知识。 9.1 基础汇编最基本的例子，是将汇编代码转换成shellcode。 9.2 现成的汇编（shellcraft）shellcraft模块会提供给你一些现成的汇编代码。它通常是可定制的。找出存在哪些shellcraft模板的最简单方法是查看RTD上的文档。 9.3 命令行工具有三个命令行工具用于与汇编进行交互。 asm disasm shellcraft asm asm工具的功能正如其名，它将汇编码转换为机器码，它为汇编指令输出的格式化提供了几个选项，当输出是一个终端时，它默认为十六进制编码。 当输出是其他东西时，它显示的是原始数据。 如果在命令行上没有提供指令，它将在stdin上获取数据。 最后，它支持一些不同的选项，通过--format选项来指定输出格式。支持的参数有raw、hex、string和elf。 disasm Disasm是asm的反义词，也就是将16进制的机器码反汇编成汇编指令。 shellcraft shellcraft命令是内部shellcraft模块的命令行接口。在命令行中，必须按arch.os.template的顺序指定完整的环境信息。 9.4 异构架构为其它非X86架构进行汇编交互，你需要自行安装适当版本的binutils。你应该看看installing.md以了解更多这方面的信息。我们唯一需要改变的是在全局环境变量中设置架构。你可以在 context.md 中看到更多关于context的信息。 9.4.1 现成汇编shellcraft模块会自动切换到相应的架构。 9.4.2 命令行工具你也可以通过使用--context命令行选项，使用命令行来汇编生成其它架构的shellcode。 十、调试Pwntools对在你的漏洞工作流程中使用调试器有丰富的支持，在开发EXP的问题出现时，调试器非常有用。 除了这里的调试资源外，你可能想通过以下项目来增强你的GDB经验： Pwndbg GDB Enhanced Features (GEF) 10.1 先前条件你的机器上应该同时安装了gdb和gdbserver。你可以用which gdb或which gdbserver来轻松检查。 如果你发现你没有安装它们，它们可以很容易地从大多数软件包管理器中安装。 10.2 在GDB下启动一个进程在GDB下启动一个进程，同时还能从pwntools与该进程进行交互，这在之前是一个棘手的过程，但幸运的是，这一切都已经被解决了，而且这个过程是相当无感和便捷的。 要在GDB下从第一条指令开始启动一个进程，只需使用gdb.debug。 这应该会自动在一个新的窗口中启动调试器，以便你进行交互。如果不是这样，或者你看到关于context.terminal的错误，请查看指定终端窗口的章节。 在这个例子中，我们传入了gdbscript=&#39;continue&#39;，以使调试器恢复执行，但是你可以传入任何有效的GDB脚本命令，它们将在调试进程启动时被执行。 10.3 附加到一个正在运行的进程有时你不想在调试器下启动你的目标，但想在开发过程的某个阶段附加到它。这也已经被Pwntools便捷无缝的实现了。 10.3.1 本地进程一般来说，你会创建一个process()管道，以便与目标可执行文件交互。你可以简单地把它传递给gdb.attach()，它将神奇地打开一个新的终端窗口，在调试器中运行目标二进制文件。 一个新的窗口应该出现，你可以继续与进程进行互动，就像你通常在Pwntools中做的一样。 10.3.2 远程服务器有时你想调试的二进制文件运行在一个远程服务器上，你想调试你所连接的进程（而不是服务器本身）。只要服务器在当前机器上运行，这也可以无缝地完成。 让我们用socat伪造一个服务器! 然后我们像往常一样用远程管道连接到远程进程。 它是有效的！为了调试特定的bash进程，只要把它我们的远程对象传给gdb.attach()。Pwntools将查找连接的远程端的PID，并尝试自动连接到它。 调试器应该自动出现，你可以与进程进行交互。 10.3 调试异构架构从基于英特尔的系统中在pwntools下调试异构架构（如ARM或PowerPC）是十分容易的。 用gdb.debug(...)来代替调用process(...) 10.3.1 提示和限制运行异构架构的进程必须用gdb.debug启动，以便对其进行调试，由于QEMU的工作方式，不可能附加到一个正在运行的进程上。 需要注意的是，QEMU有一个非常有限的用来通知GDB各种库的位置存根，所以调试可能会更加困难，一些命令也无法工作。 Pwntools推荐使用Pwndbg来处理这种情况，因为它拥有专门处理QEMU存根下调试程序的能力。 10.4 故障排除（Pwntools自身）10.4.1 幕后花絮（工作详情）有时程序就是不正常工作，你需要看看Pwntools内部在调试器的设置下发生了什么。 你可以在全局范围内设置日志上下文（例如通过context.log_level=&#39;debug&#39;），也可以通过传递相同的参数，只为GDB会话设置。 你应该看到在幕后为你处理的一切操作。比如说： 10.4.2 指定一个终端窗口Pwntools[attempts to launch a new window][run_in_new_terminal]，根据你当前使用的任何窗口系统来展示你的调试器。 默认情况下，它是自动检测的： tmux or screen X11-based terminals like GNOME Terminal 如果你没有使用支持的终端环境，或者它没有以你想要的方式工作（例如，水平与垂直分割），你可以通过设置context.terminal环境变量来增加支持。 例如，下面将使用TMUX进行水平分割，而不是默认设置。 也许你是一个GNOME终端的用户，而默认的设置并不工作？ 你可以指定任何你喜欢的终端，甚至可以把设置放在~/.pwn.conf里面，这样它就会被用于你的所有脚本了 10.4.3 环境变量Pwntools允许你通过process()指定任何你喜欢的环境变量，对于gdb.debug()也是如此。 CWD 不幸的是，当使用gdb.debug()时，该进程是在gdbserver下启动的，它增加了自己的环境变量。当环境必须被非常仔细地控制时，这可能会带来复杂的情况。 这只在你用gdb.debug()在调试器下启动进程时发生。如果你能够启动你的进程，然后用gdb.attach()附加，你就可以避免这个问题。 环境变量排序 一些漏洞可能需要某些环境变量以特定的顺序出现。但是Python2的字典是没有顺序的，这可能会加剧这个问题。 为了让你的环境变量有一个特定的顺序，我们建议使用Python3（它基于插入顺序对字典进行排序），或者使用collection.OrderedDict。 10.4.4 无法附加到进程中现代的Linux系统有一个叫做trace_scope的设置，它可以阻止非子进程的进程被调试。Pwntools对于它自己启动的任何进程都能解决这个问题，但是如果你必须在Pwntools之外启动一个进程，并试图通过pid附加到它（例如gdb.attach(1234)），你可能被阻止附加。 你可以通过禁用安全设置和重启机器来解决这个问题： 10.4.5 argv0 and argc==0有些题目要求在启动时将argv[0]设置为一个特定的值，甚至要求它是NULL（即argc==0）。 通过gdb.debug()不可能用这种配置启动一个processs，但你可以使用gdb.attach()。这是因为在gdbserver下启动二进制文件的限制。 十一、ROP11.1 背景面向返回的编程（ROP）是一种绕过NX（no-execute，也称为预防数据执行（DEP））的技术。 Pwntools有几个特点，使ROP的利用更简单，但只适用于i386和amd64架构。 11.2 加载一个ELF要创建一个ROP对象，只需向它传递一个ELF文件。 这将自动加载二进制文件，并从其中提取大多数简单的gadgets。例如，如果你想加载rbx寄存器。 11.2.1 修复地址在这里，我们可以看到gadgets的地址，它的反汇编内容，它加载了什么寄存器，以及gadgets执行时堆栈被调整了多少。 由于在我们的例子中，/bin/sh是地址无关的（即使用ASLR），我们可以先调整ELF对象上的加载地址。 11.3 检查gadgets你可以通过魔法访问器询问ROP对象如何加载你想要的任何寄存器。我们在上面使用了rbx，但是我们也可以寻找其他的寄存器。 如果寄存器不能被加载，返回值为None。在我们的例子中，假如没有pop rcx; ret的gadgets： 11.3.1 查看所有gadgetsPwntools有意排除了大多数非实质性的gadgets，但你可以通过查看ROP.gadgets属性看到它已经加载的列表，该属性将一个gadgets的地址映射到gadgets本身。 11.3.2 真正查看所有的gadgetsPwntools的ROP过滤掉了非实质性的小工具，所以如果它没有你想要的东西，我们建议使用ROPGadget来检查二进制文件。 11.4 添加原始数据为了将原始数据添加到ROP栈中，只需调用ROP.raw()。 11.5 导出ROP栈现在我们有了一些gadgets，让我们看看ROP栈上有什么： 11.6 提取原始字节现在我们有了一个ROP栈，我们想从它那里得到原始字节。我们可以使用byte()方法来实现这个功能。 11.7 神奇地调用函数Pwntools的ROP工具的真正威力在于能够调用任意的函数，无论是通过神奇的访问器还是通过ROP.call()例程。 注意这里它使用的是32位ABI，这是不正确的。我们也可以对64位二进制文件进行ROP，但我们需要相应地设置context.arch。我们可以使用context.binary来自动完成这个工作。 11.8 使用函数名来调用函数如果你的库在其GOT/PLT中有你想调用的函数，或者有二进制的符号，你可以直接调用函数名。 11.9 多重ELF一般来说，在你的进程的地址空间中，一次有一个以上的ELF可用。让我们看一个使用/bin/sh以及其libc的例子。最初，我们看了rop.rcx，这个gadgets是不存在的，因为bash中没有pop rcx; ret这个gadgets。然后，现在我们也有来自libc的所有gadgets了。 注意rax和rbx的gadgets是在主二进制文件中（0xAA…），而后两个是在libc（0xBB…）。 现在，让我们做一个更复杂的函数调用吧! 请注意，Pwntools能够使用pop rdx; pop r12; retgadgets，并说明堆栈上需要的额外值。还要注意的是，每个项目的符号值都在rop.dump()中获取。例如，它显示我们正在设置rdx=3435973836。 11.10 获取一个shell当我们了解了pwntools的ROP功能时，获得一个shell是很容易的！我们直接调用execve，并从内存中的某个地方找到一个&quot;/bin/sh/x00 &quot;的实例作为第一个参数传递进去。 显示我们的ROP栈 提取ROP的原始字节 十二、日志Pwntools有一个丰富的内部调试系统，可用于你自己的调试，以及弄清Pwntools幕后发生的事情。 12.1 功能当你从pwn导入*时，日志功能就导入了。这些功能如下： error warn info debug 例如： 注意，最后一行默认不显示，因为默认的日志级别是 “info”。 你可以在你的开发脚本中使用这些，而不是打印，这可以让你准确地调控你看到的调试信息量 你可以通过各种方式控制哪些日志信息是可见的，所有这些都将在下面解释。 12.2 命令行最简单的方法是在运行你的脚本时加入神奇的参数DEBUG，例如：打开最大限度的日志记录功能： 这对于查看正在发送/接收的确切字节，以及在pwntools内部发生的事情，以使你的EXP发挥作用是很有用的。 12.3 环境你也可以通过context.log_level来设置日志的粗略程度，就像你设置目标架构等的方式一样。这与在命令行中控制所有的日志语句的方式相同。 log_console 默认情况下，所有的日志都转到STDOUT。如果你想把它改成一个不同的文件，例如STDERR，你可以通过log_console设置来实现。 log_file 有时你想让你的日志转到一个特定的文件，例如log.txt，以便以后查看。你可以通过设置context.log_file来添加一个日志文件。 12.4 管道每个管子在创建时都可以单独控制其日志的粗略程度。只需将level=&#39;...&#39;传递给对象的构造。 这适用于所有的管子（process、remote等），也适用于类似管子的东西（如gdb.attach和gdb.debug）以及其他许多例程。 例如，如果你想确切地看到一些shellcode是如何组装的。 12.5 范围有时你希望所有的日志都被启用，但只针对部分漏洞脚本。你可以手动切换context.log_level，或者你可以使用一个范围内的助手。 "},{"title":"gcc_protection","date":"2023-05-10T10:43:51.000Z","url":"/2023/05/10/gcc-protection/","tags":[["pwn","/tags/pwn/"]],"categories":[[" ",""]],"content":"GCC编译各种保护选项 NX：-z execstack / -z noexecstack (关闭 / 开启) 不让执行栈上的数据，于是JMP ESP就不能用了 Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) 栈里插入cookie信息 PIE：-no-pie / -pie (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限 "},{"title":"PWN5-1","date":"2022-11-12T15:20:41.000Z","url":"/2022/11/12/PWN5-1/","tags":[["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":"PWN5-1题目描述及其考点题目描述：考点：格式化输出漏洞及canary保护 WP使用checksec查看程序，有canary保护无法正常溢出使用对应的ida打开程序，F5查看伪代码阅读代码，大概思路为：输入name，输出name，输入passwd，检查输入的passwd是否与取得的随机数相同，相同则拿到shell但23行输出name时编写不规范，此时就存在格式化字符串漏洞，且与输入的passwd比较的数字地址为0x804C044因此，只要输入name时修改0x804C044的值，输入passwd时输入相同的值，便可通过if可以利用格式化字符串漏洞与%n来修改0x804C044的值首先，调试程序，找到name的偏移位置 重点：可以看到偏移值为10，因此，只要将0x804C044地址输入到name，加上%10$n，在%10$n之前输入了0x804C044为4字节，因此将4赋值给name所指向的地址，即0x804C044的值改为4 再输入passwd为4，即可通过if，拿到shell EXP 解析payload:先给name赋值为0x804C044地址再给0x804C044地址赋值为4（0x804C044为4个字节） recvuntil:接受数据到 ‘:’ 为止 最后运行脚本，便拿到了shell，便可拿到flag"},{"title":"jarvisoj_level0_1","date":"2022-11-11T11:53:20.000Z","url":"/2022/11/11/jarvisoj-level0-1/","tags":[["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":"jarvisoj_level0_1题目描述及其考点题目描述：考点：基本的栈溢出 WP使用checksec查看程序使用对应的ida打开程序，F5查看伪代码没什么问题，接着看下一个函数发现有溢出漏洞，read函数，查看变量的长度，为0x80接着发现callsystem后门函数，记住地址0x400596接下来解题思路便有了，便可直接写脚本了 EXP 解析payload:先将变量填满由于程序是64位文件，需要用8个字节来填充ebp（如果是32位则需要4个字节）再将后门函数的地址溢出到ret函数，+1是为了维持堆栈平衡(?) 最后运行脚本，便拿到了shell，便可拿到flag"},{"title":"pwn1_sctf_20161","date":"2022-11-11T09:13:08.000Z","url":"/2022/11/11/pwn1-sctf-20161/","tags":[["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":"pwn1_sctf_2016_1题目描述及其考点题目描述：考点：代码阅读能力 WP使用checksec查看程序使用对应的ida打开程序，F5查看伪代码查看调用的vuln函数分析后，发现fgets()函数限制输入32个字节到变量s中，产看栈中s变量的长度为0x3c即60，无法溢出，继续查看代码发现19行replace()函数会把输入的I替换成you，1个字符变成3个字符，并在27行重新赋值给s之后，发现留了个get_flag后门函数，地址为0x8048F0D 所以，只要利用I转you，填满s变量，再溢出get_flag函数地址即可拿到flag EXP 解析payload:利用I转you，填满s变量的60个字节由于程序是32位文件，需要用4个字节来填充到ebp再将后门函数的地址溢出到ret函数，+1是为了维持堆栈平衡(?) 最后运行脚本，便拿到了shell，便可拿到flag"},{"title":"ciscn_2019_n_1 1","date":"2022-11-10T11:32:28.000Z","url":"/2022/11/10/ciscn-2019-n-1-1/","categories":[[" ",""]],"content":"ciscn_2019_n_1 1题目描述及其考点题目描述：考点：连续地址溢出变量 WP使用checksec查看程序本题重点：发现没有开地址随机化保护使用对应的ida打开程序，F5查看main函数伪代码没发现问题，再查看调用的func函数发现当变量v2等于11.28125时，程序便会打印flag，但没有给v2赋值的操作又发现v1与v2连续定义的，且没开地址随机保护，说明v1v2的地址是相连的，且程序的输入流给到了v1只要将v1的值填满，溢出的数值即填充到v2变量中查看v1v2所占空间地址，v1的地址范围为0x30～0x4，v2的地址范围为0x4～0x0因为我们无法传float型数据，所以要想办法将11.28125的内存表示存入v2变量可以将11.28125进制转化再存入到v2变量，但会有大小端序问题，故选择另外一种方式查看11.28125在程序中的表示，将值溢出到v2变量找到伪代码对应的汇编的比较v2与11.28125的那一段，找到表示11.28125的字符串，点进去解释：ucomiss指令就是将浮点寄存器xmm0的值与dword_3007f4进行比较，显然dword_3007f4的值就是要找的11.28125 EXP 最后运行脚本，便拿到了shell，便可拿到flag"},{"title":"warmup_csaw_2016 1","date":"2022-11-10T06:25:35.000Z","url":"/2022/11/10/warmup-csaw-2016-1/","categories":[[" ",""]],"content":"warmup_csaw_2016 1题目描述及其考点题目描述：考点：基本的栈溢出 WP使用checksec查看程序使用对应的ida打开程序，F5查看main函数伪代码发现有溢出漏洞，gets函数，查看传值的变量的大小为0x40字节查看别的函数，发现有留给我们查看flag的后门记住这个函数的地址0x40060D接下来解题思路便有了，便可直接写脚本了 EXP 解析payload:先将变量填满由于程序是64位文件，需要用8个字节来填充ebp（如果是32位则需要4个字节）再将后门函数的地址溢出到ret函数，+1是为了维持堆栈平衡(?) 最后运行脚本，便拿到了shell，便可拿到flag"},{"title":"rip1","date":"2022-11-10T00:51:23.000Z","url":"/2022/11/10/rip1/","tags":[["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":"rip1题目描述及其考点题目描述：考点：基本的栈溢出 WP使用checksec查看程序使用对应的ida打开程序，F5查看伪代码发现有溢出漏洞，gets函数，查看传值的变量的大小为15字节查看旁边的fun函数，发现是留给我们的shell后门记住这个fun函数的地址0x401186接下来解题思路便有了，便可直接写脚本了 EXP 解析payload:先将变量填满由于程序是64位文件，需要用8个字节来填充ebp（如果是32位则需要4个字节）再将后门函数的地址溢出到ret函数，+1是为了维持堆栈平衡(?) 最后运行脚本，便拿到了shell，便可拿到flag"},{"title":"test_your_nc","date":"2022-11-09T11:13:46.000Z","url":"/2022/11/09/test-your-nc/","tags":[["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":"test_your_nc题目描述及考点题目描述：考点：基本的pwntools使用 WP使用checksec查看程序可以得知这个程序是64位程序之后便可用ida64打开程序，按F5查看伪代码，可以看到这题目直接链接即可。我们直接根据给出的地址写个python链接脚本即可 EXP 最后运行脚本，便拿到了shell，便可拿到flag "},{"title":"无符号与有符号","date":"2022-07-09T06:05:02.000Z","url":"/2022/07/09/%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B8%8E%E6%9C%89%E7%AC%A6%E5%8F%B7/","tags":[["system","/tags/system/"]],"categories":[[" ",""]],"content":"补码最高位决定是为正负数（最高位的值取负，然后正常计算结果）补码的负数加减算术运算逻辑为：先取反减一，再运算。 无符号每位对应每位的值 转换底层二进制值不变，只是改变了解释方式。 一般结果为yes，但有符号数与无符号数做关系运算时，比较的是底层二进制的值。此处，-1等于0xffffffff，而0为0x00000000，所以结果为no。"},{"title":"系统","date":"2022-07-09T05:42:31.000Z","url":"/2022/07/09/%E7%B3%BB%E7%BB%9F/","tags":[["system","/tags/system/"]],"categories":[[" ",""]],"content":"文件万物皆文件文件就是字节序列，仅此而已 硬件计算机一直遵循着冯·诺依曼(计算机之父)所提出的体系结构 部位 描述 运算器 与控制器组成为CPU 控制器 与运算器组成为CPU 存储器 存储文件字节数据等 输入设备 键盘鼠标等 输出设备 显示器投影仪等 存储在计算机中，存储器的基本单位为字节（Byte,也可以简写为B），而进制为2^10即1024;但1字节等于8位,每位存储一个0或1 单位 进制 1Byte 8bit 1KB 1024B 1MB 1024KB 1GB 1024MB 1TB 1024GB 大端法与小端法每个字节为8位，而常见的第一位在右，此即位大端法；反之，则为小端法 我们所浏览的图片视频等等，只是一个文件而已，而文件也只是存储0和1而已;只是人们规定了文件打开的解释方式，便成了我们所看到的图片视频"},{"title":"常用命令大全","date":"2022-06-12T06:11:42.000Z","url":"/2022/06/12/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","tags":[["linux","/tags/linux/"]],"categories":[[" ",""]],"content":"命令行大全本文将写出一些常用的命令及其作用描述，具体使用方法自行查阅(可使用 man 命令查看文档，或者通过上网使用搜索引擎查阅) 导航命令 命令 描述 pwd 输出当前所在的工作目录地址名称 ls 列出目录下的内容 cd 进入某个目录 文件操作命令 命令 描述 file 查看文件的类型及其他参数 mkdir 创建一个目录 touch 修改一个文件的时间戳，如果文件名不存在则创建一个文件 cp 复制文件或目录 mv 移动文件或目录,如果移动的位置是原位置则重命名 rm 删除文件或目录,特别注意⚠️ 该操作不可逆不可撤回 ln 创建硬链接和符号链接 命令的命令 命令 描述 type 显示命令类型 which 显示可执行文件的位置｜ help 获取SHELL内建命令的帮助信息 man 显示命令的手册 alias 创建自己的命令 重定向命令 命令 描述 &amp; 后台执行命令，放于命令行末端，将程序置于后台执行，不占用SHELL | 管道符，将前一个命令的标准输出引流到后一个命令的标准输入 xargs 搭配管道符使用，将上一个命令的数据转换成命令行参数传入下一个命令 &gt; 标准输出重定向，标准输出内容重定向到文件，会将内容覆盖 &gt;&gt; 标准输出追加重定向,标准输出内容重定向到文件尾部，将新内容追加到源文件 2&gt; 标准错误重定向，标准错误内容重定向到文件，便不会直接在屏幕上输出报错 &amp;&gt; 标准输出及标准错误重定向，将所有输出都重定向到文件，此次命令不会有输出 扩展 命令 描述 echo 输出一行文本 *扩展 通配符 {}扩展 $扩展 变量扩展 $() 命令替换扩展｜ “扩展 将引号内的内容丧失特殊意义，使其成为普通字符⚠️ 某些符号除外 ‘扩展 将引号内的内容 全部 都丧失特殊意义，使其成为普通字符 \\ 转义字符，将单个有特殊意义的字符成为普通字符，或者转义为控制码 技巧 命令 描述 clear 清除终端屏幕输出 history 显示或操作命令历史列表 权限 命令 描述 id 查看用户身份 passwd 修改密码｜ umask 设置默认权限 chmod 修改文件权限 chown 修改文件所属主和所属组 chgrp 修改文件所属组 su 以其他用户身份启动SHELL sudo 以其他用户身份执行命令 进程 命令 描述 ps 查看进程｜ top 动态查看进程 jobs 查看后台执行的程序 fg 将进程置于前台 bg 将进程置于后台 kill 终止进程，向进程发送信号 killall 按名称终止进程 shutdown 关闭或重启系统 环境 命令 描述 printenv 显示部分或全部环境变量 set 显示SHELL变量和环境变量 echo 查看变量内容 alias 查看命令别名 存储挂载 命令 描述 mount 挂载文件系统 umount 卸载文件系统 fsck 检查和修复文件系统 fdisk 操作分区 dd 转换和复制文件 网络 命令 描述 ping 发送ICMP包到目标地址检测是否连通网络 ifconfig 输出网络接口信息 netstat 输出网络连接、路由表、接口统计、伪装连接、多播成员关系 ip 显示/操作路由、设备、策略路由、隧道 wget 非交互式网络下载工具 (需通过包管理器下载) ssh 远程登陆程序 scp 基于ssh协议传输文件程序 查找 命令 描述 locate 按照路径名查找文件 find 在指定目录中查找文件 归档与备份 命令 描述 gzip 压缩或解压缩文件 zip 压缩文件 tar 磁带归档实用工具 文本处理 命令 描述 nl 对行进行编号 cat 查看或者拼接文件内容 sort 以行为单位对文件内容排序 uniq 报告或者忽略相同的行 wc 统计文件中换行符、单词和字节的数量 grep 输出与正则表达式相匹配的行 head 输出文件开头部分 tail 输出文件结尾部分 cut 从每行中删除部分内容 comm 逐行比较两个已排序的文件 diff 逐行比较文件 patch 对原文件应用diff文件 sed 用于文本过滤和转换的流编辑器 "},{"title":"正则表达式","date":"2022-05-18T13:29:06.000Z","url":"/2022/05/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":[["linux","/tags/linux/"]],"categories":[[" ",""]],"content":"简介正则表达式是一种匹配文本字符串的方式，一般用来检索、替换那些符合所要求的文本字符串。要注意：不同的工具，不同的编程语言，其正则表达式都略有差异。此文以POSIX标准(大部分命令行工具的标准)来介绍 grepgrep是Linux中的一个命令程序，名为全局正则表达式输出，一般用来列出匹配的文本字符串等。 文本字符与元字符grep zip 该命令的意思为列出匹配zip字符串的文本等条目。在这里zip为最基本的文本字符，而接下来要介绍的则是元字符。 元字符就是将一些特殊符号转为特殊意义 元字符 特殊意义 . 代指任意字符 ^ 锚点，表示行首 $ 锚点，表示行尾 [] 方括号内的为待匹配字符,^在最前面表示否定，-表示范围 * 表示前面的元素会匹配0次或多次 注意 上面的元字符为BRE标准，下面为ERE,BRE需要\\转义 ? 表示前面的元素会匹配0次或1次 + 表示前面的元素会匹配1次或多次 {} 匹配指定次数,{n,m}匹配n次或至少n次,至多m次 () 将元素集合为一个元素(组) | 表示多选，‘或’的意思 POSIX字符类有时候会遇到不是按ASCII码标准的词序，而是使用aAbB..zZ；这时候用a-z表示小写字母范围则会出错，为了解决这个问题POSIX提供了一种字符类来表示范围。 字符类 描述 [:alnum:] 字母和数字字符 [:word:] 在alnum的基础上加入下划线 [:alpha:] 字母字符 [:blank:] 空格符和制表符 [:cntrl:] ASCII的控制字符 [:digit:] 数字0～9 [:graph:] 可见字符 [:lower:] 小写字符 [:punct:] 标点符号字符 [:print:] 可输出字符 [:space:] 空白字符 [:upper:] 大写字符 [:xdigit:] 用于表示十六进制数值字符 "},{"title":"位运算","date":"2022-04-15T21:30:08.000Z","url":"/2022/04/16/%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":[["c","/tags/c/"]],"categories":[[" ",""]],"content":"位运算C语言可以对二进制位进行运算，称为位运算 运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 名称 与 或 非 异或 左移 右移 用处 取1 化1 全反 取反 取乘 取除 与1 &amp; 0 = 00 &amp; 0 = 01 &amp; 1 = 1总结：当第一位与 第二位都为1则运算得1 或1 | 0 = 10 | 0 = 01 | 1 = 1总结：当第一位或 第二位之中有一位为1则运算得1 非~100 = 011~001 = 110~010 = 101总结：对每一位非运算，将每一位值取反；即0取1，1取0 异或1 ^ 0 = 10 ^ 0 = 01 ^ 1 = 0总结：当第一位与第二位相异则运算得1 左移 右移1 &lt;&lt; 2 = B100 =O4B100 &gt;&gt; 2 = 1 总结：左移是将一个数的二进制值中的每个位向左移动n位,不够则补零。十进制运算结果相当于乘以2的n次方。右移反之，即结果相当于除以2的次方，不计算余数 tips: 使用左移右移运算，比直接乘除操作执行速度要更快，会提高程序运行速度"},{"title":"链表","date":"2022-04-05T08:21:51.000Z","url":"/2022/04/05/%E9%93%BE%E8%A1%A8/","tags":[["c","/tags/c/"]],"categories":[[" ",""]],"content":"链表链表是一种数据结构,用于存储数据，基本原理大概为： 当前节点存储数据，并在节点中存入下一节点地址，可以通过当前节点访问下一节点，实现一环扣一环 代码： 该段代码简易还原了c语言单链表的实现，链表还有很多操作，例如：增删改查…"},{"title":"sqlmap","date":"2022-03-02T10:23:31.000Z","url":"/2022/03/02/sqlmap/","tags":[["sql","/tags/sql/"]],"categories":[[" ",""]],"content":"sqlmap常用命令sqlmap 基础 sqlmap -u “url（网站）” 查询是否存在注入点 --dbs [检测站点有那些数据库 ] --current-db [检测当前使用的数据库名 ] --tables -D “db_name” [列出指定数据库的所有表名,-D后面接数据库名称] --columns -T “table_name” -D “db_name” [列出指定数据库中指定数据表的列(字段)] --dump -C “columns_name” -T “table_name” -D “db_name”i [列出数据表中的行（内容）] 常用指令 指令 作用 --purge 重新扫描，会删除原先扫描记录 --tables 获取表名 --dbs 检测站点包含哪些数据库 --current-db 获取当前的数据库名 --current-user 检测当前用户 --is-dba 判断站点的当前用户是否为数据库管理员 --batch 默认确认，不询问你是否输入 --search 后面跟参数 -D -T -C搜索列（C），表（T）和数据库名称（D） --threads 10 线程，参数后空格接数字，sqlmap线程最高设置为10 --level 3 sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5 --risk 3 执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全 --privileges 查看权限 --proxy “目标地址″ 使用代理注入 "},{"title":"IPV4基础","date":"2022-02-27T11:03:37.000Z","url":"/2022/02/27/IP%E5%9F%BA%E7%A1%80/","tags":[["internet","/tags/internet/"]],"categories":[[" ",""]],"content":"IPV4：ip地址由32位二进制组成；一般被分为4组，每组8位；我们看到的一般写为十进制 IPV4结构：ip地址被分为 网络位和主机位，通过子网掩码区别划分，网络位称为网段，由对应子网掩码为1的位组成，而主机位则是后面对应为0的部分； 网络号 与 广播号： 特殊的IP地址: 由上述内容我们知道，IP是由网络位和主机位组成；但有两个特殊情况，如主机位全为1 或 0 。当主机位全为1时，我们将其称之为广播号，目标IP地址为广播号时，会将数据传输至该网络中的每一台主机；而当主机位全为0时，我们将其称之为网络号，此IP地址代表这个网络。 IP地址的分类： 一般我们会将IP地址分为ABCDE五类，而常用的一般为ABC三类，剩下两类一般用于特殊用途。 类别 范围 对应掩码 位数 A 1.0.0.0 ~ 126.255.255.255 255.0.0.0 /8 B 128.0.0.0 ~ 191.255.255.255 255.255.0.0 /16 C 192.0.0.0 ~ 223.255.255.255 255.255.255.0 /24 私网地址：三大类网络中，每类都有固定的私网地址范围 类别 范围 A 10.0.0.0 ~ 10.255.255.255 B 172.16.0.0 ~ 172.31.255.255 C 192.168.0.0 ~ 192.168.255.255 可变长的子网掩码： 直接举例吧： ip：172.16.31.0 /20 二进制：10101100.00010000.00100000.00000000 子网： 11111111.11111111.11110000.000000000 "},{"title":"linux-日常命令","date":"2022-02-23T03:19:56.000Z","url":"/2022/02/23/linux-%E6%97%A5%E5%B8%B8%E5%91%BD%E4%BB%A4/","tags":[["linux","/tags/linux/"]],"categories":[[" ",""]],"content":"命令大全操作文件和目录（即文件夹） 命令 作用 参数 mkdir 创建目录（即文件夹） cp 复制 i提示确认r文件类型u只复制不存在及更新v相关信息 mv 移动/重命名 i提示确认u只移动不存在及更新v相关信息 rm 删除 i提示确认r文件类型f忽略不存在v相关信息 ln (-s) 创建硬链接（符号链接） 程序（命令）命令 命令 作用 参数 type 显示命令类型。 which 显示可执行命令的位置。 help 获取Shell内建命令的帮助信息。 man 显示命令的手册页。 apropos 显示适合的命令清单。 whatis 显示手册页的简述。 info 显示命令的info条目。 alias 创建自己的命令。 "},{"title":"C-code-指针基础","date":"2022-02-22T03:33:31.000Z","url":"/2022/02/22/C-code/","tags":[["c","/tags/c/"]],"categories":[[" ",""]],"content":"c语言指针 名 语法 左值 可在‘=‘左边的值，即为可修改的值（或者说变量？） 指针声明 int *p,n; p=&amp;n 统配类指针 void *指针变量名，任何类型的指针都能与 void 类型的指针互相赋值 指针运算 指针的增/减会向前/后跳跃指针类型长度的字节数 数组指针 指针变量名 = 数组起始地址（即数组名） 指针参数 以地址为值传入指针参数，会修改原变量所以称输出参数 返回指针的函数 类型名* 指针变量名（形式参数表） 数组参数 参数形式int arr[] 值 数组地址或者数组名。但一般用指针参数不用数组参数，传值方式一样 动态内存(堆) int *p1 = (int *)malloc(sizeof(int)) int *array = (int *)calloc(10,sizeof(int)) 一定要释放堆需要手动释放堆内存空间，如果在一个函数内开空间函数结束也不会自动释放空间。 释放堆free(p1) 或 free(array) (好习惯：释放完将该指针指向NULL，p1=NULL;) 字符串与指针 char *ch = “hello,world” 此时字符串为常量保存在程序中，然后将字符串首地址存入指针，很像字符数组和指针的关系，但不可修改字符串的内容,且不可输入。如果想要传参，如同一般指针传参就好 参数形式 char *ch，值为保存在指针的地址 ch 函数返回字符串 返回一个存有字符串的动态变量或者全局变量的地址，或者是上一个函数中的局部变量但不能是此函数中的局部变量 指针数组 int *n[数组长度] 多级指针 访问只需要一个*，int x=15, *p=&amp;x, **q=&p; 二级指针q先访问q中的地址，再访问该地址的指针变量存入的地址，共访问两次所以为二级指针。 动态的二维数组 因为二维数组是二级指针，所以将一维数组的指针改为二维即可，即*变为** 定义函数指针 返回类型 (*指针变量)(形式参数表);double (*p2)(int); 赋值函数指针 指针变量名 = 函数名 回调函数 一个函数的参数为函数或函数指针，这个函数参数就称为回调函数。即别的函数执行时调用此函数，此函数称为回调函数 函数指针 数组 (*func[3])()={NULL, add, erase}; 注意事项！！！ 避免使用悬空指针（被释放的动态内存）和未初始化的指针 不同类型的指针之间不能赋值 数组和指针是完全不同的，数组变量存放一组同类元素，指针变量中存放一个地址 值传递是将某个类型的数值传给函数，指针传递是将某个变量的地址传给函数有了指针传递，函数的参数被分为两类：输入参数和输出参数在设计函数原型时，通常将输入参数排在前面，输出参数排在后面。 返回指针的函数必须确保返回值指向的变量在函数执行结束时依然存在 使用动态变量时必须严格防止内存泄露 指针指向的字符串为字符串常量的地址，只可以修改指针的指向，不可修改字符串 "},{"title":"C","date":"2022-02-22T05:20:31.000Z","url":"/C/index.html","categories":[[" ",""]]},{"title":"friends","date":"2022-02-22T05:28:29.000Z","url":"/friends/index.html","categories":[[" ",""]],"content":" # 这是我的 [b站主页]()"},{"title":"internet","date":"2022-02-27T11:02:59.000Z","url":"/internet/index.html","categories":[[" ",""]]},{"title":"linux","date":"2022-02-23T03:20:40.000Z","url":"/linux/index.html","categories":[[" ",""]]},{"title":"pwn","date":"2022-11-09T11:11:37.000Z","url":"/pwn/index.html","categories":[[" ",""]]},{"title":"system","date":"2022-07-09T05:41:54.000Z","url":"/system/index.html","categories":[[" ",""]]},{"title":"search","date":"2022-02-22T05:26:07.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"sql","date":"2022-03-02T10:21:41.000Z","url":"/sql/index.html","categories":[[" ",""]]},{"title":"writeup","date":"2023-05-10T17:19:29.000Z","url":"/writeup/index.html","categories":[[" ",""]]},{"title":"标签","date":"2022-02-22T05:23:46.000Z","url":"/tags/index.html","categories":[[" ",""]],"content":"🐩 pwn🐏 writeup🐣 C🐳 linux🐝 system🐙 网络🐌 sql"}]